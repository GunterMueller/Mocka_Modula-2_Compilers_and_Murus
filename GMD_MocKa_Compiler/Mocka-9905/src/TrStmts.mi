(******************************************************************************)
(* Copyright (c) 1988 by GMD Karlruhe, Germany				      *)
(* Gesellschaft fuer Mathematik und Datenverarbeitung			      *)
(* (German National Research Center for Computer Science)		      *)
(* Forschungsstelle fuer Programmstrukturen an Universitaet Karlsruhe	      *)
(* All rights reserved.							      *)
(******************************************************************************)
%( Modula_P
(******************************************************************************)
(* 91/10/09, jv, new standard procedure "move"                                *)
(* 91/09/06, jv, extended standard procedure OPEN                             *)
(* 91/08/06, jv, introduced CHANNEL OF ANY                                    *)
(* 91/07/29, jv, new standard procesdure in, out, outbyte, outword            *)
(* 91/07,    rh, installation of the process module concept of MODULA-P       *)
(* 91/01,    rh, transputer network version of MOCKA_P                        *)
(******************************************************************************)
%)

IMPLEMENTATION MODULE TrStmts;

(****************************************************************************)
IMPORT SuBase;
FROM SuAlloc   IMPORT ALLOCATE;
FROM SuErrors  IMPORT CompilerError, ERROR, SourcePosition, UndefSourcePos;
FROM SuTokens  IMPORT Ident;
FROM SuTree    IMPORT get, get1, get2, get3, get4, get5, GetIdent, 
		      Node, NodeKind;
FROM CgTypeMap IMPORT SizePROC, SizeADDRESS, SizeSHORTCARD,
		      NewProcessParamSize, TransferParamSize,
                      ReservedProcFrameSize, ReservedParamFrameSize,
                      StandardProcNEWparamSize, 
                      StandardProcDISPOSEparamSize,
%( Modula_P
		      StandardProcOpenParamSize,
%)
		      AdjustedArrayElemSize, HighFieldOffset;
FROM SuValues  IMPORT calc1, calc2, CalcOperator, 
		      ConvToBool, ConvToShortInt, 
		      ConvToShortCard, ConvToLongInt,
		      OrdOfValue, 
		      ConvertShortCardToValue, ConvertLongCardToValue,
                      MaxBitSetValue, MaxCharValue, 
		      MaxShortIntValue, MaxLongIntValue, 
		      MinLongIntValue, MaxLongCardValue,
%( Modula_P
		      MinOneValue,
%)
		      Value, ZeroValue, StringLength;
FROM DfScopes  IMPORT apply, applyControlVar, 
		      EnterWithStatement, LeaveWithStatement,
                      ErrorObject, RootObject, CompUnitObject,
		      TypeERROR, TypeCHAR, TypeADDRESS, 
		      TypeSHORTINT, TypeLONGINT, TypeLONGCARD, TypeVOID;
FROM DfTable   IMPORT Object, ObjectClass, Type, TypeClass, TypeDescription,
                      FormalParam, VariableKind, StandardProcedure;
%( CGMOBIL
   FROM CgMobil IMPORT
%)
%( OPMOBIL
   FROM OpMobil IMPORT
%)
%( NOMOBIL
   FROM NoMobil IMPORT
%)
                      AddressOperand, DataOperand, Label,
		      AddressTempo, DataTempo, 
		      ModuleIndex, UndefOperand,
                      Mode, Relation, SysProc,
		      Assign, AssignLong, AssignAddressTempo, AssignDataTempo,
		      BeginProcedure,
		      Call,
%( Modula_P
   		      StartGlobalProcess,
%)
		      Content, CopyOpenArray, Dec1, Dec2,
		      DeclareLabel, DeclareAddressTempo, DeclareDataTempo,
		      EndProcedure,
		      FixedCompareAndBranch, FixedPlus, FixedMinus, FrameBase,
		      Goto, Inc1, Inc2, LocalVariable, Mark, PlaceLabel, 
		      PostCall, PreCall,
		      ProcedureConstant, GlobalVariable,
		      Return, ReturnValue, StaticVariable, Switch, SysCall,
		      UseAddressTempo, UseDataTempo;
%( Debug
(* ++ hh 09/92 ++ *)
FROM CgDebug   IMPORT BeginDebugBlock, EndDebugBlock, LocalObjectsDebug,
		      ProcedureDebug, LineNumberDebug, LastLineNumberDebug;
%)
FROM TrBase    IMPORT Attributes, AttrKind, BooleanLabels, 
		      MaxWithNesting, TopWithStack, WithStack, OneValue,
		      ActualProcedureLevel,
		      InitAttr, SignedType, AdjustMode, ModeOf, GetRange,
                      ConstantIsInRange, RuntimeRangeCheck, IsInRange,
		      CheckLowerBound, CheckUpperBound,
		      EmitErrMsg, DontEmitErrMsg,
                      tpParNum, DemandConstFold, InhibitConstFold, 
		      GetStaticArrayFieldCount, TypeOfArithmeticValue,
		      ConvertCharToString, ConstToOp, ValueToOp, 
		      IsAddressable, IsExpression, InitTrBase, UseObject,
		      RangeCheckOption, IndexCheckOption;
FROM TrParam   IMPORT ClassExpressionlist, InitTrParam;
FROM TrExpr    IMPORT ClassExpression, Condition, InitTrExpr;
FROM TrDesig   IMPORT ClassDesignator, InitTrDesig;
FROM TrSets    IMPORT InitTrSets;
FROM TrStProc  IMPORT StandardProc, InitTrStProc;
FROM TrCompat  IMPORT AssignCompatible, Compatible, InitTrCompat;

%( Modula_P
FROM CgMobil IMPORT   UndefTempo, ParRepCtrlVarTempo,
                      SkipAddress,
                      LongIntConstant, BoolConstant,
                      DeclareStorageTempo, AdrOfStorageTempo, LabelDistConstant,
                      BeginParallel,       EndParallel,
                      BeginProcess,        EndProcess,     StartProcess,
                      ReadFromChannel,     WriteToChannel, WriteToChannelLong,
                      ReadTimer,           Delay,
                      BeginAltInput, WaitForReadyGuard, EndAltInput,
                      CheckBoolGuard, CheckAlt,
                      EnableSkip, EnableChannel, EnableTimer,
                      DisableSkip, DisableChannel, DisableTimer,
                      BeginAlternative, EndAlternative,
                      DeclareReplicatorTempo, InitReplication,
                      AssignRepControlVar,    DoReplication;
(* ++ 91/01 - rh ++ *)
FROM CgMobil IMPORT RemoteEnableChannel, RemoteDisableChannel,
                    BeginRemoteDisable, EndRemoteDisable;
(* -- rh -- *)

FROM DfScopes IMPORT  IdentTIMER, TypeTIME, TypeBOOLEAN;
FROM TrBase   IMPORT  TermIdent;
FROM DfScopes IMPORT  MakeReplicator, UndoMakeReplicator;

(* ++ rh *++ *)  (* 90/05 *)
FROM SuTokens IMPORT  GetIdentRepr;
FROM CgMobil  IMPORT  UndefProcIndex, ProcIndex, DeclareProcedure, DeclareModule;
FROM CgTypeMap IMPORT CompUnitProcNumber;
FROM TrBase   IMPORT  ActualPAR_NestingLevel;
IMPORT  Strings;
FROM CgConstants IMPORT PrefixOfInitModule, SuffixOfInitModule, NotProcess_p;
(* -- rh -- *)
%)
(******************************************************************************)

VAR 
  MinusOneValue           : Value;  (* represents -1 *)
  BiggestSignedType       : Type;   (* integer type with the greatest range *)
  MaxOfBiggestSignedType  : Value;  (* MAX(BiggestSignedType) *)
  ParameterSizeNEWPROCESS,
  ParameterSizeTRANSFER,
  ParameterSizeNEW,
  ParameterSizeDISPOSE    : LONGINT;
 
(******************************************************************************)
 
PROCEDURE TranslateStatementpart ( StmtpartObject : Object; body : Node );
   
  VAR 
    DefiningProc      : Object; 
			(* enclosing procedure, if StmtpartObject specifies   *)
			(* local module                                       *)
    StatementlistNode : Node;   (* root of statement list of body             *)
    returnCall        : BOOLEAN; 
			(* = TRUE, if StmtpartObject specifies a function     *)
			(*         and at least one return statement is in    *)
			(*         the function body.                         *)
    bodyClass         : NodeKind; 
    bodyPos           : SourcePosition;
    LoopNesting       : LONGCARD; (* = 0: not in LOOP context *)
    EndLabelOfActualLOOP : Label;
                        (* stack of LOOP labels. Specifies the label of the   *)
			(* actual LOOP ( if LoopNesting > 0 ).                *)
			(* Pushed (on entry) and popped (on exit) in          *)
			(* StatementLoop into (from) a local variable. Used   *)
			(* in StatementExit.                                  *)
  
%( Modula_P
   PAR_nesting : CARDINAL;  (* = 0: not in PAR context *)
   Actual_LOOP_is_contained_in_PAR : BOOLEAN;
                        (* stack of boolean values:                          *)
                        (* TRUE,  if the actual LOOP is contained in a       *)
                        (*        PAR statement.                             *)
                        (* FALSE, if the actual LOOP is defined outside      *)
                        (*        of a PAR statement.                        *)
                        (* Pushed (on entry) and popped (on exit) in         *)
                        (* StatementLoop into (from) a local variable. Used  *)
                        (* in StatementExit.                                 *)

(* ++ rh ++ *)  (* 90/05/30 *)
   MoreThanOneStatement : BOOLEAN; (* check if a statement sequence has more *)
   ProcessCallAppeared  : BOOLEAN; (* than one statement; needed for a       *)
   LastProcessPos : SourcePosition;(* process call must be the only statement*)
                                   (* of a component of a PAR statement      *)
   procindex            : ProcIndex;
   moduleindex          : ModuleIndex;
   ProcOperand          : DataOperand;
   ModName              : ARRAY [1..80] OF CHAR;
   InitModName          : ARRAY [1..80] OF CHAR;

 CONST
   NumberOfInitProc     = CompUnitProcNumber;
   NameOfInitProc       = "_INIT";
(* -- rh -- *)
%)

  (*--------------------------------------------------------------------------*)

  PROCEDURE ClassStatementlist ( node : Node );
   
    VAR 
      statement, statements  : Node; 
      statementsClass        : NodeKind; 
      statementsPos          : SourcePosition;
   
    (*------------------------------------------------------------------------*)

    PROCEDURE ClassStatement;
   
      VAR statementClass : NodeKind; statementPos : SourcePosition;

      (*----------------------------------------------------------------------*)
     
      PROCEDURE NodeStatementAssign;
      VAR 
	lhsNode, rhsNode : Node; 
	lhs, rhs         : Attributes; 
	lhsBaseType      : Type;
	op               : DataOperand;
	len              : LONGINT; (* number characters, if rhs is a string *)
      BEGIN (* NodeStatementAssign *)
     
	lhs           := InitAttr;
	rhs           := InitAttr;
	lhsBaseType   := TypeERROR;
	len           := 0;
	get2 (statement, lhsNode, rhsNode);

%( Debug
	  LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%) 
       
	RValue (rhsNode,rhs);
	LValue (lhsNode,lhs);

	(* SC: lhs Expression must be a variable.                          *)
	(*     Whether the lhs is a variable or not is checked in LValue.  *)
	(* SC: rhs and lhs expressions must be assignment compatible.      *)
	 
	IF (rhs.kind = IsError) OR (lhs.kind = IsError) THEN
	ELSIF AssignCompatible (lhs.type,rhs,EmitErrMsg,statementPos) THEN
	 
	  IF NOT IsInRange (lhs.type,TRUE,TRUE,rhs) THEN RETURN END;
	  IF rhs.type^.class=ClassSTRING THEN len := StringLength (rhs.val) END;
	  IF lhs.type^.class = SubrangeType THEN 
	    lhsBaseType := lhs.type^.BaseTypeOfSubrangeType
	  ELSE
	    lhsBaseType := lhs.type;
	  END; (* IF *)
	  CASE lhsBaseType^.class OF
	  | ClassSHORTCARD, ClassLONGCARD,
	    ClassSHORTINT, ClassLONGINT, 
	    ClassSIorSCorLIorLC, ClassSCorLIorLC, EnumerationType, ClassSIorLI,
	    ClassREAL, ClassSRorLR, ClassLONGREAL,
	    ClassBOOLEAN, ClassCHAR,
	    ClassADDRESS, ClassNIL, ClassOPAQUE, PointerType,
%( Modula_P
            ClassTIME,
%)
	    ClassBITSET, SetType, ClassWORD, ProcedureType, ClassPROC:
	      IF rhs.kind = IsConstant THEN 
		ConstToOp (rhs,lhs.type);
	      ELSE
		IF RangeCheckOption THEN
		  RuntimeRangeCheck 
		    (lhs.type,CheckLowerBound,CheckUpperBound,rhs);
		END; (* IF *)
		AdjustMode (rhs.type,lhs.type,rhs.op,rhs.op);
	      END;
	      Assign (ModeOf(lhs.type),lhs.op,rhs.op);
	  | ArrayType:
	      IF rhs.type^.class = ClassCHAR THEN
		ConvertCharToString (rhs);
		ConstToOp (rhs,rhs.type);
		len := 1;
		IF GetStaticArrayFieldCount(lhs.type) > 1 THEN len:=2 END;
		AssignLong (len,lhs.op,rhs.op);
	      ELSIF rhs.type^.class = ClassSTRING THEN
		ConstToOp (rhs,rhs.type);
		IF GetStaticArrayFieldCount(lhs.type) > len THEN INC(len) END;
		AssignLong (len,lhs.op,rhs.op)
	      ELSE
	        AssignLong (lhs.type^.size,lhs.op,rhs.op)
	      END; (* IF *)
	  | RecordType:
	      AssignLong (lhs.type^.size,lhs.op,rhs.op)
%( Modula_P
          | ChannelType :
              AssignLong (lhs.type^.size,lhs.op,rhs.op)
          | ChannelOfAnyType :
              AssignLong (lhs.type^.size,lhs.op,rhs.op)
%)
	  | ClassERROR:
	  ELSE (* CASE *)
	    CompilerError ("assertion violation");
	  END; (* CASE *)
	END; (* IF *)
      END NodeStatementAssign;
     
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementCall;
      VAR 
	ProcDesignator         : Node; (* ClassDesignator *)
	APList                 : Node; (* ClassExpressionlist *)
	ProcDesignatorAttr     : Attributes;
	DummyAttr              : Attributes;
	DummyAttr1             : Attributes;
	ParamCount             : tpParNum;
	ActualParameterListOK  : BOOLEAN;
	ResultType             : Type;
%( Modula_P
	PlacementNode          : Node;
	PlacementAttr          : Attributes;
	PlacementClass         : NodeKind;
	PlacementPos           : SourcePosition;
%)

      BEGIN (* NodeStatementCall *)
	ProcDesignatorAttr := InitAttr;
	DummyAttr          := InitAttr;
	DummyAttr1         := InitAttr;
	ParamCount := 0;
	ActualParameterListOK := FALSE;
	
%( ~ Modula_P
	get2 (statement,ProcDesignator,APList);
%)
%( Modula_P
	get3 (statement,ProcDesignator,APList, PlacementNode);
        get (PlacementNode, PlacementClass, PlacementPos);
%)
%( Debug
	LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)
	ClassDesignator (ProcDesignator,ProcDesignatorAttr);
     
	(*DumpAttr (ProcDesignatorAttr);;*)
	CASE ProcDesignatorAttr.kind OF
	 
	  IsProcedureObj: (* procedure call *)
%( Modula_P
            IF   PlacementClass # PlacementEmpty
	    THEN ERROR ("'AT' not allowed here", PlacementPos);
	    END;
%)
	    ResultType := ProcDesignatorAttr.obj^.TypeOfProcedure^.ResultType;
	    IF ResultType^.class <> ClassVOID THEN
	      ERROR ("procedure expected",ProcDesignatorAttr.pos);
	    ELSE
	      PreCall (ProcDesignatorAttr.obj^.TypeOfProcedure^.ParameterSize);
	      ClassExpressionlist 
		(APList,                                     (* in    *)
		ProcDesignatorAttr,                          (* in    *)
		ProcDesignatorAttr.type^.FirstParam,         (* in    *)
		ParamCount,                                  (* inout *)
		DummyAttr,                                   (* out   *)
		ActualParameterListOK);                      (* out   *)
	      IF ActualParameterListOK THEN
		Call (ProcDesignatorAttr.op);
	      END; (* IF *)

	      PostCall (ProcDesignatorAttr.obj^.TypeOfProcedure^.ParameterSize);
	    END; (* IF *)
	 
	| IsStandardProcedureObj: 
%( Modula_P
            IF   PlacementClass # PlacementEmpty
	    THEN ERROR ("'AT' not allowed here", PlacementPos);
	    END;
%)
	    (* standard procedures allowed here are procedures *)
	    CASE ProcDesignatorAttr.obj^.ProcName OF
	      ProcINC, ProcDEC, ProcINCL, ProcEXCL, ProcHALT,
%( Modula_P
              ProcOPEN,
	      ProcOUT, ProcOUTBYTE, ProcOUTWORD, ProcIN, ProcMOVE,
%)
	      (* from module SYSTEM: *)
	      ProcNEWPROCESS, ProcTRANSFER,
	      (* additionally: *)
	      ProcNEW, ProcDISPOSE:
		CASE ProcDesignatorAttr.obj^.ProcName OF
		  ProcHALT:  PreCall (0);
		| ProcNEWPROCESS: PreCall (ParameterSizeNEWPROCESS);
		| ProcTRANSFER: PreCall (ParameterSizeTRANSFER);
		| ProcNEW: PreCall (ParameterSizeNEW);
		| ProcDISPOSE: PreCall (ParameterSizeDISPOSE);
%( Modula_P
		| ProcOPEN: PreCall (StandardProcOpenParamSize);
%)
		ELSE (* CASE *)
		END; (* CASE *)
		ClassExpressionlist 
		  (APList,                                     (* in    *)
		  ProcDesignatorAttr,                          (* in    *)
		  NIL,                                         (* in    *)
		  ParamCount,                                  (* inout *)
		  DummyAttr,                                   (* out   *)
		  ActualParameterListOK);                      (* out   *)
		(* number of parameters is checked in StandardProc          *)
		(* StandardProc has to be called even if                    *)
		(* NOT ActualParameterListOK (local stack has to be popped).*)
		StandardProc 
		  (ProcDesignatorAttr,FALSE,DummyAttr,ParamCount,
		  ActualParameterListOK,DummyAttr1);
		CASE ProcDesignatorAttr.obj^.ProcName OF
		  ProcHALT:  PostCall (0);
		| ProcNEWPROCESS: PostCall (ParameterSizeNEWPROCESS);
		| ProcTRANSFER: PostCall (ParameterSizeTRANSFER);
		| ProcNEW: PostCall (ParameterSizeNEW);
		| ProcDISPOSE: PostCall (ParameterSizeDISPOSE);
%( Modula_P
		| ProcOPEN: PostCall (StandardProcOpenParamSize);
%)
		ELSE (* CASE *)
		END; (* CASE *)
	    ELSE (* CASE *)
	      ERROR 
		("this standard procedure not allowed here", 
		ProcDesignatorAttr.pos);
	    END; (* CASE *)

%( Modula_P
(* ++ rh ++ *)  (* 90/05/22 *)
        | IsProcessObj: 
            (* process modules may be called like procedures *)
            (* but only inside a PAR statement !!!! *)
              ProcessCallAppeared := TRUE;
              LastProcessPos := ProcDesignatorAttr.pos;
              IF PAR_nesting > 0 THEN
                IF NOT MoreThanOneStatement THEN
       	          ResultType := ProcDesignatorAttr.obj^.TypeOfProcedure^.ResultType;
	          IF ResultType^.class <> ClassVOID THEN
	            ERROR ("procedure expected",ProcDesignatorAttr.pos);
	          ELSE

		    PlacementAttr.kind := IsConstant;
		    PlacementAttr.type := TypeLONGINT;
		    PlacementAttr.val  := MinOneValue;
		    IF PlacementClass = PlacementEmpty
		    THEN ConstToOp (PlacementAttr, TypeLONGINT);
		    ELSE RValue (PlacementNode, PlacementAttr);
	                 (* SC: placement expr. must be assign. *)
			 (*     comp. with LONGINT.             *)
	                 IF (PlacementAttr.type # TypeERROR) 
	                 THEN IF AssignCompatible (TypeLONGINT, 
						       PlacementAttr,
						       DontEmitErrMsg,
						       PlacementPos)
			      THEN IF PlacementAttr.kind = IsConstant
				   THEN ConstToOp (PlacementAttr, TypeLONGINT);
				   END;
                              ELSE ERROR 
	             ("'AT' expression not assignment compatible with LONGINT ",
                                   PlacementPos);
			      END;
			 END;
                    END;

	            PreCall (ProcDesignatorAttr.obj^.TypeOfProcedure^.ParameterSize);
  	            ClassExpressionlist 
		      (APList,                                     (* in    *)
		      ProcDesignatorAttr,                          (* in    *)
		      ProcDesignatorAttr.type^.FirstParam,         (* in    *)
		      ParamCount,                                  (* inout *)
		      DummyAttr,                                   (* out   *)
		      ActualParameterListOK);                      (* out   *)
	            IF ActualParameterListOK THEN
		      StartGlobalProcess (ProcDesignatorAttr.op,
                                          PlacementAttr.op, 
                            ProcDesignatorAttr.obj^.TypeOfProcedure^.ParameterSize);
	            END; (* IF *)
	            PostCall (ProcDesignatorAttr.obj^.TypeOfProcedure^.ParameterSize);
                  END;
                END;
              ELSE  (* process call is not contained in a PAR statement *)
                ERROR ('process calls only allowed inside a PAR statement',
                       ProcDesignatorAttr.pos);
              END;
(* -- rh -- *)
%)

	| IsError: (* nothing *)

	ELSE (* CASE *)

	  (* procedure variables *)
	  (* =================== *)
	   
%( Modula_P
          IF   PlacementClass # PlacementEmpty
	  THEN ERROR ("'AT' not allowed here", PlacementPos);
	  END;
%)
	  IF ProcDesignatorAttr.kind = IsError THEN
	    (* nothing *)
	  ELSIF IsAddressable (ProcDesignatorAttr) THEN
	    IF ProcDesignatorAttr.type^.class = ProcedureType THEN
	      (* assumption: substituted procedure is declared on level 0. *)
	      (* this is checked where the assignment takes place.         *)
	      ResultType  := ProcDesignatorAttr.type^.ResultType;
	      IF (ProcDesignatorAttr.type^.class = ProcedureType) AND 
		 (ResultType^.class <> ClassVOID)
	      THEN
		ERROR ("variable doesn't denote a proper procedure",
		      ProcDesignatorAttr.pos);
	      ELSE
	        PreCall (ProcDesignatorAttr.type^.ParameterSize);
		ClassExpressionlist 
		  (APList,                                     (* in    *)
		  ProcDesignatorAttr,                          (* in    *)
		  ProcDesignatorAttr.type^.FirstParam,         (* in    *)
		  ParamCount,                                  (* inout *)
		  DummyAttr,                                   (* out   *)
		  ActualParameterListOK);                      (* out   *)
		IF ActualParameterListOK THEN
		  UseObject (ProcDesignatorAttr);
		  Call (ProcDesignatorAttr.op);
		END; (* IF *)
	        PostCall (ProcDesignatorAttr.type^.ParameterSize);
	      END; (* IF *)
	    ELSIF ProcDesignatorAttr.type^.class = ClassPROC THEN
	        PreCall (0);
		ClassExpressionlist 
		  (APList,                                     (* in    *)
		  ProcDesignatorAttr,                          (* in    *)
		  NIL,
		  (*
		  ProcDesignatorAttr.type^.FirstParam,         (* in    *)
		  *)
		  ParamCount,                                  (* inout *)
		  DummyAttr,                                   (* out   *)
		  ActualParameterListOK);                      (* out   *)
		IF ActualParameterListOK THEN
		  UseObject (ProcDesignatorAttr);
		  Call (ProcDesignatorAttr.op);
		END; (* IF *)
	        PostCall (0);
	    ELSE
	      ERROR 
		("variable doesn't denote a procedure",ProcDesignatorAttr.pos);
	    END; (* IF *)
	  ELSE
	    ERROR ("procedure expected",ProcDesignatorAttr.pos);
	  END; (* IF *)
	 
	END; (* CASE *)
      END NodeStatementCall;

      (*----------------------------------------------------------------------*)
       
      PROCEDURE NodeStatementCase;
       
      (*   NodeStatementCase is concerned with several aspects of CASE        *)
      (*   choices (labels):                                                  *)
      (*    - selector/choice type compatibility,                             *)
      (*    - choice value range bounds,                                      *)
      (*    - number of CASE choices (currently restricted to 512*4), and     *)
      (*    - CASE choice usage (for tracking multiply defined choices).      *)
      (*							              *)
      (*          CONST maxCaseLabel = 512 *4 -1;                             *)
      (*          TYPE CaseDescriptor = ...                                   *)
      (*							              *)
      (*   For limiting the number of CASE choices to 2048 ('maxCaseLabel'+1),*)
      (* two variables are employed to maintain the current upper bound and   *)
      (* current lower bound choices ('curupb' and 'curlwb', respectively).   *)
      (* If 'maxCaseLabel' is exceeded then an error is emitted.  To increase *)
      (* the number of choices available, one need only increase the value of *)
      (* the constant 'maxCaseLabel'.                                         *)
      (*   The array 'LabelAlreadyUsed' tracks the choices that have been     *)
      (* defined in the current CASE statement.  When a 'LabelExpr' or a      *)
      (* 'LabelRange' is encountered, its actual value (or a range of values) *)
      (* is used to index the array, which is then marked as used.  In this   *)
      (* way, choices can be checked for previous usage by simply examining   *)
      (* the indexed boolean value.                                           *)
      (*   All values from 'CaseMinLwb' to 'CaseMaxUpb' (currently, these are *)
      (* equal to the actual values of MinLontIntValue and MaxLongIntValue,   *)
      (* respectively) can be mapped onto the 'LabelAlreadyUsed' array, but,  *)
      (* the range from 'curlwb' to 'curupb' can never exceed                 *)
      (* 'maxCaseLabelPlus1'.                                                 *)
      (*			                                              *)
      (*                   4096  4097  4098    ....  8189  8190  8199         *)
      (*                   2048  2049  2050    ...   4093  4094  4095         *)
      (*      + exprVal      0     1     2     ...   2045  2046  2047         *)
      (*                  +-----+-----+-----+-------+-----+-----+-----+       *)
      (* LabelAlreadyUsed |  0  |  1  |  2  |  ...  |2045 |2046 |2047 |       *)
      (*                  +----+------+-----+-------+-----+-----+-----+       *)
      (*      - exprVal    -2048 -2047 -2046   ...    -3    -2    -1          *)
      (*                   -4096 -4095 -4094   ...   -2051 -2050 -2049         *)

	CONST 
	  maxCaseLabel       = 512 * 4 - 1; (* ms 10/90 *)
	  maxCaseLabelPlus1  = maxCaseLabel + 1;
	TYPE
	  ChoiceLabelList    = POINTER TO ChoiceLabelListElem;
          ChoiceLabelListElem= RECORD
				 label : Label;
				 next  : ChoiceLabelList;
			       END;
	  CaseJumpTableType  = RECORD
				 high : SHORTINT; (* = -1: entries is empty *)
				 entries: ARRAY [0..maxCaseLabel] OF Label;
			       END;
	  CaseDescriptorType = RECORD
	                         selector : Attributes;
	                         ExitLabel : Label;
	                         DefaultLabel : Label; 
				   (* = ElsePartLabel, if StatementCaseElse   *)
				   (* = ErrorLabel,    if StatementCaseSimple *)
				 curlwb, curupb : LONGINT;
				 jumptab : CaseJumpTableType;
					  (* jumptab is normalized in that way*)
					  (* that the index of the lowest case*)
					  (* label is 0.                      *)
				 choicelabels : ChoiceLabelList;
					  (* Labels are ordered in order of *)
					  (* the choices.                   *)
				 labelAlreadyUsed : 
					  ARRAY [0..maxCaseLabel] OF BOOLEAN;
			       END;
	 
        VAR 
	  selectorNode, choicesNode, elsepartNode   : Node;
	  selectorClass  : NodeKind;
	  selectorOK     : BOOLEAN;
	  cd             : CaseDescriptorType;
          FirstVisit     : BOOLEAN;
	  choicelabelsOK : BOOLEAN;
	 
        (*--------------------------------------------------------------------*)
	   
	PROCEDURE InitCaseDescriptor;
	VAR i : SHORTCARD;
	BEGIN
	  WITH cd DO
	    curlwb := MAX(LONGINT); curupb := MIN(LONGINT); (* don't change ! *)
	    jumptab.high := -1;
	    FOR i:=0 TO maxCaseLabel DO 
	      jumptab.entries[i] := DefaultLabel;
	      labelAlreadyUsed[i] := FALSE;
	    END; (* FOR *)
	    choicelabels := NIL;
	  END; (* WITH *)
	END InitCaseDescriptor;
	 
	(*--------------------------------------------------------------------*)
	 
	PROCEDURE ClassChoicelist ( node : Node );
	   
	  TYPE
	    RangeList     = POINTER TO RangeListElem;
			    (* list of ranges of a choice *)
	    RangeListElem = RECORD
			      lwb, upb: LONGINT; (*lower, upper bound of range*)
			      next    : RangeList; (* next range in list      *)
			    END;
	  VAR 
	    choice, choices : Node; 
	    choicesClass    : NodeKind; 
	    choicesPos      : SourcePosition; 
	    ranges          : RangeList;
	   
	  (*------------------------------------------------------------------*)
	   
	  PROCEDURE ClassChoice ( node : Node );
	     
	    VAR labelsOfChoice, statementsOfChoice : Node; 
		choiceClass        : NodeKind; 
		choicePos          : SourcePosition;
	     
	    (*----------------------------------------------------------------*)
	     
	    PROCEDURE ClassLabellist ( node : Node );
	       
	      VAR 
		label, labels : Node; 
		labelsClass   : NodeKind; 
		labelsPos     : SourcePosition;
	     
	      (*--------------------------------------------------------------*)
	     
	      PROCEDURE ClassLabel;
	     
		VAR labelClass : NodeKind; labelPos : SourcePosition;

		(*------------------------------------------------------------*)

		PROCEDURE NodeLabelExpr;
		VAR 
		  exprNode  : Node;
		  expr      : Attributes;
		  exprVal   : LONGINT;
		  i         : SHORTINT;
		BEGIN (* NodeLabelExpr *)
		  get1 (label, exprNode);
		  CValue (exprNode,expr);
		   
		  CASE expr.type^.class OF
		 
		    ClassBOOLEAN, ClassSHORTCARD, ClassSIorSCorLIorLC, 
		    ClassSCorLIorLC, ClassCHAR, ClassSHORTINT, ClassSIorLI, 
		    ClassLONGINT, EnumerationType, SubrangeType:
		   
		      (* SC: Selector and choice types must be compatible,  *)
		      (*     and choice value must be within its associated *)
		      (*     type range.                                    *)
		      IF NOT Compatible
			       (expr.type,cd.selector.type,
			       DontEmitErrMsg,labelPos) 
		      THEN
			ERROR ("Selector and choice types are incompatible", 
			      labelPos);
			choicelabelsOK := FALSE;
			RETURN;
		      ELSIF NOT ConstantIsInRange
				 (cd.selector.type,expr.type,expr.val,expr.pos) 
		      THEN
			choicelabelsOK := FALSE;
			RETURN 
		      ELSE 
		     
			IF (expr.type^.class = ClassSHORTINT) OR
			   (expr.type^.class = ClassSIorLI)
			THEN
			  exprVal := ConvToShortInt (expr.val);
			ELSIF expr.type^.class = ClassLONGINT THEN
			  exprVal := ConvToLongInt (expr.val);
			ELSIF expr.type^.class = ClassSHORTCARD THEN
			  exprVal := ConvToShortCard (expr.val);
			ELSE
			  exprVal := OrdOfValue (expr.val);
			END; (* IF *)
		       
			(* Check exprVal against curlwb and curupb for label  *)
			(* bounds error.  If no error occurred then adjust    *)
			(* these bounds if it is necessary.                   *)
			IF exprVal < cd.curlwb THEN
			  IF exprVal > cd.curupb THEN
			    (* It is the 1st occurrence of a label in the     *)
			    (* current CASE statement.                        *)
			    cd.curupb := exprVal;
			  ELSIF ABS(cd.curupb - exprVal) > maxCaseLabel THEN
			    choicelabelsOK := FALSE;
			    ERROR 
			      ("impl. restriction: label exceeds label range", 
			      labelPos); 
			    RETURN;
			  END; (* IF *)
			  cd.curlwb := exprVal;
			ELSIF exprVal > cd.curupb THEN
			  IF ABS (exprVal - cd.curlwb) > maxCaseLabel THEN
			    choicelabelsOK := FALSE;
			    ERROR 
			      ("impl. restriction: label exceeds label range", 
			      labelPos); 
			    RETURN;
			  ELSE 
			    cd.curupb := exprVal;
			  END; (* IF *)
			END; (* IF *)
			 
			(* Check for multiple uses of choice labels.  If no   *)
			(* error occurs then mark the choice as used.         *)
			IF ABS(exprVal) > maxCaseLabel THEN
			  i := exprVal MOD maxCaseLabelPlus1;
			ELSE 
			  i := exprVal;
			END;
			IF i < 0 THEN INC(i,maxCaseLabelPlus1) END;
			IF cd.labelAlreadyUsed[i] THEN
			  (* SC: choice value cannot occur more than once.    *)
			  choicelabelsOK := FALSE;
			  ERROR ("label already defined",labelPos); 
			ELSE 
			  cd.labelAlreadyUsed[i] := TRUE;
			  AddRange (exprVal,exprVal);
			END; (* IF *)
		      END; (* IF *)
		 
		  | ClassERROR: (* nothing *)
	              choicelabelsOK := FALSE;
		 
		  ELSE (* CASE *)
	            choicelabelsOK := FALSE;
		    ERROR ("expression choice type not allowed", labelPos)
		  END; (* CASE *)
		END NodeLabelExpr;
	       
		(*------------------------------------------------------------*)

		PROCEDURE NodeLabelRange;
		VAR 
		  lwbNode, upbNode      : Node;
		  lwb, upb              : Attributes;
		  lwbClass, upbClass    : NodeKind;
		  lwbPos, upbPos        : SourcePosition;
		  lwbVal, upbVal, n, i  : LONGINT;
		  erroneous             : BOOLEAN; 
		BEGIN (* NodeLabelRange *)
		  lwbVal := MAX(LONGINT);
		  upbVal := MIN(LONGINT);
		  get2 (label,lwbNode,upbNode);
		  get (lwbNode,lwbClass,lwbPos);
		  get (upbNode,upbClass,upbPos);
		 
		  CValue (lwbNode,lwb);
		  CValue (upbNode,upb);
		 
		  (* lower bound of case label range *)
		  (* =============================== *)
		   
		  erroneous := TRUE;
		  CASE lwb.type^.class OF
		    ClassBOOLEAN, ClassSHORTCARD, ClassSIorSCorLIorLC, 
		    ClassSCorLIorLC, ClassCHAR, ClassSHORTINT, ClassSIorLI, 
		    ClassLONGINT, EnumerationType, SubrangeType:
		     
		      IF NOT Compatible
			       (lwb.type,cd.selector.type,
			       DontEmitErrMsg,lwb.pos) 
		      THEN
	                choicelabelsOK := FALSE;
			ERROR 
			  ("Selector and lwb choice types are incompatible",
			  lwb.pos);
		      ELSIF ConstantIsInRange 
			      (cd.selector.type,lwb.type,lwb.val,lwb.pos) 
		      THEN
			IF lwb.type^.class = SubrangeType THEN 
			  lwb.type := lwb.type^.BaseTypeOfSubrangeType
			END; (* IF *)
			IF (lwb.type^.class = ClassSHORTINT) OR
			   (lwb.type^.class = ClassSIorLI)
			THEN
			  lwbVal := ConvToShortInt (lwb.val)
			ELSIF lwb.type^.class = ClassSHORTCARD THEN
			  lwbVal := ConvToShortCard (lwb.val)
			ELSIF lwb.type^.class = ClassLONGINT THEN
			  lwbVal := ConvToLongInt (lwb.val)
			ELSE
			  lwbVal := OrdOfValue (lwb.val)
			END; (* IF *)
			erroneous := FALSE;
		      END; (* IF *)
		 
		  | ClassERROR:
	              choicelabelsOK := FALSE;
		  ELSE (* CASE *)
	            choicelabelsOK := FALSE;
		    ERROR ("lwb choice type not allowed", lwb.pos)
		  END; (* CASE *)
		 
		  (* upper bound of case label range *)
		  (* =============================== *)
		 
		  CASE upb.type^.class OF
		     
		    ClassBOOLEAN, ClassSHORTCARD, ClassSIorSCorLIorLC, 
		    ClassSCorLIorLC, ClassCHAR, ClassSHORTINT, ClassSIorLI, 
		    ClassLONGINT, EnumerationType, SubrangeType:
		   
		      IF NOT Compatible
			       (upb.type,cd.selector.type,
			       DontEmitErrMsg,upb.pos) 
		      THEN
	                choicelabelsOK := FALSE;
			ERROR
			  ("selector and upb choice types are incompatible", 
			  upb.pos);
			RETURN;
		      ELSIF ConstantIsInRange 
			      (cd.selector.type,upb.type,upb.val,upb.pos) 
		      THEN
			IF upb.type^.class = SubrangeType THEN 
			  upb.type := upb.type^.BaseTypeOfSubrangeType;
			END; (* IF *)
			IF (upb.type^.class = ClassSHORTINT) OR
			   (upb.type^.class = ClassSIorLI)
			THEN
			  upbVal := ConvToShortInt (upb.val);
			ELSIF upb.type^.class = ClassSHORTCARD THEN
			  upbVal := ConvToShortCard (upb.val);
			ELSIF upb.type^.class = ClassLONGINT THEN
			  upbVal := ConvToLongInt (upb.val);
			ELSE
			  upbVal := OrdOfValue (upb.val);
			END; (* IF *)
			IF erroneous THEN 
	                  choicelabelsOK := FALSE;
			  RETURN; 
			END;
		      ELSE
	                choicelabelsOK := FALSE;
			RETURN;
		      END; (* IF *)
		   
		  | ClassERROR: 
	              choicelabelsOK := FALSE;
		      RETURN;
		 
		  ELSE (* CASE *)
	            choicelabelsOK := FALSE;
		    ERROR ("upb choice type not allowed", upb.pos); RETURN;
		  END;(* CASE *)
			 
		  IF lwbVal > upbVal THEN 
	            choicelabelsOK := FALSE;
		    ERROR ("lwb exceeds upb",lwb.pos); RETURN;
		  END; (* IF *)
			     
		  (* update 'curlwb' and 'curupb' *)
		  IF lwbVal < cd.curlwb THEN
		    IF upbVal > cd.curupb THEN
		      (* 1st occurrence of a label in the current CASE stmt.*)
		      IF ABS (upbVal - lwbVal) > maxCaseLabel THEN
	                choicelabelsOK := FALSE;
			ERROR 
			  ("impl. restriction: label exceeds label range", 
			  lwb.pos); 
			RETURN;
		      END; (* IF *)
		      cd.curupb := upbVal;
		    ELSIF ABS (cd.curupb - lwbVal) > maxCaseLabel THEN
	              choicelabelsOK := FALSE;
		      ERROR 
			("impl. restriction: label exceeds label range", 
			lwb.pos); 
		      RETURN;
		    END; (* IF *)
		    cd.curlwb := lwbVal;
		  ELSIF upbVal > cd.curupb THEN
		    IF ABS (upbVal - cd.curlwb) > maxCaseLabel THEN
	              choicelabelsOK := FALSE;
		      ERROR 
			("impl. restriction: label exceeds label range", 
			upb.pos); 
		      RETURN;
		    END; (* IF *)
		    cd.curupb := upbVal;
		  END; (* IF *)
			   
		  i := lwbVal; 
		  n := lwbVal;
		  LOOP (* Add choice range to LabelAlreadyUsed list. *)
		    IF ABS(i) > maxCaseLabel THEN 
		      i := i MOD maxCaseLabelPlus1
		    END; (* IF *)
		    IF i < 0 THEN INC (i,maxCaseLabelPlus1) END;
		    IF cd.labelAlreadyUsed[i] THEN
	              choicelabelsOK := FALSE;
		      ERROR("label(s) of range already defined",upb.pos);
		      EXIT; (* because of intersection *)
		    ELSE 
		      cd.labelAlreadyUsed[i] := TRUE;
		    END; (* IF *)
		    IF n < upbVal THEN INC(i); INC(n); ELSE EXIT; END;
		  END; (* LOOP *)
		  AddRange (lwbVal,upbVal);
			   
		END NodeLabelRange;
	       
		(*------------------------------------------------------------*)
		 
		PROCEDURE AddRange ( LwbOfRange, UpbOfRange : LONGINT );
		(* Enters range into list of ranges of ClassChoicelist.   *)
		VAR oldranges : RangeList;
		BEGIN
		  oldranges := ranges;
		  NEW (ranges);
		  WITH ranges^ DO
		    lwb := LwbOfRange; upb := UpbOfRange; next := oldranges;
		  END; (* WITH *)
		END AddRange;
		 
		(*------------------------------------------------------------*)

	      BEGIN (* ClassLabel *)
		get (label,labelClass,labelPos);
		IF labelClass = LabelExpr THEN 
		  NodeLabelExpr;
		ELSIF labelClass = LabelRange THEN 
		  NodeLabelRange;
		ELSE 
		  CompilerError ("assertion violation");
		END; (* IF *)
	      END ClassLabel;
	       
	      (*--------------------------------------------------------------*)

	    BEGIN (* ClassLabellist *)
	      labels := node;
	      get (labels,labelsClass,labelsPos);
	      WHILE labelsClass = LabellistElem DO
		get2 (labels,label,labels);
		ClassLabel;
		get (labels,labelsClass,labelsPos);
	      END; (* WHILE *)
	      IF labelsClass <> LabellistEnd THEN
		CompilerError ("assertion violation");
	      END; (* IF *)
	    END ClassLabellist;
	     
	    (*----------------------------------------------------------------*)
	     
	  BEGIN (* ClassChoice *)
	    get (choice,choiceClass,choicePos);
	    IF choiceClass = Choice THEN 
	      get2 (choice,labelsOfChoice,statementsOfChoice);
	      IF FirstVisit THEN
		ClassLabellist (labelsOfChoice);
	      ELSE
		IF selectorOK AND choicelabelsOK THEN
		  PlaceLabel (cd.choicelabels^.label);
		  cd.choicelabels := cd.choicelabels^.next;
		  ClassStatementlist (statementsOfChoice);
		  Goto (cd.ExitLabel);
		ELSE
		  ClassStatementlist (statementsOfChoice);
		END; (* IF *)
	      END; (* IF *)
	    ELSE 
	      CompilerError ("assertion violation");
	    END; (* IF *)
	  END ClassChoice;
	   
	  (*------------------------------------------------------------------*)
	   
	  PROCEDURE EnterChoice;
	  VAR ptr : RangeList; oldChoices : ChoiceLabelList; i : LONGINT;
	    index : LONGINT;
	  BEGIN
	    IF ranges = NIL THEN RETURN END;
	     
	    (* Enter the label for this choice into the list of choice *)
	    (* labels for the CASE statement (at top of list).         *)
	    oldChoices := cd.choicelabels;
	    NEW (cd.choicelabels);
	    cd.choicelabels^.next := oldChoices;
	    DeclareLabel (cd.choicelabels^.label);

	    (* Enter this label into jump table elements indexed by ranges. *)
	    ptr := ranges;
	    WHILE ptr <> NIL DO
	      FOR i := ptr^.lwb TO ptr^.upb DO
		index := i - cd.curlwb;
		cd.jumptab.entries[index] := cd.choicelabels^.label;
	      END; (* FOR *)
	      ptr := ptr^.next;
	    END; (* WHILE *)
	    cd.jumptab.high := cd.curupb - cd.curlwb;
	  END EnterChoice;
	   
	  (*------------------------------------------------------------------*)
	 
	BEGIN (* ClassChoicelist *)
	  get (node,choicesClass,choicesPos);
	  IF choicesClass = ChoicelistElem THEN 
	    get2 (node,choice,choices);
	    ranges := NIL;
	    ClassChoice (choice);
	    ClassChoicelist (choices);
	    IF FirstVisit THEN
	      (* Now the lowest case label is known, because all labels in   *)
	      (* all choices of the case statement are processed.            *)
	      EnterChoice;
	    END; (* IF *)
	  ELSIF choicesClass <> ChoicelistEnd THEN
	    CompilerError ("assertion violation");
	  END; (* IF *)
	END ClassChoicelist;
	   
        (*--------------------------------------------------------------------*)

      BEGIN (* NodeStatementCase *)
        IF   statementClass = StatementCaseSimple
        THEN get2 (statement, selectorNode, choicesNode); elsepartNode := NIL;
        ELSE get3 (statement, selectorNode, choicesNode,  elsepartNode);
        END;
	get (selectorNode, selectorClass, cd.selector.pos);
%( Debug
	LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)	 
	RValue (selectorNode,cd.selector);
	selectorOK := FALSE;
	(* SC: selector must be a basic type (except REAL), *)
	(*     an enumeration type or a subrange type.      *)
	IF cd.selector.kind = IsError THEN
	  cd.selector.op := UndefOperand;
	ELSE
	  CASE cd.selector.type^.class OF
	  | ClassSHORTCARD, ClassLONGCARD, 
	    ClassSHORTINT, ClassLONGINT, 
	    ClassSIorSCorLIorLC, ClassSCorLIorLC, ClassSIorLI, ClassLIorLC,
	    ClassBOOLEAN, ClassCHAR, 
	    EnumerationType, SubrangeType:
	      IF cd.selector.kind = IsConstant THEN 
	        ConstToOp (cd.selector,cd.selector.type);
	      END; (* IF *)
	      selectorOK := TRUE;
	  ELSE
	    cd.selector.op := UndefOperand;
	    ERROR
	      ("Selector is not basic (except REAL), enum. or subr. type",
	      cd.selector.pos)
	  END; (* CASE *)
	END; (* IF *)
	 
	DeclareLabel (cd.DefaultLabel);
	DeclareLabel (cd.ExitLabel);
	InitCaseDescriptor; (* DefaultLabel has to be declared before *)
	 
	IF selectorOK THEN
	  FirstVisit := TRUE; (* evaluate jump table *)
	  choicelabelsOK := TRUE;
	  ClassChoicelist (choicesNode);
	 
	  (* Switch has to be called even if jump table is empty *)
	  Switch (ModeOf(cd.selector.type),
		 cd.curlwb,
		 cd.curupb,
		 cd.jumptab.entries,
		 cd.DefaultLabel,
		 cd.selector.op);
	END; (* IF *)
	 
	FirstVisit := FALSE; (* code emitting, uses jump table *)
	ClassChoicelist (choicesNode);
	 
	PlaceLabel (cd.DefaultLabel);
	IF statementClass = StatementCaseSimple THEN
	  PreCall (0);
	  SysCall (SysProcCaseError);
	  PostCall (0);
	ELSE (* statementClass = StatementCaseElse *)
	  ClassStatementlist (elsepartNode);
	END; (* IF *)
	 
	PlaceLabel (cd.ExitLabel);
	 
      END NodeStatementCase;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementExit;
      BEGIN
%( Modula_P
        (* SC: EXIT inside a PAR statement for a LOOP which surrounds the PAR *)
        (*     is not allowed.                                                *)
        IF   (PAR_nesting > 0) AND (NOT Actual_LOOP_is_contained_in_PAR)
        THEN ERROR (
                "EXIT the LOOP surrounding the PAR statement is not allowed.",
                statementPos);
        END;
%)
	(* SC: context must be StatementLoop. *)
	IF LoopNesting = 0 THEN
	  ERROR ("EXIT is not in LOOP context",statementPos);
	ELSE 
%( Debug
	  LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)
	  Goto (EndLabelOfActualLOOP);
	END; (* IF *)
      END NodeStatementExit;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementFor;
       
	VAR 
	  bodyNode           : Node; (* subtree repr. body of FOR statement   *)
	  byNode             : Node; (* subtree repr. FOR increment           *)
	  ctrlNode           : Node; (* subtree repr. FOR control variable    *)
	  fromNode           : Node; (* subtree repr. start value             *)
	  toNode             : Node; (* subtree repr. limit                   *)
	  by, ctrl, from, to : Attributes;
	  ctrlId             : Ident;
	  ctrlObj            : Object;
	  ctrlClass          : NodeKind;
	  ctrlPos            : SourcePosition;
	  ctrlType           : Type; (* type of control variable              *)
	  ctrlBaseType       : Type; (* base type of type of control variable *)
	  ForType            : Type; (* type used for computations/checks in  *)
				     (* the FOR statement, might my different *)
				     (* from ctrlType.                        *)
	  ctrlMode           : Mode; (* mode of ctrlType                      *)
	  ForTypeMode        : Mode; (* mode of ForType                       *)
	  bool               : Value;
	  stopVal            : Value; (* value for termination of loop exec.  *)
	  by1Val, by2Val     : Value;
	  ctrlMin            : Value; (* min. value of ctrlType               *)
	  ctrlMax            : Value; (* max. value of ctrlType               *)
	  min                : Value; (* possible min. value of control       *)
				      (* variable, min >= ctrlMin.            *)
	  max                : Value; (* possible max. value of control       *)
				      (* variable, max <= ctrlMax.            *)
	  ctrlAddressOp      : AddressOperand; (* address of control variable *)
	  ctrlDataOp         : DataOperand; (* content of control variable    *)
	  firstOp            : DataOperand; (* content of start value         *)
	  lastOp             : DataOperand; (* content of limit               *)
	  stepOp             : DataOperand; (* content of increment           *)
	  stopOp             : DataOperand; (* content of termination value   *)
	  firstTempo         : DataTempo; (* tempo for start value (if needed)*)
	  lastTempo          : DataTempo; (* tempo for limit (if needed)      *)
	  stopTempo          : DataTempo; (* tempo for termination value      *)
	  BodyLabel          : Label; (* marks beginning of FOR body          *)
	  EndLabel           : Label; (* marks instruction after FOR statement*)
	  IsInRange, success, 
	  upwards, zerostep, singlestep,
	  LoopNeverExecuted, LoopExecutedOnlyOnce,
	  StopTempoNecessary,
	  ctrlOK, ForStatementOK, InvertBy, DoubleBy   : BOOLEAN;
	 
        (*--------------------------------------------------------------------*)
	 
	PROCEDURE AnalyseForStatement ( VAR ForOK, CtrlOK : BOOLEAN );

	  VAR fromOK, toOK, byOK : BOOLEAN;
	   
          (*------------------------------------------------------------------*)
	  PROCEDURE IsAllowedCtrlType ( CtrlType : Type ) : BOOLEAN;
	  BEGIN
	    IF CtrlType^.class = SubrangeType THEN
	      CtrlType := CtrlType^.BaseTypeOfSubrangeType;
	    END; (* IF *)
	    WITH CtrlType^ DO
	      RETURN (class = ClassSHORTCARD) OR
		     (class = ClassLONGCARD) OR
		     (class = ClassSHORTINT) OR
		     (class = ClassLONGINT) OR
		     (class = ClassCHAR) OR
		     (class = ClassBOOLEAN) OR
		     (class = EnumerationType) OR
		     (class = ClassADDRESS);
	    END; (* WITH *)
	  END IsAllowedCtrlType;
          (*------------------------------------------------------------------*)
	 
	BEGIN (* AnalyseForStatement *)
	   
	  ForOK  := FALSE;
	  CtrlOK := FALSE;
	  fromOK := FALSE;
	  toOK   := FALSE;
	  byOK   := FALSE;
	   
	  (* control variable:                                                *)
	  (* =================                                                *)
	  (* SC: ctrlId must be a simple type;                                *)
	  (*     ctrlId must not be imported, or a parameter,                 *)
	  (*     or a structured variable component.                          *)
	   
	  (* Quatsch    HE 06/90 
	  get (ctrlNode,ctrlClass,ctrlPos);
	  IF ctrlClass = ExpressionError THEN
	    (* syntax error occured, error message already emitted by parser *)
	    RETURN;
	  END; (* IF *)
	  *)

	  GetIdent (ctrlNode,ctrlPos,ctrlId);
	  apply (ctrlId,ctrlPos,ctrlObj);
	  ctrlType := TypeERROR;
	  IF ctrlObj^.class = ErrorObj THEN
	    (* Control variable is not declared in current module. *)
	    (* Error message already emitted in applyControlVar.   *)
	  ELSIF ctrlObj^.class # VariableObj THEN
	    IF ctrlObj^.class = FieldObj THEN
	      ERROR 
		("control variable must not be component of a structured type",
		ctrlPos);
	    ELSE
	      ERROR ("variable expected",ctrlPos);
	    END; (* IF *)
	  ELSIF ctrlObj^.kind # LocalVar THEN
	    ERROR ("control variable cannot be a parameter",ctrlPos);
	  ELSE 
	    applyControlVar (ctrlId,ctrlPos,ctrlObj);
	    IF ctrlObj^.class # ErrorObj THEN
	      (* control variable is declared in actual module *)
	      ctrlType := ctrlObj^.TypeOfVariable;
	      IF NOT IsAllowedCtrlType (ctrlType) THEN
		ERROR ("control variable has wrong type",ctrlPos);
		ctrlType := TypeERROR; (* to avoid further error messages *)
	      ELSE
		ctrlMode := ModeOf (ctrlType);
		CtrlOK := TRUE;
	      END; (* IF *)
	    END; (* IF *)
	  END; (* IF *)

	  (* FROM expression:                                                 *)
	  (* ================                                                 *)
	  (* SC: "from" expression must be compatible with the ctrl var.      *)
	   
	  RValue (fromNode,from);
	  fromOK := FALSE;
	  IF (from.type = TypeERROR) OR (ctrlType = TypeERROR) THEN
	  ELSIF from.kind = IsProcedureObj THEN
	    ERROR ("procedure not expected here",from.pos);
	  ELSIF NOT Compatible (ctrlType,from.type,DontEmitErrMsg,from.pos) THEN
	    ERROR
	      ("starting value not compatible with control variable",from.pos);
	  ELSIF from.kind = IsConstant THEN
	    IsInRange := ConstantIsInRange 
			   (ctrlType,from.type,from.val,from.pos);
	    fromOK := IsInRange;
	  ELSE
	    IF RangeCheckOption THEN
	      RuntimeRangeCheck (ctrlType,CheckLowerBound,CheckUpperBound,from);
	    END;
	    fromOK := TRUE;
	  END;
	   
	  (* TO expression:                                                   *)
	  (* ==============                                                   *)
	  (* SC: "to" expression must be compatible with the ctrl var.        *)
	   
	  RValue (toNode,to);
	  toOK := FALSE;
	  IF (to.type = TypeERROR) OR (ctrlType = TypeERROR) THEN
	  ELSIF to.kind = IsProcedureObj THEN
	    ERROR ("procedure not expected here",to.pos);
	  ELSIF NOT Compatible (ctrlType,to.type,DontEmitErrMsg,to.pos) THEN
	    ERROR ("limit not compatible with control variable", to.pos)
	  ELSIF to.kind = IsConstant THEN
	    IsInRange := ConstantIsInRange (ctrlType,to.type,to.val,to.pos);
	    toOK := IsInRange;
	  ELSE
	    IF RangeCheckOption THEN
	      RuntimeRangeCheck (ctrlType,CheckLowerBound,CheckUpperBound,to);
	    END;
	    toOK := TRUE;
	  END;
	   
	  (* BY expression:                                                   *)
	  (* ==============                                                   *)
	  (* SC: "by" Expression must be SHORTCARD or SHORTINT or LONGINT.    *)
	   
	  CValue (byNode,by);
	  byOK := FALSE;
	  CASE by.type^.class OF
	  | ClassSHORTCARD, ClassLONGCARD, ClassSHORTINT, ClassLONGINT,
	    ClassSIorSCorLIorLC, ClassSCorLIorLC, ClassLIorLC, ClassSIorLI: 
	      byOK := TRUE;
	  | ClassERROR:
	  ELSE (* CASE *)
	    ERROR ("CARDINAL or INTEGER expected as increment", by.pos);
	  END; (* CASE *)

	  ForOK := CtrlOK AND fromOK AND toOK AND byOK;
	   
	END AnalyseForStatement;
	 
        (*--------------------------------------------------------------------*)
	 
	PROCEDURE AccessControlVariable ( VAR op : AddressOperand );
	VAR ActivationRecordBaseOp : AddressOperand;
	BEGIN 
	  IF ctrlObj^.DefiningProcedure = StmtpartObject THEN
	    (* control variable is declared in actual scope *)
	    LocalVariable (ctrlObj^.offset,op);
	  ELSIF ctrlObj^.DefiningProcedure = RootObject THEN
	    (* control variable is static *)
	    StaticVariable ( CompUnitObject^.moduleindex, ctrlObj^.offset, op);
	  ELSE (* control variable is neither local nor static *)
	    FrameBase (
	      ctrlObj^.DefiningProcedure^.procindex,
	      ctrlObj^.DefiningProcedure^.level,
	      ActivationRecordBaseOp);
	    GlobalVariable (ctrlObj^.offset,ActivationRecordBaseOp,op);
	  END; (* IF *)
	END AccessControlVariable;
	 
        (*--------------------------------------------------------------------*)

        PROCEDURE UseFirst ( VAR dop : DataOperand );
        (* Returns operand of start value (of mode 'ForTypeMode').            *)
	(* Must not be called before 'ForType' ('ForTypeMode') is evaluated ! *)
	BEGIN
	  IF from.kind = IsConstant THEN
	    ValueToOp (from.val,TypeOfArithmeticValue(from.val),ForType,dop,from.pos);
          ELSIF LoopExecutedOnlyOnce THEN
	    dop := from.op;
	    AdjustMode(from.type,ForType,dop,dop);
	  ELSE
	    UseDataTempo (ForTypeMode,firstTempo,dop);
	  END; (* IF *)
	END UseFirst;
	 
        (*--------------------------------------------------------------------*)
	 
	PROCEDURE UseLast ( VAR dop : DataOperand );
	(* Returns operand of limit (of mode 'ForTypeMode').                  *)
	(* Must not be called before 'ForType' ('ForTypeMode') is evaluated ! *)
	BEGIN
	  IF to.kind = IsConstant THEN
	    ValueToOp (to.val,TypeOfArithmeticValue(to.val),ForType,dop,to.pos);
          ELSIF LoopExecutedOnlyOnce THEN
	    dop := to.op;
	    AdjustMode(to.type,ForType,dop,dop);
	  ELSE
	    UseDataTempo (ForTypeMode,lastTempo,dop);
	  END; (* IF *)
	END UseLast;
	 
        (*--------------------------------------------------------------------*)
	 
	PROCEDURE ComputeFurtherInformation;
	 
	  (* Evaluates upwards, singlestep, zerostep, LoopNeverExecuted,      *)
	  (* LoopExecutedOnlyOnce, ForType, ForTypeMode                       *)

	  VAR ord : LONGCARD;
	   
          (*------------------------------------------------------------------*)
	   
	  PROCEDURE EvalPossibleExtremalsOfCtrl ( VAR min, max : Value );
	  (* Returns the lowest and highest possible value of the control     *)
	  (* variable. Information about starting value and limit (if one of  *)
	  (* them or both are constant expressions) is used to evaluate the   *)
	  (* extremals. 'min' and 'max' are of an arithmetic type, i.e. if    *)
	  (* the control variable is of an enumeration type, or CHAR or       *)
	  (* BOOLEAN, the ordinal values are returned.                        *)
	  VAR
	    bool     : Value;
	    success  : BOOLEAN;
	  BEGIN (* EvalPossibleExtremalsOfCtrl *)
	    min := ctrlMin;
	    max := ctrlMax;
	    (* try to use information about starting value and limit *)
	    IF upwards THEN
	      IF from.kind = IsConstant THEN (* min := Max(min,from.val) *)
		calc2 (CalcLess,min,from.val,bool,success);
		IF ConvToBool(bool) THEN min := from.val END;
	      END; (* IF *)
	      IF to.kind = IsConstant THEN (* max := Min(max,to.val) *)
		calc2 (CalcLess,to.val,max,bool,success);
		IF ConvToBool(bool) THEN max := to.val END;
	      END; (* IF *)
	    ELSE
	      IF from.kind = IsConstant THEN (* max := Min(max,from.val) *)
		calc2 (CalcLess,from.val,max,bool,success);
		IF ConvToBool(bool) THEN max := from.val END;
	      END; (* IF *)
	      IF to.kind = IsConstant THEN (* min := Max(min,to.val) *)
		calc2 (CalcLess,min,to.val,bool,success);
		IF ConvToBool(bool) THEN min := to.val END;
	      END; (* IF *)
	    END; (* IF *)
	  END EvalPossibleExtremalsOfCtrl;
	   
          (*------------------------------------------------------------------*)
	   
	  PROCEDURE CheckBy ( VAR ByOutOfCtrlRange : BOOLEAN );
	   
	  (* Returns TRUE, if the increment is out of range in such a way     *)
	  (* that no computations/checks with control variable and increment  *)
	  (* with a common mode are possible, or if the increment has a value *)
	  (* that the incremented start value would be greater/less than the  *)
	  (* limit (i.e. the loop would be executed only once).               *)
	  (* Assert: by # 0                                                   *)
	  (* If the control variable is of a signed type, then                *)
	  (*   MIN(LONGINT) <= by <= MAX(LONGINT)                             *)
	  (* else                                                             *)
	  (*   MIN(LONGINT) <= by <= MAX(LONGCARD)                            *)
	   
	  VAR 
	    helpVal, bool, bool1, bool2 : Value; 
	    success, success1, success2 : BOOLEAN;
	 
	  BEGIN (* CheckBy*)
	     
	    ByOutOfCtrlRange := FALSE;
	    IF zerostep THEN RETURN END;

	    IF SignedType (ctrlType) THEN
	       
	      (* SC: MIN(LONGINT) <= by <= MAX(LONGINT *)
	      calc2 (CalcLessOrEq,MinLongIntValue,by.val,bool1,success1);
	      calc2 (CalcLessOrEq,by.val,MaxLongIntValue,bool2,success2);
	      IF NOT ( ConvToBool (bool1) AND ConvToBool(bool2) 
	      AND success1 AND success2 )
	      THEN
		ERROR ("increment out of range",by.pos); 
		ByOutOfCtrlRange := TRUE;
		RETURN;
	      END; (* IF *)
	       
	      IF upwards THEN
		(* 1a)   0 <= min <= max:  ByOutOfCtrlRange := (by > max-min) *)
		(* 1b)   min < 0  <= max:  ByOutOfCtrlRange := (by+min > max) *)
		(* 1c)   min <= max <= 0:  ByOutOfCtrlRange := (by > max-min) *)
		calc2 (CalcLess,min,ZeroValue,bool1,success);
		calc2 (CalcLessOrEq,ZeroValue,max,bool2,success);
		IF ConvToBool(bool1) AND ConvToBool(bool2) THEN (* 1b *)
		  calc2 (CalcPlus,by.val,min,helpVal,success);
		  calc2 (CalcGreater,helpVal,max,bool,success);
		ELSE (* 1a, 1c *)
		  calc2 (CalcMinus,max,min,helpVal,success);
		  calc2 (CalcGreater,by.val,helpVal,bool,success);
		END; (* IF *)
	      ELSE (* downwards *)
		(* 2a)   0 <= min <= max:  ByOutOfCtrlRange := (by+max < min) *)
		(* 2b)   min < 0  <= max:  ByOutOfCtrlRange := (by+max < min) *)
		(* 2c)   min <= max <= 0:  ByOutOfCtrlRange := (by < min-max) *)
		calc2 (CalcLessOrEq,ZeroValue,max,bool1,success);
		IF ConvToBool(bool1) THEN (* 2a, 2b *)
		  calc2 (CalcPlus,by.val,max,helpVal,success);
		  calc2 (CalcLess,helpVal,min,bool,success);
		ELSE (* 2c *)
		  calc2 (CalcMinus,min,max,helpVal,success);
		  calc2 (CalcLess,by.val,helpVal,bool,success);
		END; (* IF *)
	      END; (* IF *)
	       
	    ELSE (* NOT SignedType(ctrlType) *)
	       
	      (* SC: MIN(LONGINT) <= by <= MAX(LONGCARD *)
	      calc2 (CalcLessOrEq,MinLongIntValue,by.val,bool1,success1);
	      calc2 (CalcLessOrEq,by.val,MaxLongCardValue,bool2,success2);
	      IF NOT ( ConvToBool (bool1) AND ConvToBool(bool2) 
	      AND success1 AND success2 )
	      THEN
		ERROR ("increment out of range",by.pos);
		ByOutOfCtrlRange := TRUE;
		RETURN;
	      END; (* IF *)
	       
	      (* IF upwards THEN                                *)
	      (*   ByOutOfCtrlRange := (max-min < by)           *)
	      (* ELSE                                           *)
	      (*   ByOutOfCtrlRange := (max+by < min);          *)
	      (* END;                                           *)
	      IF upwards THEN
		calc2 (CalcMinus,max,min,helpVal,success);
	        calc2 (CalcLess,helpVal,by.val,bool,success);
	      ELSE
		calc2 (CalcPlus,max,by.val,helpVal,success);
	        calc2 (CalcLess,helpVal,min,bool,success);
	      END; (* IF *)
	       
	    END; (* IF *)
	     
	    ByOutOfCtrlRange := ConvToBool (bool);

	  END CheckBy;
	   
          (*------------------------------------------------------------------*)
	   
	  PROCEDURE EvalForType;
	    (* side effects:                                                  *)
	    (*      - InvertBy                                                *)
	    (*      - DoubleBy                                                *)
	    (*      - ForType                                                 *)
	    (*      - by1Val                                                  *)
	    (*      - by2Val                                                  *)
	  VAR 
	    bool, bool1 : Value;
	    success : BOOLEAN;
	  BEGIN (* EvalForType *)
	    InvertBy := FALSE;
	    DoubleBy := FALSE;
	     
	    IF LoopExecutedOnlyOnce OR zerostep THEN 
	       
	      ForType := ctrlBaseType;
	       
	    ELSIF SignedType (ctrlBaseType) THEN
	       
	      IF upwards THEN
		(*       0 < by <= Max { MAX(LONGCARD), MAX(LONGINT) }        *)
		(* 1a)  by <= MAX(ctrlBaseType)         ==> ctrlBaseType      *)
		(* 1b)  by <= MAX(BiggestSignedType)    ==> BiggestSignedType *)
		(* 1c)  by > MAX(BiggestSignedType)     ==> BiggestSignedType *)
		(*                                          DoubleBy          *)
		calc2 (CalcLessOrEq,by.val,ctrlMax,bool,success);
		IF ConvToBool(bool) THEN (* 1a *)
		  ForType := ctrlBaseType;
		ELSE
		  calc2 
		    (CalcLessOrEq,by.val,MaxOfBiggestSignedType,bool1,success);
		  IF ConvToBool(bool1) THEN (* 1b *)
		    ForType := BiggestSignedType;
		  ELSE (* 1c *)
		    ForType := BiggestSignedType;
		    DoubleBy := TRUE; 
		    (* by <= MAX(BiggestSignedType)-MIN(BiggestSignedType) *)
		    (* by1 := MAX(BiggestSignedType);                      *)
		    (* by2 := by - MAX(BiggestSignedType);                 *)
		    by1Val := MaxOfBiggestSignedType;
		    calc2 
		      (CalcMinus,by.val,MaxOfBiggestSignedType,by2Val,success);
		  END; (* IF*)
		END; (* IF*)
	      ELSE (* downwards *)
		(*       MIN(BiggestSignedType) <= by < 0                     *)
		(* 2a)  MIN(ctrlBaseType) <= b          ==> ctrlBaseType      *)
		(* 2b)  MIN(BiggestSignedType) <= by    ==> BiggestSignedType *)
		calc2 (CalcLessOrEq,ctrlMin,by.val,bool,success);
		IF ConvToBool(bool) THEN (* 2a *)
		  ForType := ctrlBaseType;
		ELSE (* 2b *)
		  ForType := BiggestSignedType;
		END; (* IF *)
	      END; (* IF *)
	       
	    ELSE (* NOT SignedType(ctrlBaseType) *)
	    
	      IF upwards THEN
		(*      0 < by <= (MAX(ctrlType)-MIN(ctrlType))               *)
		(* ==>  0 < by <= MAX(ctrlType)                               *)
		(* ==>  0 < by <= MAX(ctrlBaseType)                           *)
		IF (from.type = TypeADDRESS) OR (to.type = TypeADDRESS) THEN
		  ForType := TypeLONGCARD;
		ELSE
		  ForType := ctrlBaseType;
		END; (* IF *)
	      ELSE
		(*      - (MAX(ctrlType)-MIN(ctrlType)) <= by < 0             *)
		(* ==>  - MAX(ctrlType) <= by < 0                             *)
		(* ==>  0 < -by <= MAX(ctrlType)                              *)
		IF (from.type = TypeADDRESS) OR (to.type = TypeADDRESS) THEN
		  ForType := TypeLONGCARD;
		ELSE
		  ForType := ctrlBaseType;
		END; (* IF *)
		InvertBy := TRUE;  (* i.e. DEC(ctrl,-by) *)
	      END; (* IF *)

	    END; (* IF *)
	  END EvalForType;
	   
          (*------------------------------------------------------------------*)
	 
	BEGIN (* ComputeFurtherInformation *)
	 
	  (* upwards *)
	  (* ======= *)
	   
	  calc2 (CalcGreaterOrEq,by.val,ZeroValue,bool,success);
	  upwards := ConvToBool(bool);
	   
	  (* singlestep *)
	  (* ========== *)
	   
	  IF upwards THEN
	    calc2 (CalcEq,by.val,OneValue,bool,success);
	  ELSE 
	    calc2 (CalcEq,by.val,MinusOneValue,bool,success);
	  END; (* IF*)
	  singlestep := ConvToBool(bool);

	  (* zerostep *)
	  (* ======== *)
	   
	  zerostep := FALSE;
	  calc2 (CalcEq,by.val,ZeroValue,bool,success);
	  IF success THEN
	    zerostep := ConvToBool (bool);
	  ELSE
	    CompilerError ("assertion violation");
	  END; (* IF *)

	  (* ctrlBaseType *)
	  (* ============ *)
	   
	  IF ctrlType^.class = SubrangeType THEN
	    ctrlBaseType := ctrlType^.BaseTypeOfSubrangeType;
	  ELSE
	    ctrlBaseType := ctrlType;
	  END; (* IF *)

	  (* ctrlMin, ctrlMax, min, max *)
	  (* ========================== *)

	  GetRange (ctrlType,ctrlMin,ctrlMax);
	  EvalPossibleExtremalsOfCtrl (min,max);
	  IF (ctrlBaseType^.class = ClassCHAR) OR
	     (ctrlBaseType^.class = ClassBOOLEAN) OR
	     (ctrlBaseType^.class = EnumerationType)
          THEN
	    ord := OrdOfValue(ctrlMin); ConvertLongCardToValue (ord,ctrlMin);
	    ord := OrdOfValue(ctrlMax); ConvertLongCardToValue (ord,ctrlMax);
	    ord := OrdOfValue(min);     ConvertLongCardToValue (ord,min);
	    ord := OrdOfValue(max);     ConvertLongCardToValue (ord,max);
	    IF from.kind = IsConstant THEN
	      ord := OrdOfValue(from.val); ConvertLongCardToValue(ord,from.val);
	    END;
	    IF to.kind = IsConstant THEN
	      ord := OrdOfValue(to.val); ConvertLongCardToValue (ord,to.val);
	    END;
	  END; (* IF *)

	  LoopNeverExecuted := FALSE;      (* !!! *)
	  LoopExecutedOnlyOnce := FALSE;   (* !!! *)
	   
	  (* LoopNeverExecuted *)
	  (* ================= *)
	     
	  IF (from.kind=IsConstant) AND (to.kind=IsConstant) AND NOT zerostep
	  THEN
	    IF upwards THEN
	      calc2 (CalcGreater,from.val,to.val,bool,success);
	    ELSE
	      calc2 (CalcLess,from.val,to.val,bool,success);
            END; (* IF *)
	    IF success THEN
              LoopNeverExecuted := ConvToBool(bool);
	      IF LoopNeverExecuted THEN
                LoopExecutedOnlyOnce := FALSE;
	      END; (* IF *)
	    END; (* IF *)
	  END; (* IF *)
		 
	  (* LoopExecutedOnlyOnce *)
	  (* ==================== *)
	   
	  IF NOT (LoopNeverExecuted OR zerostep) THEN
	    CheckBy (LoopExecutedOnlyOnce);
	  END; (* IF *)

	  (* ForType, ForTypeMode *)
	  (* ==================== *)
	   
	  EvalForType;
	  ForTypeMode := ModeOf (ForType);
	   
	END ComputeFurtherInformation;
	 
        (*--------------------------------------------------------------------*)
	 
	PROCEDURE ProvideOverflowTest;
	  (* side effects:                                                    *)
	  (*      - StopTempoNecessary                                        *)
	  (*      - stepVal                                                   *)
	  (*      - stopTempo                                                 *)
	  (*      - lastOp                                                    *)
	  (*      - stopOp                                                    *)
	  (*                                                                  *)
	VAR 
	  stepminusoneOp, boundOp        : DataOperand; 
	  OvflLabel                      : Label; 
	  boundVal, stepminusoneVal, inv : Value;
	  boundType                      : Type;
	BEGIN (* ProvideOverflowTest *)

	  StopTempoNecessary := FALSE;
	  IF zerostep OR LoopNeverExecuted OR LoopExecutedOnlyOnce THEN 
	    RETURN;
	  END;
	   
	  IF upwards THEN (* boundVal := MIN(ctrlType) + (step-1) *)
	    calc2 (CalcMinus,by.val,OneValue,stepminusoneVal,success);
	    calc2 (CalcPlus,ctrlMin,stepminusoneVal,boundVal,success);
	  ELSE (* boundVal := MAX(ctrlType) + (step+1) *)
	    calc2 (CalcPlus,by.val,OneValue,stepminusoneVal,success);
	    calc2 (CalcPlus,ctrlMax,stepminusoneVal,boundVal,success);
	  END; (* IF *)
	  boundType := TypeOfArithmeticValue (boundVal);
	   
	  IF to.kind = IsConstant THEN (* constant overflow/underflow test *)
	   
	    IF upwards THEN
	      calc2 (CalcLess,to.val,boundVal,bool,success);
	      IF ConvToBool(bool) THEN (* underflow possible *)
		stopVal := ctrlMin;
	      ELSE (* no underflow possible *)
                calc2 (CalcMinus,to.val,stepminusoneVal,stopVal,success);
	      END; (* IF *)
	    ELSE (* downwards *)
	      calc2 (CalcGreater,to.val,boundVal,bool,success);
	      IF ConvToBool(bool) THEN (* overflow possible *)
		stopVal := ctrlMax;
	      ELSE (* no overflow possible *)
                calc2 (CalcMinus,to.val,stepminusoneVal,stopVal,success);
	      END; (* IF *)
	    END; (* IF *)
	   
	  ELSE (* dynamic overflow / underflow test *)
	     
	    IF singlestep THEN
	     
	      (* a priori no overflow/underflow possible *)
	      (* stop := last *)
	      IF to.kind = IsConstant THEN
		stopVal := to.val;
	      ELSE
		UseLast (lastOp);
		DeclareDataTempo (ForTypeMode,stopTempo);
		AssignDataTempo (ForTypeMode,stopTempo,lastOp);
	        StopTempoNecessary := TRUE;
	      END; (* IF *)
	       
	    ELSE (* NOT singlestep *)
	     
	      (*--------------------------------------------------------------*)
	      (* (f3)                 if last < MIN(ctrlType) + (step - 1)    *)
	      (*                            [ > MAX(ctrlType) + (step + 1) ]  *)
	      (*                      then goto OVFL                          *)
	      (*--------------------------------------------------------------*)
	      DeclareLabel (OvflLabel);
	      IF upwards THEN
		UseLast (lastOp);
		ValueToOp (boundVal,boundType,ForType,boundOp,by.pos);
		FixedCompareAndBranch 
		  (ForTypeMode,RelLess,OvflLabel,lastOp,boundOp);
	      ELSE
		IF SignedType (ctrlType) THEN
		  UseLast (lastOp);
		  ValueToOp (boundVal,boundType,ForType,boundOp,by.pos);
		  FixedCompareAndBranch
		    (ForTypeMode,RelGreater,OvflLabel,lastOp,boundOp);
		ELSE
		  (* (step+1) <= 0   ==>  inv = -(step+1) >= 0                *)
		  (* assert: last >= 0 holds always                           *)
		  (*      last + inv > MAX(ctrlType)  ==>  overflow           *)
		  (* ==>  last > MAX(ctrlType) - inv   ==>  overflow          *)
		  (* ==>  MAX(ctrlType) - inv < 0      ==> always overflow    *)
		  (* ==>  MAX(ctrlType) - inv >= 0  ==> FixedCompareAndBranch *)
		  calc1 (CalcUnaryMinus,stepminusoneVal,inv,success);
		  calc2 (CalcMinus,ctrlMax,inv,boundVal,success);
		  calc2 (CalcLess,boundVal,ZeroValue,bool,success);
		  IF ConvToBool (bool) THEN (* always overflow *)
		    Goto (OvflLabel);
		  ELSE
		    UseLast (lastOp);
		    boundType := TypeOfArithmeticValue (boundVal);
		    ValueToOp (boundVal,boundType,ForType,boundOp,by.pos);
		    FixedCompareAndBranch
		      (ForTypeMode,RelGreater,OvflLabel,lastOp,boundOp);
		  END; (* IF *)
		END; (* IF *)
	      END; (* IF *)
	      (*--------------------------------------------------------------*)
	      (* (f4)                 stop := last - (step - [+] 1)           *)
	      (*--------------------------------------------------------------*)
	      UseLast (lastOp);
	      ValueToOp (stepminusoneVal,by.type,ForType,stepminusoneOp,by.pos);
	      FixedMinus (ForTypeMode,lastOp,stepminusoneOp,stopOp);
	      DeclareDataTempo (ForTypeMode,stopTempo);
	      AssignDataTempo (ForTypeMode,stopTempo,stopOp);
	      StopTempoNecessary := TRUE;
	      (*--------------------------------------------------------------*)
	      (* (f5)                 goto BODY                               *)
	      (* (f6)         OVFL:                                           *)
	      (*--------------------------------------------------------------*)
	      Goto (BodyLabel);
	      PlaceLabel (OvflLabel);
	      (*--------------------------------------------------------------*)
	      (* (f7)                 stop := MIN [MAX] (ctrlType)            *)
	      (*--------------------------------------------------------------*)
	      IF upwards THEN
		ValueToOp
		  (ctrlMin,TypeOfArithmeticValue(ctrlMin),ForType,stopOp,by.pos);
	      ELSE
		ValueToOp
		  (ctrlMax,TypeOfArithmeticValue(ctrlMax),ForType,stopOp,by.pos);
	      END; (* IF *)
	      AssignDataTempo (ForTypeMode,stopTempo,stopOp);
	       
	    END; (* IF *) (* NOT singlestep *)
	   
	  END; (* IF *) (* dynamic overflow / underflow test *)

	END ProvideOverflowTest;
	 
        (*--------------------------------------------------------------------*)
	 
	PROCEDURE GenerateForBodyCode;
	  (* side effects:                                                    *)
	  (*      - stopOp                                                    *)
	  (*      - ctrlAddressOp                                             *)
	  (*      - ctrlDataOp                                                *)
	  (*      - stepOp                                                    *)
	VAR
	  invertedByVal  : Value; 
	  invertedByType : Type;
	BEGIN (* GenerateForBodyCode *)
	  (*----------------------------------------------------------------*)
	  (* (c2,d3,f8)   BODY:                                             *)
	  (* (c3,d4,f9)           <statements>                              *)
	  (*----------------------------------------------------------------*)
	  PlaceLabel (BodyLabel);
	  ClassStatementlist (bodyNode);
	  (*----------------------------------------------------------------*)
	  (* (c4',d5',f10')	  LineNumberDebug (FOR)		            *)
	  (* (c4,d5,f10)          if ctrl >= [<=] stop then goto END        *)
	  (*----------------------------------------------------------------*)
%( Debug
	  LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)
	  IF StopTempoNecessary THEN
	    UseDataTempo (ForTypeMode,stopTempo,stopOp);
	  ELSE
	    ValueToOp 
	      (stopVal,TypeOfArithmeticValue(stopVal),ForType,stopOp,by.pos);
	  END; (* IF *)
	  AccessControlVariable (ctrlAddressOp);
	  Content (ctrlMode,ctrlAddressOp,ctrlDataOp);
	  AdjustMode (ctrlType,ForType,ctrlDataOp,ctrlDataOp);
	  IF upwards THEN
	    FixedCompareAndBranch 
	      (ForTypeMode,RelGreaterOrEqual,EndLabel,ctrlDataOp,stopOp);
	  ELSE
	    FixedCompareAndBranch 
	      (ForTypeMode,RelLessOrEqual,EndLabel,ctrlDataOp,stopOp);
	  END; (* IF *)
	  (*----------------------------------------------------------------*)
	  (* (c5,d6,f11)          INC (ctrl,step)                           *)
	  (*----------------------------------------------------------------*)
	  AccessControlVariable (ctrlAddressOp);
	  IF singlestep THEN
	    IF upwards THEN
	      Inc1 (ctrlMode,ctrlAddressOp);
	    ELSE
	      Dec1 (ctrlMode,ctrlAddressOp);
	    END; (* IF *)
	  ELSE
	    IF InvertBy THEN
	      calc1 (CalcUnaryMinus,by.val,invertedByVal,success);
	      invertedByType := TypeOfArithmeticValue (invertedByVal);
	      ValueToOp (invertedByVal,invertedByType,ctrlType,stepOp,by.pos);
	      Dec2 (ctrlMode,ctrlAddressOp,stepOp);
	    ELSIF DoubleBy THEN
	      ValueToOp
		 (by1Val,TypeOfArithmeticValue(by1Val),ctrlType,stepOp,by.pos);
	      Inc2 (ctrlMode,ctrlAddressOp,stepOp);
	      ValueToOp
		 (by2Val,TypeOfArithmeticValue(by2Val),ctrlType,stepOp,by.pos);
	      Inc2 (ctrlMode,ctrlAddressOp,stepOp);
	    ELSE
	      ValueToOp (by.val,by.type,ctrlType,stepOp,by.pos);
	      Inc2 (ctrlMode,ctrlAddressOp,stepOp);
	    END; (* IF *)
	  END; (* IF *)
	  (*----------------------------------------------------------------*)
	  (* (c6,d7,f12)          goto BODY                                 *)
	  (* (c7,d8,f13)  END:                                              *)
	  (*----------------------------------------------------------------*)
	  Goto (BodyLabel);
	  PlaceLabel (EndLabel);
	END GenerateForBodyCode;
	 
        (*--------------------------------------------------------------------*)
	 
      BEGIN (* NodeStatementFor *)
       
	ctrl               := InitAttr;
	from               := InitAttr;
	to                 := InitAttr;
	by                 := InitAttr;
	ctrlObj            := ErrorObject;
	ctrlPos            := UndefSourcePos;
	ctrlType           := TypeERROR;
	ctrlBaseType       := TypeERROR;
	ctrlMode           := ModeOf (ctrlType);
	ForType            := TypeERROR;
	ForTypeMode        := ModeOf (ForType);
	stopVal            := ZeroValue;
	by1Val             := ZeroValue;
	by2Val             := ZeroValue;
	ctrlMin            := MaxLongIntValue;
	ctrlMax            := MinLongIntValue;
	min                := MaxLongIntValue;
	max                := MinLongIntValue;
	firstOp            := UndefOperand;
	lastOp             := UndefOperand;
	stepOp             := UndefOperand;
	stopOp             := UndefOperand;
	ctrlAddressOp      := UndefOperand;
	ctrlDataOp         := UndefOperand;
	upwards            := TRUE;
	zerostep           := FALSE;
	singlestep         := TRUE;
	StopTempoNecessary := FALSE;
	InvertBy           := FALSE;
	get5 (statement, ctrlNode, fromNode, toNode, byNode, bodyNode);
	 
        AnalyseForStatement (ForStatementOK,ctrlOK);

        IF NOT ForStatementOK THEN
	 
          IF ctrlOK THEN
	    ClassStatementlist (bodyNode);
	  (*ELSE (* Too many errors expected in body of FOR statement, *)
	         (* because too many expressions might depend on the   *)
	         (* control variable.                                  *)
	  *)
	  END; (* IF *)
	   
        ELSE (* code generation is enabled *)

	  (* compute upwards, singlestep, zerostep            *)
	  (*         LoopNeverExecuted, LoopExecutedOnlyOnce, *)
	  (*         ForType, ForTypeMode.                    *)
	   
          ComputeFurtherInformation;

	  (********************************************************************)
	  (*                                                                  *)
	  (*  The following seven cases (a-h) are distinguished for code      *)
	  (*  generation.                                                     *)
	  (*  Note the correspondencies:  ctrl   =  control variable          *)
	  (*                              first  =  starting value            *)
	  (*                              last   =  limit                     *)
	  (*                              step   =  increment(decrement)      *)
	  (*  [] used for step < 0.                                           *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* a)    If LoopExecutedOnlyOnce:                                   *)
	  (*       -----------------------------------------------------------*)
	  (* (a1') 		  LineNumberDebug (FOR)			      *)
	  (* (a1)                 ctrl := first                               *)
	  (* (a2)                 <statements>                                *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* b)    Start value and limit are both constant expressions and    *)
	  (*       LoopNeverExecuted:                                         *)
	  (*       -----------------------------------------------------------*)
	  (* (b1') 		  LineNumberDebug (FOR)			      *)
	  (* (b1)                 goto END                                    *)
	  (* (b2)                 <statements>                                *)
	  (* (b3)         END:                                                *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* c)    Start value and limit are both constant expressions and    *)
	  (*       NOT (LoopExecutedOnlyOnce OR LoopNeverExecuted):           *)
	  (*       -----------------------------------------------------------*)
	  (* (c1') 		  LineNumberDebug (FOR)			      *)
	  (* (c1)                 ctrl := first                               *)
	  (* (c2)         BODY:                                               *)
	  (* (c3)                 <statements>                                *)
	  (* (c4') 		  LineNumberDebug (FOR)			      *)
	  (* (c4)                 if ctrl >= [<=] stop then goto END          *)
	  (* (c5)                 INC (ctrl,step)                             *)
	  (* (c6)                 goto BODY                                   *)
	  (* (c7)         END:                                                *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* d)    Start value is a dynamic, limit is a constant expression:  *)
	  (*       -----------------------------------------------------------*)
	  (* (d1') 		  LineNumberDebug (FOR)			      *)
	  (* (d1)                 if first > [<] last then goto END           *)
	  (* (d2)                 ctrl := first                               *)
	  (* (d3)         BODY:                                               *)
	  (* (d4)                 <statements>                                *)
	  (* (d5') 		  LineNumberDebug (FOR)			      *)
	  (* (d5)                 if ctrl >= [<=] stop then goto END          *)
	  (* (d6)                 INC (ctrl,step)                             *)
	  (* (d7)                 goto BODY                                   *)
	  (* (d8)         END:                                                *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* e)    Start value and/or limit are dynamic expressions           *)
	  (*       and LoopExecutedOnlyOnce:                                  *)
	  (*       -----------------------------------------------------------*)
	  (* (e1') 		  LineNumberDebug (FOR)			      *)
	  (* (e1)                 if first > [<] last then goto END           *)
	  (* (e2)                 ctrl := first                               *)
	  (* (e3)                 <statements>                                *)
	  (* (e4)         END:                                                *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* f)    Start value and/or limit are dynamic expressions           *)
	  (*       and NOT LoopExecutedOnlyOnce:                              *)
	  (*       -----------------------------------------------------------*)
	  (* (f1') 		  LineNumberDebug (FOR)			      *)
	  (* (f1)                 if first > [<] last then goto END           *)
	  (* (f2)                 ctrl := first                               *)
	  (* (f3)                 if last < ( MIN(ctrlType) + (step-1) )      *)
	  (*                            [ > ( MAX(ctrlType) + (step+1) ) ]    *)
	  (*                      then goto OVFL                              *)
	  (* (f4)                 stop := last - (step - [+] 1)               *)
	  (* (f5)                 goto BODY                                   *)
	  (* (f6)         OVFL:                                               *)
	  (* (f7)                 stop := MIN [MAX] (ctrlType)                *)
	  (* (f8)         BODY:                                               *)
	  (* (f9)                 <statements>                                *)
	  (* (f10') 		  LineNumberDebug (FOR)			      *)
	  (* (f10)                if ctrl >= [<=] stop then goto END          *)
	  (* (f11)                INC (ctrl,step)                             *)
	  (* (f12)                goto BODY                                   *)
	  (* (f13)        END:                                                *)
	  (*                                                                  *)
	  (********************************************************************)
	  (*                                                                  *)
	  (* h)    zerostep                                                   *)
	  (*       -----------------------------------------------------------*)
	  (* (h1') 		  LineNumberDebug (FOR)			      *)
	  (* (h1)                 ctrl := first                               *)
	  (* (h2)         BODY:                                               *)
	  (* (h3)                 <statements>                                *)
	  (* (h4') 		  LineNumberDebug (FOR)			      *)
	  (* (h4)                 goto BODY                                   *)
	  (********************************************************************)

	  (*------------------------------------------------------------------*)
	  (* (a1'..h1')             LineNumberDebug (FOR)                     *)
	  (*------------------------------------------------------------------*)
%( Debug
	  LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)

	  IF zerostep THEN

	    (*----------------------------------------------------------------*)
	    (* (h1)                 ctrl := first                             *)
	    (*----------------------------------------------------------------*)
	    AccessControlVariable (ctrlAddressOp);
	    IF from.kind = IsConstant THEN
	      ValueToOp 
		(from.val,TypeOfArithmeticValue(from.val),ctrlType,firstOp,from.pos);
	    ELSE
	      firstOp := from.op;
	      AdjustMode(ForType,ctrlType,firstOp,firstOp);
	    END;
	    Assign (ctrlMode,ctrlAddressOp,firstOp);
	    (*----------------------------------------------------------------*)
	    (* (h2)           BODY:                                           *)
	    (* (h3)                   <statements>                            *)
	    (* (h4')		      LineNumberDebug (FOR)		      *)
	    (* (h4)                   goto BODY                               *)
	    (*----------------------------------------------------------------*)
	    DeclareLabel (BodyLabel);
	    PlaceLabel (BodyLabel);
	    ClassStatementlist (bodyNode);
%( Debug
	    LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)
	    Goto (BodyLabel);
	   
	  ELSIF ( from.kind = IsConstant ) AND ( to.kind = IsConstant ) THEN
	     
	    IF LoopNeverExecuted THEN
	     
	      (*--------------------------------------------------------------*)
	      (* (b1)                 goto END                                *)
	      (* (b2)                 <statements>                            *)
	      (* (b3)         END:                                            *)
	      (*--------------------------------------------------------------*)
	      DeclareLabel (EndLabel);
	      Goto (EndLabel);
	      ClassStatementlist (bodyNode);
	      PlaceLabel (EndLabel);
	     
	    ELSIF LoopExecutedOnlyOnce THEN
	       
	      (*--------------------------------------------------------------*)
	      (* (a1)                 ctrl := first                           *)
	      (* (a2)                 <statements>                            *)
	      (*--------------------------------------------------------------*)
	      AccessControlVariable (ctrlAddressOp);
	      UseFirst (firstOp);  (* firstOp has mode ForTypeMode *)
	      AdjustMode(ForType,ctrlType,firstOp,firstOp);
	      Assign (ctrlMode,ctrlAddressOp,firstOp);
	      ClassStatementlist (bodyNode);
	     
	    ELSE
	     
	      (*--------------------------------------------------------------*)
	      (* (c1)                 ctrl := first                           *)
	      (*--------------------------------------------------------------*)
	      AccessControlVariable (ctrlAddressOp);
	      UseFirst (firstOp);  (* firstOp has mode ForTypeMode *)
	      AdjustMode(ForType,ctrlType,firstOp,firstOp);
	      Assign (ctrlMode,ctrlAddressOp,firstOp);
	      DeclareLabel (BodyLabel);
	      DeclareLabel (EndLabel);
	      ProvideOverflowTest;
	      (*--------------------------------------------------------------*)
	      (* (c2)         BODY:                                           *)
	      (* (c3)                 <statements>                            *)
	      (* (c4')		      LineNumberDebug (FOR)		      *)
	      (* (c4)                 if ctrl >= [<=] stop then goto END      *)
	      (* (c5)                 INC (ctrl,step)                         *)
	      (* (c6)                 goto BODY                               *)
	      (* (c7)         END:                                            *)
	      (*--------------------------------------------------------------*)
	      GenerateForBodyCode;
	     
	    END; (* IF *)
	   
	  ELSE (* dyn. start value and/or limit *)

	    IF NOT LoopExecutedOnlyOnce THEN
	      IF from.kind # IsConstant THEN
		AdjustMode (from.type,ForType,from.op,from.op);
		DeclareDataTempo (ForTypeMode,firstTempo);
		AssignDataTempo (ForTypeMode,firstTempo,from.op);
	      END; (* IF *)
	      IF to.kind # IsConstant THEN
		AdjustMode (to.type,ForType,to.op,to.op);
		DeclareDataTempo (ForTypeMode,lastTempo);
		AssignDataTempo (ForTypeMode,lastTempo,to.op);
	      END; (* IF *)
	    END; (* IF *)
	    DeclareLabel (EndLabel);
	    (*----------------------------------------------------------------*)
	    (* (d1,e1,f1)           if first > [<] last then goto END         *)
	    (*----------------------------------------------------------------*)
	    UseFirst (firstOp);
	    UseLast  (lastOp);
	    IF upwards THEN
	      FixedCompareAndBranch 
		(ForTypeMode,RelGreater,EndLabel,firstOp,lastOp);
	    ELSE
	      FixedCompareAndBranch 
		(ForTypeMode,RelLess,EndLabel,firstOp,lastOp);
	    END; (* IF *)
	    (*----------------------------------------------------------------*)
	    (* (d2,e2,f2)           ctrl := first                             *)
	    (*----------------------------------------------------------------*)
	    AccessControlVariable (ctrlAddressOp);
	    UseFirst (firstOp);  (* firstOp has mode ForTypeMode *)
	    AdjustMode(ForType,ctrlType,firstOp,firstOp);
	    Assign (ctrlMode,ctrlAddressOp,firstOp);
	    IF LoopExecutedOnlyOnce THEN
	      (*--------------------------------------------------------------*)
	      (* (e3)                 <statements>                            *)
	      (* (e4)         END:                                            *)
	      (*--------------------------------------------------------------*)
	      ClassStatementlist (bodyNode);
	      PlaceLabel (EndLabel);
	    ELSE
	      DeclareLabel (BodyLabel);
	      (*--------------------------------------------------------------*)
	      (* (f3)                 if last < ( MIN(ctrlType) + (step-1) )  *)
	      (*                            [ > ( MAX(ctrlType) + (step+1) ) ]*)
	      (*                      then goto OVFL                          *)
	      (* (f4)                 stop := last - (step -[+] 1)            *)
	      (* (f5)                 goto BODY                               *)
	      (* (f6)         OVFL:                                           *)
	      (* (f7)                 stop := MIN [MAX] (ctrlType)            *)
	      (*--------------------------------------------------------------*)
	      ProvideOverflowTest;
	      (*--------------------------------------------------------------*)
	      (* (d3,f8)      BODY:                                           *)
	      (* (d4,f9)              <statements>                            *)
	      (* (d5',f10')	      LineNumberDebug (FOR)		      *)
	      (* (d5,f10)             if ctrl >= [<=] stop then goto END      *)
	      (* (d6,f11)             INC (ctrl,step)                         *)
	      (* (d7,f12)             goto BODY                               *)
	      (* (d8,f13)     END:                                            *)
	      (*--------------------------------------------------------------*)
	      GenerateForBodyCode;
	    END; (* IF *)
	   
          END; (* IF *) (* dyn. start value and/or limit *)

	END; (* IF *) (* code generation enabled *)
       
      END NodeStatementFor;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementIf;
      VAR 
	conditionNode,  thenpartNode,  elsepartNode  : Node;
	conditionClass, thenpartClass, elsepartClass : NodeKind;
	conditionPos,   thenpartPos,   elsepartPos   : SourcePosition;
	EndLabel,       ThenLabel,     ElseLabel     : Label;
	bl                                           : BooleanLabels;
      BEGIN
	get3 (statement, conditionNode, thenpartNode, elsepartNode);
	get (conditionNode, conditionClass, conditionPos);
	get (thenpartNode,  thenpartClass,  thenpartPos);
	get (elsepartNode,  elsepartClass,  elsepartPos);
	DeclareLabel (EndLabel);
	IF thenpartClass = StatementlistEnd THEN
	  bl.trueLabel := EndLabel;
	ELSE
	  DeclareLabel (ThenLabel);
	  bl.trueLabel := ThenLabel;
	END; (* IF *)
	IF elsepartClass = StatementlistEnd THEN
	  bl.falseLabel := EndLabel;
	ELSE
	  DeclareLabel (ElseLabel);
	  bl.falseLabel := ElseLabel;
	END; (* IF *)
	bl.trueLabelFollows := TRUE;
%( Debug
	LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *) 
%)
	Condition (conditionNode,bl);
	   
	IF thenpartClass # StatementlistEnd THEN
	  PlaceLabel (ThenLabel);
	  ClassStatementlist (thenpartNode);
	END; (* IF *)
	IF elsepartClass # StatementlistEnd THEN
	  Goto (EndLabel);
	  PlaceLabel (ElseLabel);
	  ClassStatementlist (elsepartNode);
	END; (* IF *)
	PlaceLabel (EndLabel);
	   
      END NodeStatementIf;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementLoop;
      VAR 
	body: Node; 
	LabelOfActualLOOP, EndLabelOfSurroundingLOOP : Label;
%( Modula_P
        SurroundingLOOP_is_containded_in_PAR : BOOLEAN;
%)
      BEGIN
%( Modula_P
        SurroundingLOOP_is_containded_in_PAR := Actual_LOOP_is_contained_in_PAR;
        Actual_LOOP_is_contained_in_PAR      := PAR_nesting > 0;
%)
	EndLabelOfSurroundingLOOP := EndLabelOfActualLOOP;
	get1 (statement,body);
	DeclareLabel (LabelOfActualLOOP);
	DeclareLabel (EndLabelOfActualLOOP);
	PlaceLabel (LabelOfActualLOOP);
	INC (LoopNesting);
	ClassStatementlist (body);
	DEC (LoopNesting);
	Goto (LabelOfActualLOOP);
	PlaceLabel (EndLabelOfActualLOOP);
	EndLabelOfActualLOOP := EndLabelOfSurroundingLOOP;
%( Modula_P
        Actual_LOOP_is_contained_in_PAR := SurroundingLOOP_is_containded_in_PAR;
%)
      END NodeStatementLoop;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementRepeat;
      VAR 
	bodyNode, conditionNode : Node; 
	conditionClass          : NodeKind; 
	condition               : Attributes;
	BodyLabel, EndLabel     : Label;
	conditionPos            : SourcePosition;
	bl                      : BooleanLabels;
      BEGIN
	get2 (statement, conditionNode, bodyNode);
	get (conditionNode, conditionClass, conditionPos);
	DeclareLabel (BodyLabel);
	DeclareLabel (EndLabel);
	bl.trueLabel := EndLabel;
	bl.falseLabel := BodyLabel;
	bl.trueLabelFollows := TRUE;
	 
	PlaceLabel (BodyLabel);
	ClassStatementlist (bodyNode);
%( Debug
	LineNumberDebug (conditionPos); (* ++ hh 09/92 ++ *)
%)
	Condition (conditionNode,bl);
	PlaceLabel (EndLabel);
	 
      END NodeStatementRepeat;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementReturnexpr;
      VAR 
	exprNode  : Node; 
	exprClass : NodeKind;
	expr      : Attributes;
	exprPos   : SourcePosition;
	ResultType: Type;
	lwb, upb  : LONGINT;
      BEGIN
%( Modula_P
        (* SC: RETURN [expression] is not allowed inside of a PAR statement *)
        IF   PAR_nesting > 0
        THEN ERROR ("RETURN in a 'PAR' statement context is not allowed",
                    statementPos);
        END;
%)
	(* SC: context must be function procedure. *)
	IF (StmtpartObject^.class = ErrorObj) THEN
	ELSIF (StmtpartObject^.class # ProcedureObj) OR
	      (StmtpartObject^.TypeOfProcedure^.ResultType^.class = ClassVOID) 
	THEN
	  IF StmtpartObject^.class = ModuleObj THEN
	    ERROR 
	      ("RETURN is in module context: RETURN expression not expected",
	      statementPos);
	  ELSE
	    ERROR 
	      ("RETURN is in procedure context: RETURN expression not expected",
	      statementPos);
	  END; (* IF *)
	ELSE 
	  get1 (statement,exprNode);
	  get (exprNode,exprClass,exprPos);
%( Debug
	  LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)
	  RValue (exprNode,expr);
	  ResultType := StmtpartObject^.TypeOfProcedure^.ResultType;
	  (* SC: result expr. must be assign. comp. with the function result.*)
	  IF (expr.type = TypeERROR) OR (ResultType = TypeERROR) THEN
	  ELSIF NOT AssignCompatible (ResultType,expr,DontEmitErrMsg,statementPos) THEN
	    ERROR 
	      ("RETURN expression not assignment compatible with result type",
	      statementPos)
	  ELSIF IsInRange (ResultType,TRUE,TRUE,expr) THEN
	    IF expr.kind = IsConstant THEN
              ConstToOp (expr,ResultType);
	    ELSE
	      IF RangeCheckOption THEN
	        RuntimeRangeCheck 
		  (ResultType,CheckLowerBound,CheckUpperBound,expr);
	      END;
	      AdjustMode (expr.type,ResultType,expr.op,expr.op);
	    END;
(*++ jv 89/01/23 ++*)
       (* the parameter size of the procedure must be given to the ReturnValue 
	    ReturnValue (ModeOf(ResultType),ResultType^.size,expr.op);
       *)
	    ReturnValue (ModeOf(ResultType), 
                         StmtpartObject^.TypeOfProcedure^.ParameterSize,
                         expr.op);
(*-- jv 89/01/23 --*)
	  END;
	  returnCall := TRUE;
	END
      END NodeStatementReturnexpr;
     
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementReturnvoid;
      BEGIN
%( Modula_P
        (* SC: RETURN [expression] is not allowed inside of a PAR statement *)
        IF   PAR_nesting > 0
        THEN ERROR ("RETURN in a 'PAR' statement context is not allowed",
                    statementPos);
        END;
%)
%( Debug
	LineNumberDebug (statementPos); (* ++ hh 09/92 ++ *)
%)
	(* SC: context must be a module or proper procedure. *)
	IF (StmtpartObject^.class # ModuleObj) AND
	   ((StmtpartObject^.class # ProcedureObj) OR 
	   (StmtpartObject^.TypeOfProcedure^.ResultType <> TypeVOID)) 
	THEN
	  ERROR ("RETURN is in function context: RETURN expression expected",
		statementPos);
	ELSIF StmtpartObject^.class = ModuleObj THEN
	  returnCall := TRUE;
	  Return (0);
	ELSE 
	  returnCall := TRUE;
	  Return (StmtpartObject^.TypeOfProcedure^.ParameterSize);
	END; (* IF *)
      END NodeStatementReturnvoid;
     
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementWhile;
      VAR 
	bodyNode, conditionNode   : Node; 
	condition                 : Attributes;
	conditionClass            : NodeKind;
	TestLabel, BodyLabel, EndLabel : Label;
	conditionPos              : SourcePosition;
	bl : BooleanLabels;
      BEGIN
	get2 (statement, conditionNode, bodyNode);
	get (conditionNode, conditionClass, conditionPos);
	DeclareLabel (TestLabel);
	DeclareLabel (BodyLabel);
	DeclareLabel (EndLabel);
	bl.trueLabel := BodyLabel;
	bl.falseLabel := EndLabel;
	bl.trueLabelFollows := FALSE;
	 
	Goto (TestLabel);
	PlaceLabel (BodyLabel);
	ClassStatementlist (bodyNode);
	PlaceLabel (TestLabel);
%( Debug
        LineNumberDebug (conditionPos); (* ++ hh 09/92 ++ *)
%)
	Condition (conditionNode,bl);
	PlaceLabel (EndLabel);

      END NodeStatementWhile;
       
      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementWith;
      VAR 
	bodyNode, withclauseNode : Node; 
	withclause               : Attributes;
	withclauseTempo          : AddressTempo;
	ok                       : BOOLEAN;
      BEGIN
	get2 (statement,withclauseNode,bodyNode);
	LValue (withclauseNode,withclause);
	(* SC: designator expression must be a variable of type record .*)
	ok := TRUE;
	IF withclause.type^.class = ClassERROR THEN
	ELSIF withclause.type^.class # RecordType THEN
	  ERROR ("WITH clause designator is not of record type", statementPos);
	  ok := FALSE;
	ELSE 
	  IF TopWithStack >= MaxWithNesting THEN
	    ERROR ("too many nested WITHs",statementPos);
	  ELSE
	    INC (TopWithStack);
	    DeclareAddressTempo (withclauseTempo);
	    AssignAddressTempo (withclauseTempo,withclause.op);
	    WithStack [TopWithStack] := withclauseTempo;
	  END; (* IF *)
	  EnterWithStatement (withclause.type);
	  ClassStatementlist (bodyNode);
	  LeaveWithStatement;
	  IF ok THEN DEC (TopWithStack) END;
	END; (* IF *)
      END NodeStatementWith;

      (*----------------------------------------------------------------------*)

%( Modula_P
      PROCEDURE NodeReplicator (    rep_Node      : Node;
                                VAR ok            : BOOLEAN;
                                VAR IsReplicated  : BOOLEAN;
                                VAR ctrlVar_Obj   : Object;
                                VAR ctrlVar_Ident : Ident;
                                VAR lwb_Attr      : Attributes;
                                VAR upb_Attr      : Attributes);
      (*****************************************************************)
      (* if an error occured then ok = FALSE, otherwise TRUE.          *)
      (* if an error occured then then all other paramertes are undef. *)
      (* if the rep_Node.Class = ReplicatorEmpty                       *)
      (* then IsReplicated = FALSE, all other parameters are undefined *)
      (* else IsReplicated = TRUE,  the other parameters are defined   *)
      (*****************************************************************)
      VAR rep_Class : NodeKind;
          rep_Pos   : SourcePosition;
          lwb_Node,  upb_Node,  ctrlVar_Node  : Node;
          lwb_Class, upb_Class, ctrlVar_Class : NodeKind;
          lwb_Pos,   upb_Pos,   ctrlVar_Pos   : SourcePosition;
          ctrlVar_Type                        : Type;

	 PROCEDURE IsRepCtrlVarTypeOK (ctrlVar_Obj : Object;
                                       pos         : SourcePosition) :BOOLEAN;
         VAR type : Type;
	 BEGIN
                type := ctrlVar_Obj^.TypeOfVariable;
	        IF   type^.class = SubrangeType 
                THEN type := type^.BaseTypeOfSubrangeType;
	        END; (* IF *)
	        WITH type^ DO
                  IF (class = ClassSHORTCARD) OR
		     (class = ClassLONGCARD) OR
		     (class = ClassSHORTINT) OR
		     (class = ClassLONGINT) OR
		     (class = ClassCHAR) OR
		     (class = ClassBOOLEAN) OR
		     (class = EnumerationType) OR
		     (class = ClassADDRESS)
                   THEN RETURN TRUE
                   ELSE ERROR ("control variable has wrong type", pos);
                        RETURN FALSE
                   END;
	        END; (* WITH *)
	 END IsRepCtrlVarTypeOK;

      BEGIN (* NodeReplicator *)
        (* replicator *)
        get (rep_Node, rep_Class, rep_Pos);
        IF   rep_Class = ReplicatorEmpty
        THEN ok := TRUE; IsReplicated := FALSE; 
        ELSE ok           := TRUE;
             IsReplicated := TRUE;
             get3 (rep_Node, ctrlVar_Node, lwb_Node, upb_Node);
	     (*******************************************************)
	     (* control variable:                                   *)
	     (* =================                                   *)
	     (* SC: ctrlVarId must be a simple type;                *)
	     (*     ctrlVarId must not be imported, or a parameter, *)
	     (*     or a structured variable component.             *)
	     (*******************************************************)
             GetIdent (ctrlVar_Node, ctrlVar_Pos, ctrlVar_Ident);
             applyControlVar (ctrlVar_Ident, ctrlVar_Pos, ctrlVar_Obj);
             IF   (ctrlVar_Obj^.class = ErrorObj) OR
                  (NOT IsRepCtrlVarTypeOK (ctrlVar_Obj, ctrlVar_Pos))
             THEN ok := FALSE; RETURN
             ELSE ctrlVar_Type := ctrlVar_Obj^.TypeOfVariable;
             END;

	     (*******************************************************)
	     (* lower bound:                                        *)
	     (* ============                                        *)
	     (* SC: lwb expression must be compatible with ctrlVar. *)
	     (*******************************************************)
             RValue (lwb_Node, lwb_Attr);
             IF   NOT Compatible (ctrlVar_Type,   lwb_Attr.type,
                  DontEmitErrMsg, lwb_Attr.pos)
             THEN ERROR("lower bound value not compatible with control variable"
                        , lwb_Attr.pos);
                  ok := FALSE; RETURN
             END;
             IF   lwb_Attr.kind = IsConstant
             THEN IF   ConstantIsInRange (ctrlVar_Type, lwb_Attr.type,
                                          lwb_Attr.val, lwb_Attr.pos)
                  THEN ConstToOp (lwb_Attr, TypeLONGINT);
                  ELSE ok := FALSE; RETURN
                  END;
             ELSE IF   RangeCheckOption
                  THEN RuntimeRangeCheck (ctrlVar_Type,CheckLowerBound,
                                         CheckUpperBound, lwb_Attr);
                       AdjustMode (lwb_Attr.type, TypeLONGINT,
                                   lwb_Attr.op,   lwb_Attr.op);
                  END;
             END;
	     (*******************************************************)
	     (* upper bound:                                        *)
	     (* ============                                        *)
	     (* SC: upb expression must be compatible with ctrlVar. *)
	     (*******************************************************)
             RValue (upb_Node, upb_Attr);
             IF   NOT Compatible (ctrlVar_Type,   upb_Attr.type,
                                  DontEmitErrMsg, upb_Attr.pos)
             THEN ERROR("upper bound value not compatible with control variable"
                        , upb_Attr.pos);
                  ok := FALSE; RETURN
             END;
             IF   upb_Attr.kind = IsConstant
             THEN IF   ConstantIsInRange (ctrlVar_Type,  upb_Attr.type,
                                          upb_Attr.val, upb_Attr.pos)
                  THEN ConstToOp (upb_Attr, TypeLONGINT);
                  ELSE ok := FALSE; RETURN
                  END;
             ELSE IF   RangeCheckOption
                  THEN RuntimeRangeCheck (ctrlVar_Type,CheckLowerBound,
                                         CheckUpperBound, upb_Attr);
                       AdjustMode (upb_Attr.type, TypeLONGINT,
                                   upb_Attr.op,   upb_Attr.op);
                  END;
             END;
        END
      END NodeReplicator;
	   
      PROCEDURE AccessRepCtrlVar (    ctrlVar_Obj : Object;
                                  VAR op          : AddressOperand );
      (* returns the AddressOperand for accessing the ctrlVar *)
      VAR ActivationRecordBaseOp : AddressOperand;
      BEGIN (* AccessRepCtrlVar *)
	 IF    ctrlVar_Obj^.DefiningProcedure = StmtpartObject 
         THEN  (* control variable is declared in actual scope *)
	       LocalVariable (ctrlVar_Obj^.offset,op);
	 ELSIF ctrlVar_Obj^.DefiningProcedure = RootObject 
         THEN  (* control variable is static *)
	       StaticVariable (CompUnitObject^.moduleindex, 
                               ctrlVar_Obj^.offset, op);
	 ELSE  (* control variable is neither local nor static *)
	       FrameBase (ctrlVar_Obj^.DefiningProcedure^.procindex,
	                  ctrlVar_Obj^.DefiningProcedure^.level,
	                  ActivationRecordBaseOp);
	       GlobalVariable (ctrlVar_Obj^.offset,
                               ActivationRecordBaseOp,op);
	 END; (* IF *)
      END AccessRepCtrlVar;
     
      PROCEDURE NodeStatementPar;
      CONST MaxProcessBodies  = 512;
      VAR   PAR_Class         : NodeKind;
            PAR_Pos           : SourcePosition;
            ProcessList       : Node;
            ProcessList_Class : NodeKind;
            ProcessList_Pos   : SourcePosition;    
            processbody       : Node;

            rep_Node, stmts_Node : ARRAY [1 .. MaxProcessBodies] OF Node;
            ProcessBodyLabels    : ARRAY [1 .. MaxProcessBodies] OF Label;
 
            ctrlVar_Ident     : ARRAY [1 .. MaxProcessBodies] OF Ident;
            IsReplicated      : ARRAY [1 .. MaxProcessBodies] OF BOOLEAN;

            ProcessBodyCount  : INTEGER;
            NrOfProcessBodies : INTEGER;
            NextInstrLabel    : Label;
 

          PROCEDURE Pass2 (nr : INTEGER);
          VAR RepTempo  : DataTempo;
              StartLab, EndLab                    : Label;
              lwb_Node,  upb_Node,  ctrlVar_Node  : Node;
              lwb_Class, upb_Class, ctrlVar_Class : NodeKind;
              lwb_Attr,  upb_Attr,  ctrlVar_Attr  : Attributes;
              lwb_Pos,   upb_Pos,   ctrlVar_Pos   : SourcePosition;
              ctrlVar_Obj                         : Object;
              ctrlVar_op                          : DataOperand;
              ok                                  : BOOLEAN;
 
          BEGIN (* Pass2 *)
            NodeReplicator (rep_Node [nr], ok, IsReplicated [nr], 
                            ctrlVar_Obj, ctrlVar_Ident [nr],
                            lwb_Attr,    upb_Attr);
            IF   NOT ok THEN RETURN END;
	    (*******************************************************)
	    (* now all SC's are ok                                 *)
	    (*******************************************************)
            IF   IsReplicated [nr]
            THEN DeclareLabel (StartLab); DeclareLabel (EndLab);
                 DeclareReplicatorTempo (RepTempo);
                 InitReplication (RepTempo, EndLab, lwb_Attr.op, upb_Attr.op);
                 PlaceLabel (StartLab); 
	         AccessRepCtrlVar (ctrlVar_Obj, ctrlVar_op);
                 AssignRepControlVar (ModeOf (ctrlVar_Obj^.TypeOfVariable), 
                                      RepTempo, ctrlVar_op);
                 StartProcess (ProcessBodyLabels [nr], 
                               IsReplicated [nr], RepTempo);  
                 DoReplication (RepTempo, StartLab, EndLab);
                 PlaceLabel (EndLab);
            ELSE StartProcess (ProcessBodyLabels [nr], 
                               IsReplicated [nr], UndefTempo);  
            END; (* IF IsReplicated [nr] *)
          END Pass2;

          PROCEDURE Pass3 (nr : INTEGER);
          (* ++ rh ++ *)
          VAR SaveMoreThanOneStmt,
              SaveProcessCallAppeared : BOOLEAN;
              SaveLastProcessPos      : SourcePosition;
          BEGIN (* Pass3 *)
            (* emit code of a process body *)
            PlaceLabel     (ProcessBodyLabels [nr]);
            IF   IsReplicated [nr]
            THEN MakeReplicator  (* ++ rh ++ *) 
                        (ctrlVar_Ident [nr], ParRepCtrlVarTempo, PAR_nesting); 
                 BeginProcess;
                 SaveMoreThanOneStmt     := MoreThanOneStatement;
                 SaveProcessCallAppeared := ProcessCallAppeared;
                 SaveLastProcessPos      := LastProcessPos;
                 MoreThanOneStatement := FALSE;
                 ProcessCallAppeared  := FALSE;             
                 ClassStatementlist (stmts_Node [nr]);

                 (* ++ rh ++ *)  (* 90/05/30 *)
                 IF MoreThanOneStatement AND ProcessCallAppeared THEN
                  ERROR ('PAR components must not contain a process call combined with other statements', LastProcessPos);
                 END;
                 MoreThanOneStatement    := SaveMoreThanOneStmt;
                 ProcessCallAppeared     := SaveProcessCallAppeared;
                 LastProcessPos          := SaveLastProcessPos;
                 (* -- rh -- *)
                 EndProcess;
                 UndoMakeReplicator (ctrlVar_Ident [nr]); 
            ELSE BeginProcess;
                 SaveMoreThanOneStmt     := MoreThanOneStatement;
                 SaveProcessCallAppeared := ProcessCallAppeared;
                 SaveLastProcessPos      := LastProcessPos;
                 MoreThanOneStatement := FALSE;
                 ProcessCallAppeared  := FALSE;
                 ClassStatementlist (stmts_Node [nr]);
                 (* ++ rh ++ *)  (* 90/05/30 *)
                 IF MoreThanOneStatement AND ProcessCallAppeared THEN
                  ERROR ('PAR components must not contain a process call combined with other statements', LastProcessPos);
                 END;
                 MoreThanOneStatement    := SaveMoreThanOneStmt;
                 ProcessCallAppeared     := SaveProcessCallAppeared;
                 LastProcessPos          := SaveLastProcessPos;
                 (* -- rh -- *)
                 EndProcess;
            END;
          END Pass3;

      BEGIN (* NodeStatementPar *)
        (*************************************************)
        (* Semantic checks:                              *)
        (* PAR is not allowed inside of a WITH statement *)
        (*************************************************)
        INC (PAR_nesting);
        ActualPAR_NestingLevel := PAR_nesting;    (* ++ rh ++ *)

        get (statement, PAR_Class, PAR_Pos);
        IF   TopWithStack > 0
        THEN ERROR ("PAR statement is not allowed inside of a WITH statement", 
                     PAR_Pos);
        END;
       
        (********************************************************************)
        (* transformation:                                                  *)
        (* is done with 3 passes over all processes                         *)
        (* 1. check semantic conditions of all process declarations,        *)
        (*    give each process body a unique number and start label.       *)
        (*    and emit this label declarations.                             *)
        (* 2. check replicator, emit code to start processes                *)
        (* 2. emit start code for processes                                 *)
        (* 3. emit code for process bodies                                  *)
        (********************************************************************)
 
         
        (* Pass 1 *) 
        get1 (statement, ProcessList);
        NrOfProcessBodies := 0;
        get  (ProcessList, ProcessList_Class, ProcessList_Pos);
        WHILE ProcessList_Class = ProcesslistElem DO
          INC (NrOfProcessBodies);
          IF   NrOfProcessBodies > MaxProcessBodies
          THEN ERROR ("compiler restriction: too much process bodies.",
                      ProcessList_Pos);
               NrOfProcessBodies := MaxProcessBodies;
          END; 
          get2  (ProcessList, processbody, ProcessList);
          get2  (processbody, rep_Node   [NrOfProcessBodies],
                              stmts_Node [NrOfProcessBodies]);   
          DeclareLabel (ProcessBodyLabels [NrOfProcessBodies]);
          get   (ProcessList, ProcessList_Class, ProcessList_Pos);
        END;

        (* Pass 2 *) 
        DeclareLabel  (NextInstrLabel);
        BeginParallel (NextInstrLabel);
        ProcessBodyCount := 1;
        WHILE ProcessBodyCount <= NrOfProcessBodies DO
          Pass2 (ProcessBodyCount);
          INC   (ProcessBodyCount);
        END;
        EndParallel;

        (* Pass 3 *)
        ProcessBodyCount := 1;
        WHILE ProcessBodyCount <= NrOfProcessBodies DO
          Pass3 (ProcessBodyCount);
          INC   (ProcessBodyCount);
        END;

        PlaceLabel (NextInstrLabel); 

        DEC (PAR_nesting);
        ActualPAR_NestingLevel := PAR_nesting;
      END NodeStatementPar;

      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementAlt;
      CONST MaxAltBodies = 512;
      TYPE  AlternativeKind = (alt_Error, alt_Skip, alt_Delay, alt_Channel);
                              (* if an alternative has kind 'alt_Error' *)
                              (* a semantic error occured.              *)
      VAR   ALT_Class      : NodeKind;
            ALT_Pos        : SourcePosition;

            alternative_body_list : Node;
            ElsePartStmts         : Node;

            alt_List        : Node;
            alt_List_Class  : NodeKind;
            alt_List_Pos    : SourcePosition;
            alt_body        : Node;
 
            NrOfAltBodies   : INTEGER;(* nr of alternative bodies in this ALT *)
            AltBodyCount    : INTEGER;

            rep_Node, expr_Node, 
            inp_Node, stmts_Node : ARRAY [1..MaxAltBodies] OF Node;
            alt_stmts_Label : ARRAY [1..MaxAltBodies] OF Label;
            alt_kind        : ARRAY [1..MaxAltBodies] OF AlternativeKind;
            IsReplicated    : ARRAY [1..MaxAltBodies] OF BOOLEAN;
                              (* TRUE, if the alternative use a REPlicator *)
                              (* otherwise false                           *)

            (* only if IsReplicated [nr] = TRUE,then ctrlVar_Ident is defined *)
            ctrlVar_Ident     : ARRAY [1..MaxAltBodies] OF Ident;
            alt_ctrlVar_Tempo : ARRAY [1..MaxAltBodies] OF DataTempo;

            (* alt_XXX [nr] in one of these arrays is defiend  *)
            (* iff IsReplicated [nr] = FALSE                   *)
            alt_expr_tempo  : ARRAY [1..MaxAltBodies] OF DataTempo;
            alt_time_tempo  : ARRAY [1..MaxAltBodies] OF DataTempo;
            alt_chan_tempo  : ARRAY [1..MaxAltBodies] OF AddressTempo;
            alt_dest_tempo  : ARRAY [1..MaxAltBodies] OF AddressTempo;

            alt_dest_Attr,
            alt_chan_Attr,
	    alt_size_Attr   : ARRAY [1..MaxAltBodies] OF Attributes;
	    alt_chan_of_any : ARRAY [1..MaxAltBodies] OF BOOLEAN;

            NextInstrLabel  : Label;
            AltEndLabel     : Label;
            ElsePartLabel   : Label;
            check_tempo     : DataTempo;
            op              : DataOperand;
            ContainsTimer   : BOOLEAN;

            (* ++ 91/01 - rh ++ *)
            inp_from_channel : ARRAY [1..MaxAltBodies] OF BOOLEAN;
            ContainsChannelInp : BOOLEAN;
                (* TRUE if at least one channel guard is found in the *)
                (* whole alternative statement                        *)
            RemoteSupportWsp   : AddressTempo;
                (* this is used to support channel guard for remote 'channels' *)
            RemoteDisableLabel : Label;
                (* where all remote disabling of channels is to be done *)
                (* NOTE: no calls allowed inside (T)ALT...ALTEND        *)
            GeneralAltChannelLabel           : Label;
            SelectErrorLabel                 : Label;
            RemoteCheck_tempo                : DataTempo;
            RemoteChannelSelect_tempo        : DataTempo;
            RemoteDisc_Continue_tempo        : AddressTempo;
            RemoteAltChannel_tempo           : DataTempo;
            RemoteAltChannelUsed_tempo       : DataTempo;
            RemoteProcessInfo_tempo          : DataTempo;
            remexpr_op                       : DataOperand;
            remchan_op                       : AddressOperand;
            (* -- rh -- *)

        (* ++ 91/01 - rh ++ *)
        PROCEDURE Pass1 (nr : INTEGER);
        VAR node                  : Node;
            node_Class, inp_Class : NodeKind;
            node_Pos,   inp_Pos   : SourcePosition;
          
        BEGIN (* Pass1 *)
          DeclareLabel (alt_stmts_Label [nr]);
          get (inp_Node [nr],  inp_Class,  inp_Pos);
          inp_from_channel [nr] := FALSE;
          IF   inp_Class = AltInputStmt
          THEN get1 (inp_Node [nr], node); 
               get (node, node_Class, node_Pos);
               (* ++ 91/01 - rh ++ *)
               IF node_Class = StatementDelay THEN 
                 ContainsTimer := TRUE;
               ELSIF node_Class = StatementChannelInput THEN
                 ContainsChannelInp := TRUE;
                 inp_from_channel [nr] := TRUE;
               END;
               (* -- rh -- *)
          END; 
        END Pass1;

        PROCEDURE Pass1a (nr : INTEGER);
        VAR chan_Node, dest_Node, size_Node,
            time_Node                : Node;
            lwb_Attr, upb_Attr, 
            expr_Attr, inp_Attr, 
            chan_Attr, dest_Attr, size_Attr,
            time_Attr                : Attributes;
            expr_op, time_op         : DataOperand;
            chan_op                  : AddressOperand;
            expr_Class,  inp_Class, 
            stmts_Class, chan_Class,
            dest_Class,  time_Class  : NodeKind;
            expr_Pos,   inp_Pos,   
            stmts_Pos,  chan_Pos,  
            dest_Pos,    time_Pos    : SourcePosition;
            ok               : BOOLEAN;
            StartLab, EndLab : Label;
            RepTempo         : DataTempo;
            ctrlVar_Obj      : Object;
            ctrlVar_op       : DataOperand;
	    size_Kind	     : NodeKind;
	    size_pos         : SourcePosition;

        BEGIN (* Pass1a *)
          (********************************************************************)
          (* The values of chan, dest, time, expr are evaluated and stored in *)
          (* tempos iff IsReplicated [nr] = FALSE.                            *)
          (* If IsReplicated [nr] = TRUE, these values are evaluated          *)
          (* 'dynamically' in the loop, enableing and disableing the          *)
          (* alternatives                                                     *)
          (********************************************************************)
          (***************************************************************)
          (* SC: the input statement is either empty or a channel input  *)
          (*     or a delay statement. As channel 'TIMER' is not allowed.*)
          (*     if delay statement, lhs is 'TIMER', rhs is of type TIME *)
          (*     the 'expr' is of type BOOLEAN;                          *)
          (***************************************************************)
          (* first do the remote enabling since a change of the WPtr is  *)
          (* not allowed in (T)ALT...ALTEND                              *)
          (***************************************************************)

          NodeReplicator (rep_Node [nr], ok, IsReplicated [nr], 
                          ctrlVar_Obj,   ctrlVar_Ident [nr],
                          lwb_Attr,      upb_Attr);
          IF NOT ok THEN alt_kind [nr] := alt_Error; RETURN; END;
          
          IF   IsReplicated [nr] AND inp_from_channel [nr] 
          THEN DeclareLabel (StartLab); DeclareLabel (EndLab);
               DeclareDataTempo (ModeOf (ctrlVar_Obj^.TypeOfVariable),
                                 alt_ctrlVar_Tempo [nr]);      
               DeclareReplicatorTempo (RepTempo);
               InitReplication (RepTempo, EndLab, lwb_Attr.op, upb_Attr.op);
               PlaceLabel (StartLab);
               AccessRepCtrlVar (ctrlVar_Obj, ctrlVar_op);
               AssignRepControlVar (ModeOf (ctrlVar_Obj^.TypeOfVariable), 
                                    RepTempo, ctrlVar_op);
          ELSE alt_ctrlVar_Tempo [nr] := UndefTempo;
          END; (* IF IsReplicated [nr] *)
 
          (* guard expression *)
          IF NOT IsReplicated [nr] OR inp_from_channel [nr]  THEN
            get (expr_Node [nr], expr_Class, expr_Pos);
            RValue (expr_Node [nr], expr_Attr);
            IF    expr_Attr.kind = IsError
            THEN  alt_kind [nr] := alt_Error; RETURN;
            ELSIF expr_Attr.type^.class # ClassBOOLEAN
            THEN  ERROR ("must have a BOOLEAN result", expr_Pos);
                  alt_kind [nr] := alt_Error; RETURN
            ELSE  IF   expr_Attr.kind = IsConstant
                  THEN ConstToOp (expr_Attr, expr_Attr.type);
                  END;
                  CheckBoolGuard (RemoteCheck_tempo, expr_Attr.op, expr_Attr.op);
                  IF   NOT IsReplicated [nr]
                  THEN DeclareDataTempo (ModeOf (TypeBOOLEAN),alt_expr_tempo[nr]);
                       AssignDataTempo  (ModeOf (TypeBOOLEAN),alt_expr_tempo [nr],
                                         expr_Attr.op);
                       IF inp_from_channel [nr] THEN
                         UseDataTempo     (ModeOf (TypeBOOLEAN),alt_expr_tempo [nr],
                                           expr_Attr.op);
                       END;
                  END;
            END;
            (* expr_Attr.op denotes the value of guard expression *)
          END;

          (* input statement *)
          get (inp_Node [nr],  inp_Class,  inp_Pos);
          IF    inp_Class = AltInputStmt
          THEN  get1 (inp_Node [nr], inp_Node [nr]);
                get  (inp_Node [nr], inp_Class, inp_Pos);
                IF    inp_Class  = StatementChannelInput
                THEN  get3 (inp_Node [nr], chan_Node, dest_Node, size_Node);
	              get  (size_Node, size_Kind, size_pos);
                      IF   IsTimer (chan_Node)
                      THEN ERROR ("'TIMER' input not allowed here.", inp_Pos);
                           alt_kind [nr] := alt_Error; RETURN;
                      ELSE alt_kind [nr] := alt_Channel;
	                   IF IsChannelOfAny (chan_Node) AND 
			      (size_Kind # ExpressionNone)
	                   THEN  alt_chan_of_any [nr] := TRUE;
				 CheckChannelOfAny (
				    chan_Node, dest_Node, size_Node,
				    chan_Attr, dest_Attr, size_Attr, ok);
                           ELSIF size_Kind = ExpressionNone
	                   THEN  alt_chan_of_any [nr] := FALSE;
				 CheckChannelInput (chan_Node, dest_Node, 
				 		    chan_Attr, dest_Attr, ok);
                           ELSE  ERROR (
            "The message size specification is allowed only for CHANNEL OF ANY",
	                                size_pos);
                           END;
                           IF NOT ok THEN alt_kind [nr] := alt_Error;RETURN END;
                           IF   IsReplicated [nr]
                           THEN SkipAddress (dest_Attr.op);
                           ELSE alt_chan_Attr [nr] := chan_Attr;
                                alt_dest_Attr [nr] := dest_Attr;
				IF alt_chan_of_any [nr]
                                THEN alt_size_Attr [nr] := size_Attr;
				END;
                                DeclareAddressTempo(alt_chan_tempo [nr]);
                                AssignAddressTempo (alt_chan_tempo [nr],
                                                    chan_Attr.op);
                                UseAddressTempo    (alt_chan_tempo [nr],
                                                    chan_Attr.op);
                                DeclareAddressTempo(alt_dest_tempo[nr]);
                                AssignAddressTempo (alt_dest_tempo[nr],
                                                    dest_Attr.op);
                           END;
                           RemoteEnableChannel (RemoteAltChannel_tempo, 
                                                RemoteAltChannelUsed_tempo,
                                                RemoteProcessInfo_tempo,
                                                expr_Attr.op, chan_Attr.op);
                      END;
                ELSIF inp_Class = StatementDelay
                THEN  alt_kind [nr] := alt_Delay;
                      ContainsTimer := TRUE;
                      get2 (inp_Node [nr], chan_Node, time_Node);
                      CheckDelayStmt (chan_Node, time_Node, inp_Pos,
                                      time_Attr, ok);
                      IF NOT ok THEN alt_kind [nr] := alt_Error; RETURN END;
                      IF   NOT IsReplicated [nr] 
                      THEN DeclareDataTempo (ModeOf (TypeTIME), 
                                             alt_time_tempo [nr]);
                           AssignDataTempo  (ModeOf (TypeTIME),
                                             alt_time_tempo [nr], time_Attr.op);
(*  ++ 91/01 - rh ++ not network version
                           UseDataTempo     (ModeOf (TypeTIME),
                                             alt_time_tempo [nr], time_Attr.op);
*)
                      END;
(*  ++ 91/01 - rh ++ not network version
                      EnableTimer (expr_Attr.op, time_Attr.op);
*)
                ELSE  ERROR("Must be channel input or delay statement",inp_Pos);
                      alt_kind [nr] := alt_Error;
                      RETURN;
                END;
          ELSIF inp_Class = AltEmptyInputStmt
          THEN  
(*  ++ 91/01 - rh ++ not network version
                EnableSkip (expr_Attr.op);
*)
                alt_kind [nr] := alt_Skip;
          ELSE  ERROR("Must be channel input or delay statement", inp_Pos);
                alt_kind [nr] := alt_Error;
                RETURN;
          END; 

          IF   IsReplicated [nr] AND inp_from_channel [nr]
          THEN DoReplication (RepTempo, StartLab, EndLab);
               PlaceLabel    (EndLab);
          END;
        END Pass1a;
        (* -- rh -- *)
 
        PROCEDURE Pass2 (nr : INTEGER);
        VAR chan_Node, dest_Node, 
            time_Node                : Node;
            lwb_Attr, upb_Attr, 
            expr_Attr, inp_Attr, 
            chan_Attr, dest_Attr,
            time_Attr                : Attributes;
            expr_op, time_op         : DataOperand;
            chan_op                  : AddressOperand;
            expr_Class,  inp_Class, 
            stmts_Class, chan_Class,
            dest_Class,  time_Class  : NodeKind;
            expr_Pos,   inp_Pos,   
            stmts_Pos,  chan_Pos,  
            dest_Pos,    time_Pos    : SourcePosition;
            ok               : BOOLEAN;
            StartLab, EndLab : Label;
            RepTempo         : DataTempo;
            ctrlVar_Obj      : Object;
            ctrlVar_op       : DataOperand;

        BEGIN (* Pass2 *)
          (********************************************************************)
          (* The values of chan, dest, time, expr are evaluated and stored in *)
          (* tempos iff IsReplicated [nr] = FALSE.                            *)
          (* If IsReplicated [nr] = TRUE, these values are evaluated          *)
          (* 'dynamically' in the loop, enableing and disableing the          *)
          (* alternatives                                                     *)
          (********************************************************************)
          (***************************************************************)
          (* SC: the input statement is either empty or a channel input  *)
          (*     or a delay statement. As channel 'TIMER' is not allowed.*)
          (*     if delay statement, lhs is 'TIMER', rhs is of type TIME *)
          (*     the 'expr' is of type BOOLEAN;                          *)
          (***************************************************************)

          IF alt_kind [nr] = alt_Error THEN RETURN; END;
          (* ++ 91/01 - rh ++ *)
          IF inp_from_channel [nr] THEN RETURN; END;
          (* -- rh -- *)
          
          IF   IsReplicated [nr]
          THEN NodeReplicator (rep_Node [nr], ok, IsReplicated [nr],
                               ctrlVar_Obj, ctrlVar_Ident [nr], 
                               lwb_Attr, upb_Attr);
               DeclareLabel (StartLab); DeclareLabel (EndLab);
               DeclareReplicatorTempo (RepTempo);
               InitReplication (RepTempo, EndLab, lwb_Attr.op, upb_Attr.op);
               PlaceLabel (StartLab);
               AccessRepCtrlVar (ctrlVar_Obj, ctrlVar_op);
               AssignRepControlVar (ModeOf (ctrlVar_Obj^.TypeOfVariable), 
                                    RepTempo, ctrlVar_op);
               RValue (expr_Node [nr], expr_Attr);
               IF expr_Attr.kind = IsConstant THEN
                 ConstToOp (expr_Attr, expr_Attr.type);
               END;
               expr_op := expr_Attr.op;
          ELSE 
               RepTempo := UndefTempo;
               UseDataTempo (ModeOf (TypeBOOLEAN), alt_expr_tempo [nr], expr_op);
          END; (* IF IsReplicated [nr] *)

          CheckBoolGuard (check_tempo, expr_op, expr_op);

          (* expr_op denotes the value of guard expression *)

          CASE alt_kind [nr] OF 
             alt_Skip:
                  EnableSkip (expr_op); 
(*  ++ 91/01 - rh ++ not network version
            |
             alt_Channel:
                  AdrOfStorageTempo (RemoteAltChannel_tempo, chan_op);
                  EnableChannel (expr_op, chan_op); 
                  IF IsReplicated [nr] THEN
                     get2 (inp_Node [nr], chan_Node, dest_Node);
                     LValue (chan_Node, chan_Attr);
                     chan_op := chan_Attr.op
                  ELSE
                     UseAddressTempo (alt_chan_tempo [nr], chan_op);
                  END;
                  EnableChannel (expr_op, chan_op, RemoteSupportWsp);
*)
            |
             alt_Delay:
                  IF IsReplicated [nr] THEN
                    get2 (inp_Node [nr], chan_Node, time_Node);
                    RValue (time_Node, time_Attr);
                    time_op := time_Attr.op;
                  ELSE
                    UseDataTempo (ModeOf (TypeTIME), alt_time_tempo [nr], time_op);
                  END;
                  EnableTimer (expr_op, time_op);
            |
             alt_Error:
                  (* nothing *)
          END;

          IF   IsReplicated [nr]
          THEN DoReplication (RepTempo, StartLab, EndLab);
               PlaceLabel    (EndLab);
          END;
        END Pass2; 

        PROCEDURE Pass3 (nr : INTEGER);
        VAR expr_op, time_op     : DataOperand;
            chan_op, dest_op     : AddressOperand;
            chan_Node, dest_Node,
            time_Node            : Node;
            chan_Attr, time_Attr,
            expr_Attr            : Attributes;
            lab_op               : DataOperand;
            ok                   : BOOLEAN;
            ctrlVar_Obj          : Object;
            ctrlVar_op           : DataOperand;
            lwb_Attr, upb_Attr   : Attributes; 
            StartLab, EndLab     : Label;
            RepTempo             : DataTempo;
        BEGIN (* Pass3 *)
          IF alt_kind [nr] = alt_Error THEN RETURN END;
          (* ++ 91/01 - rh ++ *)
          IF inp_from_channel [nr] THEN RETURN; END;
          (* -- rh -- *)

          IF   IsReplicated [nr]
          THEN NodeReplicator (rep_Node [nr], ok, IsReplicated [nr], 
                               ctrlVar_Obj,   ctrlVar_Ident [nr],
                               lwb_Attr,      upb_Attr);
               DeclareLabel (StartLab); DeclareLabel (EndLab);
               DeclareReplicatorTempo (RepTempo);
               InitReplication (RepTempo, EndLab, lwb_Attr.op, upb_Attr.op);
               PlaceLabel (StartLab);
               AccessRepCtrlVar (ctrlVar_Obj, ctrlVar_op);
               AssignRepControlVar (ModeOf (ctrlVar_Obj^.TypeOfVariable), 
                                    RepTempo, ctrlVar_op);
               RValue (expr_Node [nr], expr_Attr);
               IF   expr_Attr.kind = IsConstant
               THEN ConstToOp (expr_Attr, expr_Attr.type);
               END;
               expr_op := expr_Attr.op;
          ELSE RepTempo := UndefTempo;
               UseDataTempo (ModeOf (TypeBOOLEAN), alt_expr_tempo [nr],expr_op);
          END; (* IF IsReplicated [nr] *)

          CASE alt_kind [nr] OF
             alt_Skip 
                : DisableSkip (AltEndLabel,alt_stmts_Label [nr],
                               IsReplicated [nr], 
                               RepTempo, alt_ctrlVar_Tempo [nr], expr_op)
(*  ++ 91/01 - rh ++ not network version
           | alt_Channel
                : 
                  AdrOfStorageTempo (RemoteAltChannel_tempo, chan_op);
                  DisableChannel (AltEndLabel, GeneralAltChannelLabel, 
                                  IsReplicated [nr], RepTempo,
                                  alt_ctrlVar_Tempo [nr], expr_op, chan_op);

                  IF   IsReplicated [nr]
                  THEN get2 (inp_Node [nr], chan_Node, dest_Node);
                       LValue (chan_Node, chan_Attr);
                       chan_op := chan_Attr.op;
                  ELSE UseAddressTempo (alt_chan_tempo [nr], chan_op);
                  END;
                  (* ++ 91/01 - rh ++*)
                  DisableChannel (AltEndLabel, alt_stmts_Label [nr],
                                  IsReplicated [nr], RepTempo, 
                                  alt_ctrlVar_Tempo [nr], expr_op, chan_op,
                                  RemoteSupportWsp)
                  (* -- rh -- *)
*)
           | alt_Delay
                : IF   IsReplicated [nr]
                  THEN get2 (inp_Node [nr], chan_Node, time_Node);
                       RValue (time_Node, time_Attr);
                       time_op := time_Attr.op;
                  ELSE UseDataTempo (ModeOf (TypeTIME),    alt_time_tempo [nr], 
                                     time_op);
                  END;
                  LabelDistConstant (alt_stmts_Label [nr], AltEndLabel, lab_op);
                  DisableTimer (IsReplicated [nr], RepTempo, 
                                alt_ctrlVar_Tempo [nr],lab_op,expr_op, time_op);
           | alt_Error : (* nothing *)
          END; (* CASE *)

          IF   IsReplicated [nr]
          THEN DoReplication (RepTempo, StartLab, EndLab);
               PlaceLabel    (EndLab);
          END;
        END Pass3;

        PROCEDURE Pass4 (nr : INTEGER);
        VAR chan_Node, dest_Node, size_Node : Node;
            chan_Attr, dest_Attr, size_Attr : Attributes;
            ReturnLabel : Label;
	    ok          : BOOLEAN;
        BEGIN (* Pass4 *)
          IF alt_kind [nr] = alt_Error THEN RETURN END;

          IF   IsReplicated [nr] 
          THEN MakeReplicator    (* ++ rh  ++ *)
                  (ctrlVar_Ident [nr], alt_ctrlVar_Tempo [nr], PAR_nesting) 
          END;
          PlaceLabel (alt_stmts_Label [nr]);
          (* ++ 91/01 - rh ++ *)
          BeginAlternative ();
          IF NOT inp_from_channel [nr] THEN
            BoolConstant (FALSE, op);
            AssignDataTempo 
                (ModeOf (TypeBOOLEAN), RemoteChannelSelect_tempo, op);
            DeclareLabel (ReturnLabel); 
            BeginRemoteDisable (RemoteDisableLabel, ReturnLabel, 
                                RemoteDisc_Continue_tempo);
            PlaceLabel (ReturnLabel);
          END;
          (* -- rh -- *)
         
          IF alt_kind [nr] = alt_Channel
          THEN IF   IsReplicated [nr]
               THEN 
		    get3 (inp_Node [nr], chan_Node, dest_Node, size_Node);
	            IF alt_chan_of_any [nr]
		    THEN CheckChannelOfAny (chan_Node, dest_Node, size_Node,
					    chan_Attr, dest_Attr, size_Attr,ok);
                    ELSE LValue (chan_Node, chan_Attr);
		         LValue (dest_Node, dest_Attr);
		    END;
               ELSE chan_Attr := alt_chan_Attr [nr];
                    dest_Attr := alt_dest_Attr [nr];
                    UseAddressTempo (alt_chan_tempo [nr], chan_Attr.op);
                    UseAddressTempo (alt_dest_tempo [nr], dest_Attr.op);
	            IF alt_chan_of_any [nr]
		    THEN size_Attr := alt_size_Attr [nr]
		    END;
               END;

	       IF alt_chan_of_any [nr]
	       THEN ReadFromChannel (chan_Attr.op, dest_Attr.op, size_Attr.op)
	       ELSE ChannelInput (chan_Attr, dest_Attr);
	       END;
          END; 

          ClassStatementlist (stmts_Node [nr]);
          EndAlternative (NextInstrLabel);
          IF IsReplicated [nr] THEN UndoMakeReplicator (ctrlVar_Ident [nr]) END;
        END Pass4;

      (* ++ 91/01 - rh ++ *)
      PROCEDURE Pass6 (nr : INTEGER);
        (***********************************************)
        (* do all remote disabling of enabled channels *)
        (***********************************************)
        VAR
           ctrlVar_op         : DataOperand;
           chan_op, expr_op   : AddressOperand;
           ok                 : BOOLEAN;
           ctrlVar_Obj        : Object;
           lwb_Attr, upb_Attr,
           chan_Attr,
           expr_Attr          : Attributes;
           StartLab, EndLab   : Label; 
           RepTempo           : DataTempo;
           chan_Node, size_Node,
           dest_Node          : Node;
       BEGIN
         CASE alt_kind [nr] OF
            alt_Skip,
            alt_Delay,
            alt_Error  : 
                 (* no channel, so no remote disabling *)
                 RETURN;
            ELSE
                (* go ahead *)
         END; 
  
         IF IsReplicated [nr] THEN
            NodeReplicator (rep_Node [nr], ok, IsReplicated [nr],
                            ctrlVar_Obj, ctrlVar_Ident [nr],
                            lwb_Attr, upb_Attr);  
            DeclareLabel (StartLab); DeclareLabel (EndLab);
            DeclareReplicatorTempo (RepTempo);
            InitReplication (RepTempo, EndLab, lwb_Attr.op, upb_Attr.op);
            PlaceLabel (StartLab);
            AccessRepCtrlVar (ctrlVar_Obj, ctrlVar_op);
            AssignRepControlVar (ModeOf (ctrlVar_Obj^.TypeOfVariable),
                                 RepTempo, ctrlVar_op);
            RValue (expr_Node [nr], expr_Attr);
            IF expr_Attr.kind = IsConstant THEN
              ConstToOp (expr_Attr, expr_Attr.type);
            END;
            expr_op := expr_Attr.op;
         ELSE
            RepTempo := UndefTempo;
            UseDataTempo (ModeOf (TypeBOOLEAN), alt_expr_tempo [nr], expr_op);
         END;
       
         IF IsReplicated [nr] THEN
	    (* only channels possible *)
	    get3 (inp_Node [nr], chan_Node, dest_Node, size_Node);
            LValue (chan_Node, chan_Attr);
            chan_op := chan_Attr.op;
         ELSE
            UseAddressTempo (alt_chan_tempo [nr], chan_op);
         END;
         RemoteDisableChannel (RemoteChannelSelect_tempo,
                               RemoteDisc_Continue_tempo,
                               IsReplicated [nr], RepTempo,
                               alt_ctrlVar_Tempo [nr],
                               alt_stmts_Label [nr],
                               expr_op, chan_op);

         IF IsReplicated [nr] THEN
            DoReplication (RepTempo, StartLab, EndLab);
            PlaceLabel (EndLab);
         END; 
       END Pass6;
      (* -- rh -- *)

      BEGIN (* NodeStatementAlt *)
        (********************************************************************)
        (* transformation is done in several passes:                        *)
        (* 1. declare needed labels. look whether there is a timer input.   *)
        (* 2. check semantic. enable guards.                                *)
        (* 3. disable guards.                                               *)
        (* 4. emit bodies of alternatives.                                  *)
        (* 5. emit else part or system error call                           *)
        (********************************************************************)
 
        get (statement, ALT_Class, ALT_Pos);
        IF   ALT_Class = StatementAltSimple
        THEN get1 (statement, alternative_body_list)
        ELSE get2 (statement, alternative_body_list, ElsePartStmts)
        END; 
        DeclareLabel (AltEndLabel);
        DeclareLabel (ElsePartLabel);
        DeclareLabel (NextInstrLabel);

        DeclareDataTempo (ModeOf (TypeBOOLEAN), check_tempo);
        BoolConstant (FALSE, op);
        AssignDataTempo (ModeOf (TypeBOOLEAN), check_tempo, op);

        NrOfAltBodies := 0;
        AltBodyCount  := 0;
        ContainsTimer := FALSE;
        ContainsChannelInp := FALSE;

        (* Pass 1 *)
        alt_List := alternative_body_list;
        get (alt_List, alt_List_Class, alt_List_Pos);
        WHILE alt_List_Class = AlternativelistElem DO
          INC (AltBodyCount);
          IF   AltBodyCount > MaxAltBodies
          THEN ERROR ("compiler restriction: too much alternative bodies", 
               alt_List_Pos);
               AltBodyCount := MaxAltBodies;
          END;
          get2 (alt_List, alt_body, alt_List);
          get4 (alt_body, rep_Node [AltBodyCount], expr_Node [AltBodyCount], 
                          inp_Node [AltBodyCount], stmts_Node [AltBodyCount]);
          Pass1 (AltBodyCount);
          get (alt_List, alt_List_Class, alt_List_Pos);
        END;       
        NrOfAltBodies := AltBodyCount;

        (* ++ 91/01 - rh ++ *)
        IF ContainsChannelInp THEN
          DeclareDataTempo (ModeOf (TypeBOOLEAN), RemoteCheck_tempo);
          DeclareStorageTempo (ModeOf (TypeBOOLEAN), RemoteAltChannelUsed_tempo);
          BoolConstant (FALSE, op);
          AssignDataTempo (ModeOf (TypeBOOLEAN), RemoteCheck_tempo, op);
          AssignDataTempo (ModeOf (TypeBOOLEAN), RemoteAltChannelUsed_tempo, op);

          DeclareStorageTempo (ModeOf (TypeADDRESS), RemoteAltChannel_tempo);
          LongIntConstant    (NotProcess_p, op);
          AssignDataTempo (ModeOf (TypeADDRESS), RemoteAltChannel_tempo, op);

          DeclareStorageTempo (ModeOf (TypeBOOLEAN), RemoteProcessInfo_tempo);

          DeclareLabel (GeneralAltChannelLabel);
          DeclareLabel (SelectErrorLabel);
          DeclareLabel (RemoteDisableLabel);

          DeclareAddressTempo (RemoteDisc_Continue_tempo);
          DeclareDataTempo (ModeOf (TypeBOOLEAN), RemoteChannelSelect_tempo);
        END;

        alt_List := alternative_body_list;
        AltBodyCount := 1;
        WHILE AltBodyCount <= NrOfAltBodies DO
          Pass1a (AltBodyCount);
          INC (AltBodyCount);
        END;

        BeginAltInput (ContainsTimer);
  
        (* Pass 2 *)
        alt_List := alternative_body_list;
        AltBodyCount := 1;
        IF ContainsChannelInp THEN
          (* use the common temporary channel *)
          UseDataTempo (ModeOf (TypeBOOLEAN), RemoteCheck_tempo, remexpr_op);
          CheckBoolGuard (check_tempo, remexpr_op, remexpr_op);
          AdrOfStorageTempo (RemoteAltChannel_tempo, remchan_op);
          EnableChannel (remexpr_op, remchan_op);
        END;
        WHILE AltBodyCount <= NrOfAltBodies DO  
          Pass2 (AltBodyCount);
          INC (AltBodyCount);
        END;
   
        CheckAlt (check_tempo, ElsePartLabel);
        WaitForReadyGuard (ContainsTimer);

        (* Pass 3 *)
        alt_List := alternative_body_list;
        AltBodyCount := 1;
        IF ContainsChannelInp THEN
           (* use the common channel temporary *)
           UseDataTempo (ModeOf (TypeBOOLEAN), RemoteCheck_tempo, remexpr_op);
           AdrOfStorageTempo (RemoteAltChannel_tempo, remchan_op);
           DisableChannel (AltEndLabel, GeneralAltChannelLabel,
                           FALSE, UndefTempo, UndefTempo,
                           remexpr_op, remchan_op);
        END;
        WHILE AltBodyCount <= NrOfAltBodies DO  
          Pass3 (AltBodyCount);
          INC (AltBodyCount);
        END;

        EndAltInput (ContainsTimer);

        PlaceLabel  (AltEndLabel);

        IF ContainsChannelInp THEN
          (* alternative chosen when a channel input was selected *)
          (* (there is only one low level channel, selection is   *)
          (* done by MOPS)                                        *)
          PlaceLabel (GeneralAltChannelLabel);
          BoolConstant (TRUE, op);
          AssignDataTempo (ModeOf (TypeBOOLEAN), RemoteChannelSelect_tempo, op);
          BeginRemoteDisable (RemoteDisableLabel, SelectErrorLabel,
                              RemoteDisc_Continue_tempo);   
        END;

        (* Pass 4 *)
        alt_List := alternative_body_list;
        AltBodyCount := 1;
        WHILE AltBodyCount <= NrOfAltBodies DO  
          Pass4 (AltBodyCount); 
          INC (AltBodyCount);
        END;

        (* Pass 5 *)
        PlaceLabel (ElsePartLabel);
        IF   ALT_Class = StatementAltSimple
        THEN PreCall  (0);
             SysCall  (SysProcAltError);
             PostCall (0);
        ELSE (* ALT_Class = StatementAltElse *)
             ClassStatementlist (ElsePartStmts);
             Goto (NextInstrLabel);
        END;

        PlaceLabel (RemoteDisableLabel);
        alt_List := alternative_body_list;
        AltBodyCount := 1;
        WHILE AltBodyCount <= NrOfAltBodies DO
           Pass6 (AltBodyCount);
           INC (AltBodyCount);
        END;
        UseAddressTempo (RemoteDisc_Continue_tempo, op);
        EndRemoteDisable (op);

        PlaceLabel (SelectErrorLabel);
        PreCall (0);
        SysCall (SysProcAltError);
        PostCall (0);
        (* -- rh -- *)
   
        PlaceLabel (NextInstrLabel);
      END NodeStatementAlt;

      (*----------------------------------------------------------------------*)

      PROCEDURE IsTimer (node : Node) : BOOLEAN;
      (* if node represents the standard variable 'TIMER' *)
      (* then returns TRUE, otherwise returns FALSE       *)
      VAR kind      : NodeKind;
          IdentNode : Node;
          id        : Ident;
          idRep     : ARRAY [0..255] OF CHAR;
          pos       : SourcePosition;
      BEGIN (* IsTimer *)
        get (node, kind, pos);
        IF   kind = DesignatorIdent
        THEN get1 (node, IdentNode);
             TermIdent (IdentNode, id, idRep, pos);
             RETURN id = IdentTIMER;
        ELSE RETURN FALSE
        END;
      END IsTimer;

      (*----------------------------------------------------------------------*)

      PROCEDURE CheckChannelInput (    Chan_Node, Dest_Node : Node;
                                   VAR Chan_Attr, Dest_Attr : Attributes;
                                   VAR ok : BOOLEAN);
      (* SC: Chan is a variable of type 'CHANNEL OF t', t # ANY         *)
      (* SC: ChanBaseType and dest designator must be assignment        *)
      (*     compatible                                                 *)
      (* the corresponding attributes are returned                      *)
      (* ok = TRUE iff no error occured                                 *)
      VAR Chan_BaseType  : Type;
      BEGIN (* CheckChannelInput *)
        LValue (Chan_Node, Chan_Attr);
        LValue (Dest_Node, Dest_Attr);
        IF   (Chan_Attr.kind = IsError) OR (Dest_Attr.kind = IsError) OR
             (Chan_Attr.type^.class = ClassERROR) OR
             (Dest_Attr.type^.class = ClassERROR)
        THEN  ok := FALSE; RETURN;
        END;

        (* now: both objects are not error objects *)
        CASE Chan_Attr.type^.class OF
	   ChannelType : (* nothing ok *)
         | ChannelOfAnyType :
                 ERROR ("missing message size specification for CHANNEL OF ANY",
			Chan_Attr.pos);  
             ok := FALSE; RETURN;
        ELSE ERROR ("lhs must be a channel", Chan_Attr.pos);  
             ok := FALSE; RETURN;
        END;
        (* now: lhs is of type channel *)
        Chan_BaseType := Chan_Attr.type^.BaseTypeOfChannelType;
        IF   NOT AssignCompatible (Chan_BaseType, Dest_Attr,FALSE, statementPos)
        THEN ERROR("destination and channel base type are not asign compatible",
                    statementPos);
             ok := FALSE; RETURN
        END;
        ok := TRUE;
      END CheckChannelInput;

      (*----------------------------------------------------------------------*)

      PROCEDURE IsChannelOfAny (node : Node) : BOOLEAN;
      (* if node represents the a CHANNEL OF ANY          *)
      (* then returns TRUE, otherwise returns FALSE       *)
      VAR attr : Attributes;
      BEGIN 
        LValue (node, attr);
        RETURN attr.type^.class = ChannelOfAnyType
      END IsChannelOfAny;

      (*----------------------------------------------------------------------*)

      PROCEDURE CheckChannelOfAny (
		    Chan_Node, Dest_Node, Size_Node : Node;
                VAR Chan_Attr, Dest_Attr, Size_Attr : Attributes;
                VAR ok : BOOLEAN);
      (* Both, input and output may be checked.                         *)
      (* SC: Chan is a variable of type 'CHANNEL OF ANY'.               *)
      (* SC: Dest_Node must be an expression of type ADDRESS.           *)
      (*     Size_Node must be an expression assign compatible to       *) 
      (*     CARDINAL.                                                  *) 
      (* the corresponding attributes are returned                      *)
      (* ok = TRUE iff no error occured                                 *)
      BEGIN (* CheckChannelOfAny *)
        LValue (Chan_Node, Chan_Attr);
        RValue (Dest_Node, Dest_Attr);
        RValue (Size_Node, Size_Attr);
        IF   (Chan_Attr.kind = IsError) OR (Dest_Attr.kind = IsError) OR
             (Size_Attr.kind = IsError) OR
             (Chan_Attr.type^.class = ClassERROR) OR
             (Dest_Attr.type^.class = ClassERROR) OR
             (Size_Attr.type^.class = ClassERROR)
        THEN  ok := FALSE; RETURN;
        END;

        (* now: both objects are not error objects *)
        IF   Chan_Attr.type^.class # ChannelOfAnyType
        THEN ERROR ("lhs must be of type CHANNEL OF ANY", Chan_Attr.pos);  
             ok := FALSE; RETURN;
        END;
        (* now: lhs is of type channel *)

        IF Dest_Attr.type^.class # ClassADDRESS
        THEN  ERROR ("destination / source must be of type ADDRESS", 
		      Dest_Attr.pos); 
	      ok := FALSE;
	      RETURN;
        END;
        
	IF   NOT AssignCompatible (TypeLONGCARD, Size_Attr, FALSE, statementPos)
        THEN ERROR(
		"message size expression must be assign compatible to CARDINAL",
                Size_Attr.pos);
             ok := FALSE;
             RETURN
        END;

	IF   Dest_Attr.kind = IsConstant 
        THEN ConstToOp (Dest_Attr, TypeADDRESS);
	ELSE AdjustMode (Dest_Attr.type,TypeADDRESS,Dest_Attr.op,Dest_Attr.op);
	END;

	IF   Size_Attr.kind = IsConstant 
        THEN ConstToOp (Size_Attr, TypeLONGCARD);
	ELSE AdjustMode (Size_Attr.type,TypeLONGCARD,Size_Attr.op,Size_Attr.op);
	END;

        ok := TRUE;
      END CheckChannelOfAny;

      (*----------------------------------------------------------------------*)

      PROCEDURE CheckDelayStmt (    chan_Node, time_Node : Node;
                                    pos       : SourcePosition;
                                VAR time_Attr : Attributes;
                                VAR ok        : BOOLEAN);
          
      BEGIN (* CheckDelayStmt *)
        IF   IsTimer (chan_Node)
        THEN RValue (time_Node, time_Attr);
             IF    time_Attr.kind = IsError
             THEN  ok := FALSE
             ELSIF time_Attr.type^.class # ClassTIME
             THEN  ERROR ("must be of type 'TIME'", time_Attr.pos); ok := FALSE
             ELSE  ok := TRUE
             END
        ELSE ERROR ("lhs of a delay statement must be 'TIMER'", pos);ok := FALSE
        END;
      END CheckDelayStmt;

      (*----------------------------------------------------------------------*)

      PROCEDURE CheckChannelOutput (    Chan_Node, Src_Node : Node;
                                    VAR Chan_Attr, Src_Attr : Attributes;
                                    VAR ok : BOOLEAN);
      (* SC: Chan is a variable of type 'CHANNEL OF t', t # ANY         *)
      (* SC: ChanBaseType and dest designator must be assignment        *)
      (*     compatible                                                 *)
      (* the corresponding attributes are returned                      *)
      (* ok = TRUE iff no error occured                                 *)
      VAR Chan_BaseType  : Type;
      BEGIN (* CheckChannelInput *)
        LValue (Chan_Node, Chan_Attr);
        RValue (Src_Node, Src_Attr);
        IF   (Chan_Attr.kind = IsError) OR (Src_Attr.kind = IsError) OR
             (Chan_Attr.type^.class = ClassERROR) OR
             (Src_Attr.type^.class  = ClassERROR)
        THEN ok := FALSE; RETURN;
        END;

        (* now: both objects are not error objects *)
        CASE Chan_Attr.type^.class OF
	   ChannelType : (* nothing ok *)
         | ChannelOfAnyType :
                 ERROR ("missing message size specification for CHANNEL OF ANY",
			Chan_Attr.pos);  
             ok := FALSE; RETURN;
        ELSE ERROR ("lhs must be a channel", Chan_Attr.pos);  
             ok := FALSE; RETURN;
        END;

        (* now: lhs is of type channel *)
        Chan_BaseType := Chan_Attr.type^.BaseTypeOfChannelType;
        IF   NOT AssignCompatible (Chan_BaseType,Src_Attr, FALSE, statementPos)
        THEN ERROR("source expression and channel base type are not compatible",
                    statementPos);
             ok := FALSE; RETURN
        END;

        (* now: Chan_BaseType and Src are assignment compatible *)
        IF   NOT IsInRange (Chan_BaseType, TRUE, TRUE, Src_Attr)
        THEN ok := FALSE; RETURN
        END; 
       
	ok := TRUE;
      END CheckChannelOutput;

      (*----------------------------------------------------------------------*)

      PROCEDURE ChannelInput (VAR Chan_Attr, Dest_Attr : Attributes);
      (*************************************************************)
      (* emits the MOBIL instructions for channel input            *)
      (* all semantic checks must be done before                   *)
      (* Chan_Attr.op and Dest_Attr.op contains the address of the *)
      (* channel and destination.                                  *)
      (* ONLY for CHANNEL OF t, t # ANY                            *)
      (*************************************************************)
      VAR Chan_BaseType  : Type;
          Dest_BaseType  : Type;
	  Size_Value     : Value;
	  Size_op        : DataOperand;
          tempo          : DataTempo;
          tempo_op       : DataOperand;
          tempo_adr_op   : AddressOperand;
      BEGIN
        IF   Dest_Attr.type^.class = SubrangeType
        THEN Dest_BaseType := Dest_Attr.type^.BaseTypeOfSubrangeType
        ELSE Dest_BaseType := Dest_Attr.type
        END; 
        Chan_BaseType := Chan_Attr.type^.BaseTypeOfChannelType;

        ConvertLongCardToValue (Chan_BaseType^.size, Size_Value);
        ValueToOp (Size_Value, TypeLONGCARD, TypeLONGCARD, Size_op, 
		   UndefSourcePos);

        CASE Dest_BaseType^.class OF
	    ClassSHORTCARD, ClassLONGCARD,
	    ClassSHORTINT, ClassLONGINT, 
	    ClassSIorSCorLIorLC, ClassSCorLIorLC, EnumerationType, ClassSIorLI,
	    ClassREAL, ClassSRorLR, ClassLONGREAL,
	    ClassBOOLEAN, ClassCHAR,
	    ClassADDRESS, ClassNIL, ClassOPAQUE, PointerType,
	    ClassBITSET, SetType, ClassWORD, ProcedureType, ClassPROC,
            ClassTIME
	     : IF   Chan_BaseType^.size = Dest_Attr.type^.size
               THEN ReadFromChannel (Chan_Attr.op, Dest_Attr.op, Size_op)
               ELSE DeclareStorageTempo (ModeOf (Chan_BaseType), tempo);
                    AdrOfStorageTempo   (tempo, tempo_adr_op);
                    ReadFromChannel (Chan_Attr.op,tempo_adr_op, Size_op);
                    UseDataTempo (ModeOf (Chan_BaseType), tempo, tempo_op);
                    AdjustMode (Chan_BaseType, Dest_Attr.type, 
                                tempo_op, tempo_op);
                    Assign (ModeOf (Dest_Attr.type), Dest_Attr.op, tempo_op); 
               END;
	  | ArrayType, RecordType, ChannelType, ChannelOfAnyType
             :ReadFromChannel (Chan_Attr.op, Dest_Attr.op, Size_op);
	  | ClassERROR:
	  ELSE (* CASE *)
	    CompilerError ("TrStmts.ChannelInput");
         END
      END ChannelInput;

      (*----------------------------------------------------------------------*)

      PROCEDURE ChannelOutput (VAR Chan_Attr, Src_Attr : Attributes);
      (*************************************************************)
      (* emits the MOBIL instructions for channel output           *)
      (* all semantic checks must be done before                   *)
      (* ONLY for CHANNEL OF t, t # ANY                            *)
      (*************************************************************)
      VAR Chan_BaseType  : Type;
          Src_BaseType   : Type;
	  Size_Value     : Value;
	  Size_op        : DataOperand;
          tempo          : DataTempo;
          tempo_op       : DataOperand;
          tempo_adr_op   : AddressOperand;
      BEGIN
        Chan_BaseType := Chan_Attr.type^.BaseTypeOfChannelType;

        IF   Chan_BaseType^.class = SubrangeType
        THEN Chan_BaseType := Chan_BaseType^.BaseTypeOfSubrangeType
        END; 
        CASE Chan_BaseType^.class OF
	    ClassSHORTCARD, ClassLONGCARD,
	    ClassSHORTINT, ClassLONGINT, 
	    ClassSIorSCorLIorLC, ClassSCorLIorLC, EnumerationType, ClassSIorLI,
	    ClassREAL, ClassSRorLR, ClassLONGREAL,
	    ClassBOOLEAN, ClassCHAR,
	    ClassADDRESS, ClassNIL, ClassOPAQUE, PointerType,
	    ClassBITSET, SetType, ClassWORD, ProcedureType, ClassPROC,
            ClassTIME
	     : IF   Src_Attr.kind = IsConstant 
               THEN ConstToOp (Src_Attr, Chan_BaseType);
	       ELSE IF   RangeCheckOption 
                    THEN RuntimeRangeCheck (Chan_BaseType,
                                            CheckLowerBound,CheckUpperBound,
                                            Src_Attr);
		    END;
		    AdjustMode (Src_Attr.type,Chan_BaseType,
                                Src_Attr.op,Src_Attr.op);
	       END;
               WriteToChannel (ModeOf(Chan_BaseType),Chan_Attr.op,Src_Attr.op);
	  | ArrayType:
	      IF Src_Attr.type^.class = ClassCHAR THEN
		ConvertCharToString (Src_Attr);
		ConstToOp (Src_Attr,Src_Attr.type);
                (* allways: SIZE (Chan_BaseType) bytes are send *)
                
		ConvertLongCardToValue (GetStaticArrayFieldCount(Chan_BaseType),
		                        Size_Value);
		ValueToOp (Size_Value, TypeLONGCARD, TypeLONGCARD, Size_op, 
		           UndefSourcePos);

		WriteToChannelLong (Chan_Attr.op, Src_Attr.op, Size_op);
	      ELSIF Src_Attr.type^.class = ClassSTRING THEN
		ConstToOp (Src_Attr,Src_Attr.type);
                ConvertLongCardToValue (GetStaticArrayFieldCount(Chan_BaseType),
                                        Size_Value);
                ValueToOp (Size_Value, TypeLONGCARD, TypeLONGCARD, Size_op,
                           UndefSourcePos);
		WriteToChannelLong (Chan_Attr.op, Src_Attr.op, Size_op);
	      ELSE ConvertLongCardToValue (Chan_BaseType^.size, Size_Value);
                   ValueToOp (Size_Value, TypeLONGCARD, TypeLONGCARD, Size_op, 
		              UndefSourcePos);
		   WriteToChannelLong (Chan_Attr.op, Src_Attr.op, Size_op);

	      END; (* IF *)
	  | RecordType, ChannelType, ChannelOfAnyType :
	      ConvertLongCardToValue (Chan_BaseType^.size, Size_Value);
              ValueToOp (Size_Value, TypeLONGCARD, TypeLONGCARD, Size_op, 
		         UndefSourcePos);
              WriteToChannelLong (Chan_Attr.op, Src_Attr.op, Size_op);
	  | ClassERROR:
	  ELSE (* CASE *)
	    CompilerError ("TrStmts.ChannelOutput");
        END; (* CASE *)
      END ChannelOutput;

      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementTimerInput (Dest_Node : Node);
      VAR Dest_Attr : Attributes; 
      BEGIN (* NodeStatementTimerInput *)
        (* SC: destination must be of type TIME *)
        LValue (Dest_Node, Dest_Attr);
        IF   Dest_Attr.kind # IsError
        THEN IF   Dest_Attr.type^.class = ClassTIME
             THEN ReadTimer (Dest_Attr.op);
             ELSE IF   Dest_Attr.type^.class # ClassERROR
                  THEN ERROR ("variable must be of type TIME", Dest_Attr.pos);  
                  END;
             END;
        END;
      END NodeStatementTimerInput;

      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementDelay;
      VAR timer_Node : Node;  
          Expr_Node  : Node; 
          Expr_Attr  : Attributes; 
          kind       : NodeKind;
          pos        : SourcePosition;
          ok         : BOOLEAN;

      BEGIN (* NodeStatementDelay *)
        (* SC: timer      must be the standard variable 'TIMER' *)
        (* SC: expression must be of type TIME                  *)
        get2   (statement, timer_Node, Expr_Node);
        get (statement, kind, pos);
        CheckDelayStmt (timer_Node, Expr_Node, pos, Expr_Attr, ok);
        IF   ok
        THEN Delay (Expr_Attr.op);
        END
      END NodeStatementDelay;

      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementChannelInput;
      VAR   Dest_Node, Chan_Node, Size_Node : Node; 
            Dest_Attr, Chan_Attr, Size_Attr : Attributes; 
            ok                              : BOOLEAN;
            Size_Kind : NodeKind;
            Size_Pos  : SourcePosition;

      BEGIN (* NodeStatementChannelInput *)
        (* Three cases:                                                  *)
        (* 1. Chan is the standard variable 'TIMER'                      *)
        (*    SC: dest must be a variable of type 'TIME'                 *)
        (*    SC: size must be an 'ExpressionNone" node                  *)
        (* 2. Chan is a variable of type 'CHANNEL OF t', t # ANY         *)
        (*    SC: Chan and dest designator must be assignment compatible *)
        (*    SC: size must be an 'ExpressionNone" node                  *)
        (*    NOTICE: The channel is treated like a 'right hand side' of *)
        (*            an assignment. The destination is the corresponding*)
        (*            'left hand side'.                                  *)
        (* 3. Chan is a variable of type 'CHANNEL OF ANY'                *)
        (*    SC: dest must be an expression of type ADDRESS             *)
        (*    SC: size must be an expression assign compatible to        *)
        (*        CARDINAL.                                              *)

        get3 (statement, Chan_Node, Dest_Node, Size_Node);
	get  (Size_Node, Size_Kind, Size_Pos);
        
        IF    IsTimer (Chan_Node) AND (Size_Kind = ExpressionNone)
        THEN  (* case 1 *)
	      NodeStatementTimerInput (Dest_Node);
	ELSIF IsChannelOfAny (Chan_Node) AND (Size_Kind # ExpressionNone)
	THEN  (* case 3 *)
	      CheckChannelOfAny (Chan_Node, Dest_Node, Size_Node,
				 Chan_Attr, Dest_Attr, Size_Attr, ok);
	      IF ok
	      THEN ReadFromChannel (Chan_Attr.op, Dest_Attr.op, Size_Attr.op)
	      END
        ELSIF Size_Kind = ExpressionNone
	THEN  (* case 2 *)
	      CheckChannelInput (Chan_Node, Dest_Node, Chan_Attr, Dest_Attr,ok);
              IF    ok 
              THEN (* now: Chan_BaseType and Dest are assignment compatible *)
                   ChannelInput (Chan_Attr, Dest_Attr);
              END
        ELSE  ERROR (
            "The message size specification is allowed only for CHANNEL OF ANY",
	             Size_Pos);
        END;
      END NodeStatementChannelInput;

      (*----------------------------------------------------------------------*)

      PROCEDURE NodeStatementChannelOutput;
      VAR   Src_Node, Chan_Node, Size_Node : Node; 
            Src_Attr, Chan_Attr, Size_Attr : Attributes; 
            Size_Kind : NodeKind;
            Size_Pos  : SourcePosition;
	    ok        : BOOLEAN;

      BEGIN (* NodeStatementChannelOutput *)
        (* Two cases:                                                    *)
        (* 1. Chan is a variable of type 'CHANNEL OF t', t # ANY         *)
        (*    SC: Chan and dest designator must be assignment compatible *)
        (*    SC: size must be an 'ExpressionNone" node                  *)
        (*    NOTICE: The channel is treated like a 'right hand side' of *)
        (*            an assignment. The destination is the corresponding*)
        (*            'left hand side'.                                  *)
        (* 2. Chan is a variable of type 'CHANNEL OF ANY'                *)
        (*    SC: Src must be an expression of type ADDRESS             *)
        (*    SC: Size must be an expression assign compatible to        *)
        (*        CARDINAL.                                              *)

        get3 (statement, Chan_Node, Src_Node, Size_Node);
	get  (Size_Node, Size_Kind, Size_Pos);
        
	IF    IsChannelOfAny (Chan_Node) AND (Size_Kind # ExpressionNone)
	THEN  (* case 2 *)
	      CheckChannelOfAny (Chan_Node, Src_Node, Size_Node,
				 Chan_Attr, Src_Attr, Size_Attr, ok);
	      IF ok
	      THEN WriteToChannelLong (Chan_Attr.op,Src_Attr.op, Size_Attr.op);
	      END
        ELSIF Size_Kind = ExpressionNone
	THEN  (* case 1 *)
	      CheckChannelOutput(Chan_Node, Src_Node, Chan_Attr, Src_Attr,ok);
              IF    ok 
              THEN ChannelOutput (Chan_Attr, Src_Attr);
              END;
        ELSE  ERROR (
      "The message size specification is allowed only for CHANNEL OF ANY",
	             Size_Pos);
        END;
      END NodeStatementChannelOutput;

      (*----------------------------------------------------------------------*)

%)
    BEGIN (* ClassStatement *)
%( ~ Modula_P   (* ++ 91/01 - rh ++ *)       
      get (statement, statementClass, statementPos);
      Mark (statementPos.line, statementPos.col);
      CASE statementClass OF
	StatementAssign       : NodeStatementAssign
      | StatementCall         : NodeStatementCall
      | StatementCaseElse,
        StatementCaseSimple   : NodeStatementCase
      | StatementExit         : NodeStatementExit
      | StatementFor          : NodeStatementFor
      | StatementIf           : NodeStatementIf
      | StatementLoop         : NodeStatementLoop
      | StatementRepeat       : NodeStatementRepeat
      | StatementReturnexpr   : NodeStatementReturnexpr
      | StatementReturnvoid   : NodeStatementReturnvoid
      | StatementWhile        : NodeStatementWhile
      | StatementWith         : NodeStatementWith
      ELSE (* CASE *)
	CompilerError ("assertion violation");
      END; (* CASE *)
%)  (* -- rh -- *)

%( Modula_P   (* ++ 91/01 - rh ++ *)       
      get (statement, statementClass, statementPos);
      Mark (statementPos.line, statementPos.col);
      CASE statementClass OF
	StatementAssign       : NodeStatementAssign;
                                MoreThanOneStatement := TRUE;
      | StatementCall         : NodeStatementCall;
      | StatementCaseElse,
        StatementCaseSimple   : NodeStatementCase;
                                MoreThanOneStatement := TRUE;
      | StatementExit         : NodeStatementExit;
                                MoreThanOneStatement := TRUE;
      | StatementFor          : NodeStatementFor;
                                MoreThanOneStatement := TRUE;
      | StatementIf           : NodeStatementIf;
                                MoreThanOneStatement := TRUE;
      | StatementLoop         : NodeStatementLoop;
                                MoreThanOneStatement := TRUE;
      | StatementRepeat       : NodeStatementRepeat;
                                MoreThanOneStatement := TRUE;
      | StatementReturnexpr   : NodeStatementReturnexpr;
                                MoreThanOneStatement := TRUE;
      | StatementReturnvoid   : NodeStatementReturnvoid;
                                MoreThanOneStatement := TRUE;
      | StatementWhile        : NodeStatementWhile;
                                MoreThanOneStatement := TRUE;
      | StatementWith         : NodeStatementWith;
                                MoreThanOneStatement := TRUE;
      | StatementPar          : NodeStatementPar;
      | StatementAltSimple
       ,StatementAltElse      : NodeStatementAlt;
                                MoreThanOneStatement := TRUE;
      | StatementDelay        : NodeStatementDelay;
                                MoreThanOneStatement := TRUE;
      | StatementChannelInput : NodeStatementChannelInput;
                                MoreThanOneStatement := TRUE;
      | StatementChannelOutput: NodeStatementChannelOutput;
                                MoreThanOneStatement := TRUE;
      ELSE (* CASE *)
	CompilerError ("assertion violation");
      END; (* CASE *)
%)  (* -- rh -- *)
    END ClassStatement;

    (*------------------------------------------------------------------------*)

  BEGIN (* ClassStatementlist *)
%( Modula_P
    (* ++ rh ++ *)  (* 90/05/30 *)
    MoreThanOneStatement := FALSE;
    ProcessCallAppeared  := FALSE;
    (* -- rh -- *)
%)
    statements := node;
    get (statements,statementsClass,statementsPos);
    WHILE statementsClass = StatementlistElem DO 
      get2 (statements,statement,statements);
      ClassStatement;
      get (statements,statementsClass,statementsPos);
%( Modula_P
      (* ++ rh ++ *)  (* 90/05/30 *)
      IF NOT MoreThanOneStatement THEN
        MoreThanOneStatement := statementsClass = StatementlistElem;
      END;
      (* -- rh -- *)
%)
    END; (* WHILE *)
    IF statementsClass <> StatementlistEnd THEN
      CompilerError ("assertion violation");
    END; (* IF *)
  END ClassStatementlist;

  (*--------------------------------------------------------------------------*)
     
  PROCEDURE CValue ( node : Node; VAR attr : Attributes ); 
  (* Returns the description ('attr') of the constant expression specified by *)
  (* 'node'. If the expression is not constant, 'attr = InitAttr' is returned.*)
  VAR pos : SourcePosition; demand : BOOLEAN;
  BEGIN
    attr := InitAttr;
    demand := DemandConstFold;
    DemandConstFold := TRUE;
    ClassExpression (node,attr);
    DemandConstFold := demand;
    IF attr.kind = IsError THEN
    ELSIF attr.kind <> IsConstant THEN
      ERROR ("constant expression expected",attr.pos);
      pos := attr.pos; attr := InitAttr; attr.pos := pos;
    END; (* IF *)
  END CValue;

  (*--------------------------------------------------------------------------*)

  PROCEDURE LValue ( node : Node; VAR attr : Attributes );
  (* The description of the access path to the object specified by 'node' is  *)
  (* returned. If 'node' doesn't specify an addressable object, 'InitAttr' is *)
  (* returned.                                                                *)
  VAR pos : SourcePosition;
  BEGIN
    attr := InitAttr;
    ClassDesignator (node,attr);
    IF attr.kind = IsError THEN
    ELSIF NOT IsAddressable (attr) THEN
      ERROR ("variable expected",attr.pos);
      pos := attr.pos; attr := InitAttr; attr.pos := pos;
    END; (* IF *)
  END LValue;

  (*--------------------------------------------------------------------------*)

  PROCEDURE RValue ( node : Node; VAR attr : Attributes );
  (* The description of the expression specified by 'node' is returned. If    *)
  (* 'node' doesn't specify an expression, 'InitAttr' is returned.            *)
  VAR pos : SourcePosition;
  BEGIN
    attr := InitAttr;
    ClassExpression (node,attr);
    IF NOT (IsExpression(attr) OR (attr.kind = IsStandardProcedureObj)) THEN
      pos := attr.pos; attr := InitAttr; attr.pos := pos;
    END; (* IF *)
  END RValue;
     
  (*--------------------------------------------------------------------------*)

  PROCEDURE CopyParams;
  (* Emits code for copying value open array parameters inside procedure body.*)
  (* The address of the corresponding descriptor is on the stack.             *)
  VAR fp : FormalParam;
  BEGIN
    fp := StmtpartObject^.TypeOfProcedure^.FirstParam;
    WHILE fp # NIL DO
      IF NOT fp^.IsVarParam 
      AND (fp^.type^.class = ArrayType) AND fp^.type^.IsOpenArray 
      THEN
(* ++ 90/11 - rh *)
%( ~ Modula_P
	CopyOpenArray 
	  (fp^.offset,HighFieldOffset(fp^.offset),
	  fp^.type^.ComponentType^.size);
%)
%( Modula_P
        CopyOpenArray
          (fp^.offset,HighFieldOffset(fp^.offset),
          fp^.type^.ComponentType^.size, FALSE);
%)
(* -- rh -- *)
      END; (* IF *)
      fp := fp^.next;
    END; (* WHILE *)
  END CopyParams;
   
  (*--------------------------------------------------------------------------*)
%( Modula_P
(* ++ rh ++ *)  (* 90/05/28 *)   
  PROCEDURE CopyParamsProcessModule;
  (* Emits code for copying value open array parameters inside process body.  *)
  (* The address of the corresponding descriptor is on the stack.             *)
  VAR fp : FormalParam;
  BEGIN
    fp := StmtpartObject^.ProcessFormalParam^.FirstParam;
    WHILE fp # NIL DO
      IF NOT fp^.IsVarParam 
      AND (fp^.type^.class = ArrayType) AND fp^.type^.IsOpenArray 
      THEN
	CopyOpenArray 
	  (fp^.offset,HighFieldOffset(fp^.offset),
	  fp^.type^.ComponentType^.size, TRUE);
      END; (* IF *)
      fp := fp^.next;
    END; (* WHILE *)
  END CopyParamsProcessModule;
(* -- rh -- *)
%)
   
  (*--------------------------------------------------------------------------*)

  PROCEDURE CallSequence (obj : Object);
  (* Initialization calls for module bodies *)
  VAR ProcCallOp : DataOperand;
  BEGIN
    IF obj # NIL THEN
      CallSequence (obj^.next);
      IF obj^.class = ModuleObj THEN
	ProcedureConstant (obj^.procindex,ProcCallOp);
	PreCall (0);
	Call (ProcCallOp);
	PostCall (0);
      END;
    END;
  END CallSequence;

  (*--------------------------------------------------------------------------*)

BEGIN (* TranslateStatementpart *)

  RangeCheckOption := SuBase.SubrangeCheckOption IN SuBase.CurOptions;
  IndexCheckOption := SuBase.IndexCheckOption    IN SuBase.CurOptions;
  get (body, bodyClass, bodyPos);
   
  IF bodyClass = Statementpart THEN
    returnCall      := FALSE;
    LoopNesting     := 0;
    TopWithStack    := 0;

%( Modula_P
    PAR_nesting := 0;
    ActualPAR_NestingLevel := 0;
%)

%( Debug
    ProcedureDebug (StmtpartObject);
%)
    IF StmtpartObject^.class = ProcedureObj THEN
      ActualProcedureLevel := StmtpartObject^.level;
      BeginProcedure (
	StmtpartObject^.procindex,
	StmtpartObject^.level,
	StmtpartObject^.SizeOfActivationRecord,
	StmtpartObject^.TypeOfProcedure^.ParameterSize);
      CopyParams;

%( Modula_P
(* ++ rh ++ *)  (* 90/05/28 *)
    ELSIF (StmtpartObject^.class = ModuleObj) AND 
          (StmtpartObject^.IsProcessModule) THEN
        ActualProcedureLevel := StmtpartObject^.level;
        BeginProcedure (
          StmtpartObject^.procindex,
          StmtpartObject^.level,
          ReservedProcFrameSize,
          StmtpartObject^.ProcessFormalParam^.ParameterSize);
        CopyParamsProcessModule;          
(* -- rh -- *)
%)

    ELSIF StmtpartObject^.class = ModuleObj THEN
      ActualProcedureLevel := StmtpartObject^.level;

      BeginProcedure (StmtpartObject^.procindex,StmtpartObject^.level,
                      ReservedProcFrameSize, ReservedParamFrameSize);

    ELSE
      ERROR ("procedure or function expected",bodyPos);
    END; (* IF *)
     
%( Modula_P
(* ++ rh ++ *)  (* 90/06 *)
    (* If the current compilation unit is a process module, the first *)
    (* action (after copying parameters) is to call the 'init procedure' *)
    (* of this process module ,which contains all the necessary calls *)
    (* to init procedures of imported modules.                        *)
    (* This init procedure is declared as the init procedure of a     *)
    (* module called                                                  *)
    (* 'PrefixOfInitModule'compilation-unit-name'SuffixOfInitModule   *)
    (* NOTICE: there are no corresponding statements in the 'compiled'*)
    (*         program						      *)
    (* also for the 'main' program                                    *)
    IF (StmtpartObject = CompUnitObject) THEN
      IF( SuBase.ThisCompUnitClass = SuBase.ProcessModuleClass) OR
         (SuBase.ThisCompUnitClass = SuBase.ProgramModuleClass) THEN
        GetIdentRepr (StmtpartObject^.name, ModName);
        Strings.Assign (InitModName, PrefixOfInitModule);
        Strings.Append (InitModName, ModName);
        Strings.Append (InitModName, SuffixOfInitModule);
        DeclareModule (TRUE, FALSE, FALSE, TRUE, 
                       FALSE, InitModName, moduleindex);
        DeclareProcedure (TRUE, FALSE, None,
                          NameOfInitProc, NumberOfInitProc, 
                          moduleindex, 0, UndefProcIndex, procindex);
        PreCall (0);
        ProcedureConstant (procindex, ProcOperand);
        Call (ProcOperand);
        PostCall (0);
      END;
    END;
(* -- rh -- *)
%) 
%( Debug
    LineNumberDebug (bodyPos); (* ++ hh 09/92 ++ *)
%) 

    (* initialize bodies of modules that are local to actual block *)
    CallSequence (StmtpartObject^.FirstLocalObject);

    (* statement sequence *)
%( Debug
    BeginDebugBlock; (* ++ hh 09/92 ++ *)
%)
    get1 (body,StatementlistNode);
    ClassStatementlist (StatementlistNode);

%( Debug
    LastLineNumberDebug; (* ++ hh 09/92 ++ *)
%)
    IF StmtpartObject^.class = ProcedureObj THEN
      IF StmtpartObject^.TypeOfProcedure^.ResultType <> TypeVOID THEN
	PreCall (0);
        SysCall (SysProcReturnError);
	PostCall (0);
%( Debug
	EndDebugBlock;
	Return (0);
%)
      ELSE (* dirk *)
%( Debug
	EndDebugBlock;
%)
	Return (StmtpartObject^.TypeOfProcedure^.ParameterSize);
      END; (* IF *)
    ELSE (* module body *)
%( Modula_P
(* ++ rh ++ *)  (* 90/05/29 *)
      IF (StmtpartObject^.class = ModuleObj) AND
         (StmtpartObject^.IsProcessModule) THEN
        Return (StmtpartObject^.ProcessFormalParam^.ParameterSize);
      ELSE
        Return (0);
      END;
%)
%( ~ Modula_P
%( Debug
      EndDebugBlock;
%)
      Return (0);
(* -- rh -- *)
%)
    END; (* IF *)
    EndProcedure;
%( Debug
    (* ++ hh 09/92 ++ *)
    LocalObjectsDebug (StmtpartObject^.FirstLocalObject);
%)
  ELSE 
    CompilerError ("assertion violation");
  END; (* IF *)

END TranslateStatementpart;
 
(******************************************************************************)
 
PROCEDURE InitStmts;
VAR i : SHORTCARD; success : BOOLEAN;
BEGIN
  InitTrBase;
  InitTrExpr;
  InitTrParam;
  InitTrDesig;
  InitTrSets;
  InitTrStProc;
  InitTrCompat;
   
  calc1 (CalcUnaryMinus,OneValue,MinusOneValue,success);
  IF TypeLONGINT^.size >= TypeSHORTINT^.size THEN
    BiggestSignedType := TypeLONGINT;
    MaxOfBiggestSignedType := MaxLongIntValue;
  ELSE
    BiggestSignedType := TypeSHORTINT;
    MaxOfBiggestSignedType := MaxShortIntValue;
  END;

  ParameterSizeNEWPROCESS := NewProcessParamSize;
  ParameterSizeTRANSFER   := TransferParamSize;
  ParameterSizeNEW        := StandardProcNEWparamSize;
  ParameterSizeDISPOSE    := StandardProcDISPOSEparamSize;

END InitStmts;
 
(****************************************************************************)
 
END TrStmts.
