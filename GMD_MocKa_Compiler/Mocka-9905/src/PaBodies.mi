(******************************************************************************)
(* Copyright (c) 1988 by GMD Karlruhe, Germany				      *)
(* Gesellschaft fuer Mathematik und Datenverarbeitung			      *)
(* (German National Research Center for Computer Science)		      *)
(* Forschungsstelle fuer Programmstrukturen an Universitaet Karlsruhe	      *)
(* All rights reserved.							      *)
(******************************************************************************)
%( Modula_P
(* 91/08/06, jv, introduced CHANNEL OF ANY                                    *)
%)

IMPLEMENTATION MODULE PaBodies;

  FROM DfTable IMPORT 
    Object;

  FROM SuErrors IMPORT
    SourcePosition, CompilerError, ERROR;

  FROM SuValues IMPORT
    CalcOperator, Value, ZeroValue, calc1;

  FROM SuTokens IMPORT
    Symbol, Ident, 
    CurSym, CurPos, CurIdent, CurValue, ErrorIdent,
    GetSym, CreateIdent;

  FROM PaSymSets IMPORT
    SetOfSymbols, FactorSet, DeclarationSet,
    AddOperatorSet, AddMulOperatorSet, BecomesLeftparSet,
    BeginSet, ByDoSet, CaseSepElseEndSet, ColonSet, CommaSet,
    DoSet, ExprSet, ElsifElseSet, EndSet,
    EofSet, LeftparLeftSetBrackSet, MulOperatorSet,
    OfSet, RangeCommaSet, RelationSet, RightBrackSet,
    RightSetBrackSet, RightparSet, SemicolonSet,
    SignSet, StmtSet, ThenSet, ToSet, UntilSet,
    ErrorMessage, AddSets, ElemInSet, Check, CheckSymbol1, CheckSymbol2;

  FROM SuTree IMPORT
    Node, NodeKind, 
    PutIdent, PutValue,
    put0, put1, put2, put3, put4, put5, append;
%( Modula_P
  FROM PaSymSets IMPORT
    CaseSepEndSet, ToRightBrackSet,
    BecomesLeftparChannelInOutSet, ChanInpCommaColonSet, AlternativeSet,
    StmtLeftBrackSet;
  FROM SuTree IMPORT
     get, get1;
%)

  VAR
    BodyStopSet : SetOfSymbols;
    ValueNode   : Node;
    BitsetNode  : Node;
    BitsetIdent : Ident; 
    OneValue    : Value;
    success     : BOOLEAN;

  VAR
    DummyNode : Node;
  
  PROCEDURE body (obj : Object);

    VAR  
      StmtListNode : Node;
      NodePos      : SourcePosition;

    PROCEDURE StatementSequence (VAR StopSet : SetOfSymbols; VAR node : Node);
      VAR 
        done, StmtMissing : BOOLEAN;
        ListNode1, ListNode2, 
        ExprNode, StmtNode : Node;
        NodePos  : SourcePosition;

      PROCEDURE ExprList (VAR StopSet : SetOfSymbols; VAR node : Node);
	VAR
	  LocalStopSet : SetOfSymbols;
	  ExprNode, ListNode1, ListNode2 : Node;
	  NodePos : SourcePosition;
      BEGIN
      (* ExprList : Expression // ',' . *)
	AddSets (LocalStopSet, CommaSet, StopSet);
	NodePos := CurPos; Expression (LocalStopSet, ExprNode);
	put2 (ExpressionlistElem, NodePos, ExprNode, DummyNode, node);
	ListNode1 := node;
	WHILE CurSym = CommaSym DO
	  GetSym; NodePos := CurPos; 
	  Expression (LocalStopSet, ExprNode);
	  put2 (ExpressionlistElem, NodePos, ExprNode, DummyNode, ListNode2);
	  append (ListNode1, ListNode2); ListNode1 := ListNode2;
	END;
	put0 (ExpressionlistEnd, CurPos, ListNode2);
	append (ListNode1, ListNode2);
      END ExprList;
      (*------------------------------------------------------------------*)

      PROCEDURE Designator (VAR StopSet : SetOfSymbols; VAR node : Node);
	VAR
	  LocalStopSet : SetOfSymbols;
	  IdNode : Node; NodePos : SourcePosition;

	PROCEDURE SubscrList (VAR StopSet : SetOfSymbols; VAR node : Node);
	  VAR
	    LocalStopSet : SetOfSymbols;
	    ExprNode : Node; NodePos : SourcePosition;
	BEGIN
	(* SubscrList : Expression // ',' . *)
	  AddSets (LocalStopSet, CommaSet, StopSet);
	  NodePos := CurPos;
          Expression (LocalStopSet, ExprNode);
          put2 (DesignatorSubscript, NodePos, node, ExprNode, node);
	  WHILE CurSym = CommaSym DO
	    GetSym; NodePos := CurPos; 
	    Expression (LocalStopSet, ExprNode);
	    put2 (DesignatorSubscript, NodePos, node, ExprNode, node);
	  END;
	END SubscrList;

      BEGIN 
      (* Designator : ident Modifier* . *)
	NodePos := CurPos; 
	IF CurSym = IdentSym THEN 
          PutIdent (CurPos, CurIdent, IdNode); GetSym;
	ELSE ErrorMessage ('identifier expected', CurPos);
	  PutIdent (CurPos, ErrorIdent, IdNode);
	END;
	put1 (DesignatorIdent, NodePos, IdNode, node);
	(* Modifier :
	     ModifierRecordOrModule / ModifierArray / ModifierPointer . *)
	AddSets (LocalStopSet, RightBrackSet, StopSet);
	LOOP 
          NodePos := CurPos;
	  IF CurSym = PointSym THEN GetSym;
	    (* ModifierRecordOrModule : '.' ident . *)
	    IF CurSym = IdentSym THEN 
	      PutIdent (CurPos, CurIdent, IdNode); GetSym;
	    ELSE ErrorMessage ('identifier expected', CurPos);
	      PutIdent (CurPos, ErrorIdent, IdNode);
	    END;
	    put2 (DesignatorSelect, NodePos, node, IdNode, node);
	  ELSIF CurSym = LeftBrackSym THEN GetSym;
	    (* ModifierArray : '[' SubscrList ']' . *)
	    SubscrList (LocalStopSet, node); 
	    Check (RightBrackSym, '] expected');
	  ELSIF CurSym = RefSym THEN GetSym;
	    (* ModifierPointer : '^' . *)
	    put1 (DesignatorDeref, NodePos, node, node);
	  ELSE EXIT;
	  END (* IF *);
	END (* LOOP *);
      END Designator;
      (*------------------------------------------------------------------*)

      PROCEDURE Expression (VAR StopSet : SetOfSymbols; VAR node : Node);
	VAR
	  LocalStopSet : SetOfSymbols;
	  OpNode : Node; NodePos : SourcePosition; CurOp : Symbol;

	PROCEDURE ConvertOperator (CurOp : Symbol) : NodeKind;
	(* converts CurOp to type NodeKind *)
	BEGIN
	  CASE CurOp OF
	    PlusSym         : RETURN ExpressionPlus;
	  | MinusSym        : RETURN ExpressionMinus;
	  | MulopSym        : RETURN ExpressionTimes;
	  | RealDivSym      : RETURN ExpressionRealDiv;
	  | DivSym          : RETURN ExpressionIntDiv;
	  | ModSym          : RETURN ExpressionMod;
	  | AndSym          : RETURN ExpressionAnd;
	  | OrSym           : RETURN ExpressionOr;
	  | InSym           : RETURN ExpressionIn;
	  | EqualSym        : RETURN ExpressionEqual;
	  | NotEqualSym     : RETURN ExpressionUnEqual;
	  | LessSym         : RETURN ExpressionLess;
	  | LessEqualSym    : RETURN ExpressionLessOrEqual;
	  | GreaterSym      : RETURN ExpressionGreater;
	  | GreaterEqualSym : RETURN ExpressionGreaterOrEqual;
	  ELSE
	    CompilerError ('illegal call of ConvertOperator'); HALT;
	  END;
	END ConvertOperator;

	PROCEDURE SimpleExpression (VAR StopSet : SetOfSymbols; 
                                    VAR node    : Node);
	  VAR 
	    LocalStopSet : SetOfSymbols; 
	    SignIsThere  : BOOLEAN;
	    OpNode : Node; NodePos : SourcePosition; CurOp : Symbol;

	  PROCEDURE Term (VAR StopSet : SetOfSymbols; VAR node : Node);
	    VAR 
	      LocalStopSet : SetOfSymbols; 
	      OpNode : Node; NodePos : SourcePosition; CurOp : Symbol;

	    PROCEDURE Factor (VAR StopSet : SetOfSymbols; VAR node : Node);
	      VAR 
		LocalStopSet : SetOfSymbols;
		DesNode, ExprNode : Node;
%( Modula_P
		PlacementNode : Node;
%)
		NodePos : SourcePosition;

	      PROCEDURE Set (VAR StopSet : SetOfSymbols; base : Node);
		VAR 
		  LocalStopSet : SetOfSymbols; ExprNode : Node;

		PROCEDURE RangeList (VAR StopSet : SetOfSymbols; 
                                     VAR node    : Node);
		  VAR
		    LocalStopSet1, LocalStopSet2 : SetOfSymbols;
		    ExprNode1, ExprNode2,
		    MemberNode, ListNode1, ListNode2 : Node;
		    NodePos : SourcePosition;
		BEGIN 
		(* RangeList :
		     (Expression ['..' Expression]) // ',' . *)
		  AddSets (LocalStopSet1, RangeCommaSet, StopSet);
		  AddSets (LocalStopSet2, CommaSet, StopSet);
		  NodePos := CurPos; Expression (LocalStopSet1, ExprNode1);
		  IF CurSym = RangeSym THEN GetSym; 
		    Expression (LocalStopSet2, ExprNode2);
		    put2 (MemberRange, NodePos, 
                      ExprNode1, ExprNode2, MemberNode);
		  ELSE
		    put1 (MemberExpr, NodePos, ExprNode1, MemberNode);
		  END;
		  put2 (MemberlistElem, NodePos, MemberNode, DummyNode, node);
		  ListNode1 := node;
		  WHILE CurSym = CommaSym DO GetSym; NodePos := CurPos;
		    Expression (LocalStopSet1, ExprNode1);
		    IF CurSym = RangeSym THEN
		      GetSym; Expression (LocalStopSet2, ExprNode2);
		      put2 (MemberRange,
			NodePos, ExprNode1, ExprNode2, MemberNode);
		    ELSE
		      put1 (MemberExpr, NodePos, ExprNode1, MemberNode);
		    END;
		    put2 (MemberlistElem,
		      NodePos, MemberNode, DummyNode, ListNode2);
		    append (ListNode1, ListNode2); ListNode1 := ListNode2;
		  END (* WHILE *);
		  put0 (MemberlistEnd, CurPos, ListNode2);
		  append (ListNode1, ListNode2);
		END RangeList;

	      BEGIN (* Set *)
	      (* Set : '{' [RangeList] '}' . *)
		GetSym;
		IF CurSym = RightSetBrackSym THEN 
		  put0 (MemberlistEnd, CurPos, ExprNode);
		  GetSym; (* empty set *)
		ELSE
		  AddSets (LocalStopSet, RightSetBrackSet, StopSet);
		  RangeList (LocalStopSet, ExprNode);
		  Check (RightSetBrackSym, '} expected');
		END;
		put2 (ExpressionSet, NodePos, base, ExprNode, node);
	      END Set;

	    BEGIN (* Factor *)
	    (* Factor :
		 FactorNumber / FactorString / FactorDesignator /
		 FactorSet    / FactorParen  / FactorNot . *)
	      NodePos := CurPos;
	      CASE CurSym OF
		IdentSym : 
		  (* FactorDesignator : Designator [ParametersOrSet] . *)
		  AddSets (LocalStopSet, LeftparLeftSetBrackSet, StopSet);
		  Designator (LocalStopSet, DesNode);
		  (* ParametersOrSet :
		       ParametersOrSetParameters / ParametersOrSetSet . *)
		  IF CurSym = LeftSetBrackSym THEN 
		    Set (StopSet, DesNode);
		    (* ParametersOrSetSet : Set . *)
		  ELSIF CurSym = LeftparSym THEN
		    (* ParametersOrSetParameters : ActualParameters . *)
		    GetSym;
		    IF CurSym = RightparSym THEN 
		      (* ActualParameters : '(' ')' . *)
		      put0 (ExpressionlistEnd, CurPos, ExprNode); GetSym; 
		    ELSE
		      (* ActualParameters : '(' ExprList ')' . *)
		      AddSets (LocalStopSet, RightparSet, StopSet);
		      ExprList (LocalStopSet, ExprNode);
		      Check (RightparSym, ') expected');
		    END (* IF *);
%( ~ Modula_P
		    put2 (ExpressionCall, NodePos, DesNode, ExprNode, node);
%)
%( Modula_P
                    put0 (PlacementEmpty, CurPos, PlacementNode);
		    put3 (ExpressionCall, NodePos, DesNode, ExprNode, 
					  PlacementNode, node);
%)
		  ELSE
		    put1 (ExpressionDesignator, NodePos, DesNode, node);
		  END (* IF *)
	      | LeftSetBrackSym :
		  (* FactorSet : Set . *)
		  PutIdent (CurPos, BitsetIdent, BitsetNode);
		  put1 (DesignatorIdent, CurPos, BitsetNode, BitsetNode);
		  Set (StopSet, BitsetNode);
	      | NotSym :   
		  (* FactorNot : 'NOT' Factor . *)
		  GetSym; Factor (StopSet, node);
		  put1 (ExpressionNot, NodePos, node, node);
	      | CharConstSym :
		  PutValue (CurPos, CurValue, ValueNode);
		  put1 (ExpressionChar, CurPos, ValueNode, node); GetSym; 
	      | StringConstSym :
		  PutValue (CurPos, CurValue, ValueNode);
		  put1 (ExpressionString, CurPos, ValueNode, node); GetSym; 
	      | IntConstSym :
		  PutValue (CurPos, CurValue, ValueNode);
		  put1 (ExpressionIntNumber, CurPos, ValueNode, node); GetSym; 
	      | RealConstSym : 
		  PutValue (CurPos, CurValue, ValueNode);
		  put1 (ExpressionRealNumber, CurPos, ValueNode, node); GetSym; 
	      | LeftparSym : 
		  (* FactorParen  : '(' Expression ')' . *)
		  GetSym; AddSets (LocalStopSet, RightparSet, StopSet);
		  Expression (LocalStopSet, node);
		  Check (RightparSym, ') expected');
	      ELSE 
		CheckSymbol2 (FactorSet, StopSet, 'error in factor');
                IF ElemInSet (CurSym, FactorSet) THEN
		  Factor (StopSet, node);
                ELSE
		  put0 (ExpressionError, CurPos, node);
                END;
	      END (* CASE *);
	      CheckSymbol1 (StopSet, 'error in factor');
	    END Factor;

	  BEGIN (* Term *)
          (* Term : (Factor // MulOperator) . *)
	    AddSets (LocalStopSet, MulOperatorSet, StopSet);
            Factor (LocalStopSet, node);
	    WHILE ElemInSet (CurSym, MulOperatorSet) DO
	      CurOp := CurSym; NodePos := CurPos;
	      GetSym; Factor (LocalStopSet, OpNode);
	      put2 (ConvertOperator (CurOp), NodePos, node, OpNode, node);
	    END (* WHILE *);
          END Term;

	BEGIN (* SimpleExpression *)
	(* SimpleExpression : [sign] (Term // AddOperator) . *)
	  AddSets (LocalStopSet, AddOperatorSet, StopSet);
	  IF ElemInSet (CurSym, SignSet) THEN 
	    CurOp := CurSym; NodePos := CurPos;
	    SignIsThere := TRUE; GetSym;
	  ELSE SignIsThere := FALSE;
	  END;
	  Term (LocalStopSet, node);
	  IF SignIsThere THEN 
	    IF CurOp = PlusSym THEN
	      put1 (ExpressionMonadicPlus, NodePos, node, node);
	    ELSE
	      put1 (ExpressionMonadicMinus, NodePos, node, node);
	    END;
	  END;
	  WHILE ElemInSet (CurSym, AddOperatorSet) DO
	    CurOp := CurSym; NodePos := CurPos;
	    GetSym; Term (LocalStopSet, OpNode);
	    put2 (ConvertOperator (CurOp), NodePos, node, OpNode, node);
	  END (* WHILE *);
	END SimpleExpression;
	 
      BEGIN (* Expression *)
      (* Expression : 
	   SimpleExpression [relation SimpleExpression] . *)
	AddSets (LocalStopSet, RelationSet, StopSet);
	SimpleExpression (LocalStopSet, node);
	IF ElemInSet (CurSym, RelationSet) THEN
	  CurOp := CurSym; NodePos := CurPos;
	  GetSym; SimpleExpression (StopSet, OpNode);
	  put2 (ConvertOperator (CurOp), NodePos, node, OpNode, node);
	END (* IF *);
      END Expression;
      (*--------------------------------------------------------------------*)

      PROCEDURE SimpleStatement (VAR node : Node);
	VAR
          LocalStopSet : SetOfSymbols; 
          DesNode, ExprNode : Node;
	  NodePos : SourcePosition;
%( Modula_P
          ExprDesigNode   : Node;
	  ExprDesigKind   : NodeKind;
	  ExprDesigPos    : SourcePosition;
	  MsgNode         : Node;
	  PlacementNode   : Node;
	  MessageSizeNode : Node;
	  IdNode          : Node;
%)
      BEGIN
%( Modula_P
      (* StatementSimple ::= designator StatementTail [ AT Expression ] *)
        AddSets (LocalStopSet, BecomesLeftparSet, StopSet);
        AddSets (LocalStopSet, BecomesLeftparChannelInOutSet, StopSet);
%)
      (* StatementSimple ::= designator StatementTail *)
	AddSets (LocalStopSet, BecomesLeftparSet, StopSet);
	NodePos := CurPos; Designator (LocalStopSet, DesNode);
	IF CurSym = BecomesSym THEN
	  (* StatementTail ::= ':=' expression *)
	  NodePos := CurPos; GetSym;
          Expression (StopSet, ExprNode);
          put2 (StatementAssign, NodePos, DesNode, ExprNode, node);
	ELSIF CurSym = LeftparSym THEN GetSym;
	  IF CurSym = RightparSym THEN 
	    (* StatementTail ::= ['(' ')'  *)
            GetSym; put0 (ExpressionlistEnd, CurPos, ExprNode);
	  ELSE
	    (* StatementTail ::= ['(' ExprList ')'  *)
	    AddSets (LocalStopSet, RightparSet, StopSet);
	    ExprList (LocalStopSet, ExprNode);
            Check (RightparSym, ') expected');
	  END;
%( Modula_P
	  IF CurSym = AtSym THEN
            GetSym;
	    Expression (StopSet, PlacementNode);
          ELSE put0 (PlacementEmpty, CurPos, PlacementNode)
	  END;
	  put3 (StatementCall, NodePos, DesNode, ExprNode, PlacementNode, node);
%)
%( ~ Modula_P
	  put2 (StatementCall, NodePos, DesNode, ExprNode, node);
%)
%( Modula_P
        ELSIF CurSym = ChannelInputSym
        THEN  (* StatementTail ::= '?' designator 
	       *                 | '?' expression ',' expression
	       *		 | '?' 'AFTER' expression 
	       *)
              NodePos := CurPos; GetSym;
              IF   CurSym = AfterSym
              THEN (* DelayStatement  *)
                   GetSym;
                   Expression (StopSet, ExprNode);
                   put2 (StatementDelay, NodePos, DesNode, ExprNode, node);
              ELSE (* channel input *)
	           AddSets (LocalStopSet, CommaSet, StopSet);
                   Expression (LocalStopSet, ExprDesigNode);
		   IF CurSym = CommaSym
		   THEN NodePos := CurPos; GetSym;
	                Expression (StopSet, MessageSizeNode);
			MsgNode := ExprDesigNode;
		   ELSE put0 (ExpressionNone, CurPos, MessageSizeNode);
			(* check, that the expression ExprDesig is a true *)
			(* Designator                                     *)
			get (ExprDesigNode, ExprDesigKind, ExprDesigPos);
			IF ExprDesigKind = ExpressionDesignator
			THEN get1 (ExprDesigNode, MsgNode);
			ELSE ERROR ("Variable expected", ExprDesigPos);
	                     PutIdent (ExprDesigPos, ErrorIdent, IdNode);
			     put1 (DesignatorIdent, ExprDesigPos,IdNode,MsgNode)
			END
                   END;
                   put3 (StatementChannelInput, NodePos, 
			 DesNode, MsgNode, MessageSizeNode, node)
              END
        ELSIF CurSym = ChannelOutputSym
        THEN  (* StatementTail ::= '!' expression [ ',' expression] *)
              NodePos := CurPos; GetSym;
	      AddSets (LocalStopSet, CommaSet, StopSet);
              Expression (LocalStopSet, ExprNode);
	      IF CurSym = CommaSym
	      THEN NodePos := CurPos; GetSym;
	           Expression (StopSet, MessageSizeNode);
	      ELSE put0 (ExpressionNone, CurPos, MessageSizeNode);
	      END;
	      put3 (StatementChannelOutput, NodePos, 
	            DesNode, ExprNode, MessageSizeNode, node)
%)
        ELSE
	  put0 (ExpressionlistEnd, CurPos, ExprNode);
%( Modula_P
	  IF CurSym = AtSym THEN
            GetSym;
	    Expression (StopSet, PlacementNode);
          ELSE put0 (PlacementEmpty, CurPos, PlacementNode)
	  END;
	  put3 (StatementCall, NodePos, DesNode, ExprNode, PlacementNode, node);
%)
%( ~ Modula_P
	  put2 (StatementCall, NodePos, DesNode, ExprNode, node);
%)
	END;
      END SimpleStatement;

      PROCEDURE IfStatement (VAR node : Node);
	VAR 
          LocalStopSet : SetOfSymbols;
	  CondNode, ThenNode, ElseNode : Node;
	  NodePos : SourcePosition;
	
	PROCEDURE ElseStatement (VAR StopSet : SetOfSymbols; VAR node : Node);
	  VAR
            LocalStopSet : SetOfSymbols;
            ListNode, CondNode, ThenNode, ElseNode : Node;
	    NodePos : SourcePosition;
	BEGIN
	(* ElseStatement ::=
	     'ELSIF' expression 'THEN' StatementSequence StatementElse 
	   StatementElse ::= ['ELSE' StatementSequence] 
	*)
	  IF CurSym = ElsifSym THEN
	    NodePos := CurPos; GetSym; 
            AddSets (LocalStopSet, ThenSet, StopSet); 
	    Expression (LocalStopSet, CondNode);
	    Check (ThenSym, 'THEN expected');
	    AddSets (LocalStopSet, ElsifElseSet, StopSet); 
	    StatementSequence (LocalStopSet, ThenNode);
	    ElseStatement (StopSet, ElseNode);
	    put3 (StatementIf, NodePos, CondNode, ThenNode, ElseNode, node);
            put2 (StatementlistElem, NodePos, node, DummyNode, node); 
	    put0 (StatementlistEnd, CurPos, ListNode);
            append (node, ListNode);
	  ELSIF CurSym = ElseSym THEN
	    GetSym; StatementSequence (StopSet, node);
          ELSE
	    put0 (StatementlistEnd, CurPos, node);
	  END; 
	END ElseStatement;

      BEGIN
	(* IfStatement ::= 
	     'IF' expression 'THEN' StatementSequence StatementElse 'END' *)
	NodePos := CurPos; GetSym;
        AddSets (LocalStopSet, ThenSet, StopSet); 
	Expression (LocalStopSet, CondNode);
	Check (ThenSym, 'THEN expected');
	AddSets (LocalStopSet, ElsifElseSet, StopSet); 
	StatementSequence (LocalStopSet, ThenNode);
	ElseStatement (StopSet, ElseNode);
	Check (EndSym, 'missing END of IF statement');
        put3 (StatementIf, NodePos, CondNode, ThenNode, ElseNode, node);
      END IfStatement;

      PROCEDURE CaseStatement (VAR node : Node);
	VAR
          LocalStopSet, StmtsStopSet : SetOfSymbols;
          NodePos, SubNodePos        : SourcePosition;
          ExprNode, LabelNode, ChoiceNode,
          StmtsNode, ListNode1, ListNode2 : Node;
          done : BOOLEAN;

	PROCEDURE CaseLabelList (VAR StopSet : SetOfSymbols; VAR node : Node);
	  VAR
	    LocalStopSet1, LocalStopSet2 : SetOfSymbols;
	    ExprNode1, ExprNode2,
	    LabelNode, ListNode1, ListNode2 : Node;
	    NodePos : SourcePosition;
	BEGIN 
	(* CaseLabelList :
	     (Expression ['..' Expression]) // ',' . *)
	  AddSets (LocalStopSet1, RangeCommaSet, StopSet);
	  AddSets (LocalStopSet2, CommaSet, StopSet);
	  NodePos := CurPos; Expression (LocalStopSet1, ExprNode1);
	  IF CurSym = RangeSym THEN
	    GetSym; Expression (LocalStopSet2, ExprNode2);
	    put2 (LabelRange, NodePos, ExprNode1, ExprNode2, LabelNode);
	  ELSE
	    put1 (LabelExpr, NodePos, ExprNode1, LabelNode);
	  END;
	  put2 (LabellistElem, NodePos, LabelNode, DummyNode, node);
	  ListNode1 := node;
	  WHILE CurSym = CommaSym DO GetSym; NodePos := CurPos;
	    Expression (LocalStopSet1, ExprNode1);
	    IF CurSym = RangeSym THEN
	      GetSym; Expression (LocalStopSet2, ExprNode2);
	      put2 (LabelRange, NodePos, ExprNode1, ExprNode2, LabelNode);
	    ELSE
	      put1 (LabelExpr, NodePos, ExprNode1, LabelNode);
	    END;
	    put2 (LabellistElem, NodePos, LabelNode, DummyNode, ListNode2);
	    append (ListNode1, ListNode2); ListNode1 := ListNode2;
	  END (* WHILE *);
	  put0 (LabellistEnd, CurPos, ListNode2);
	  append (ListNode1, ListNode2);
	END CaseLabelList;
	
      BEGIN
      (*  CaseStatement ::= 'CASE' expression 'OF' 
	    ([CaseLabelList ':' StatementSequence] // '|')
	    ['ELSE' StatementSequence] 'END' *)
	done := FALSE; NodePos := CurPos; GetSym;
	AddSets (LocalStopSet, OfSet, StopSet); 
	Expression (LocalStopSet, ExprNode);
	Check (OfSym, 'OF expected');
	AddSets (LocalStopSet, ColonSet, StopSet); 
	AddSets (StmtsStopSet, CaseSepElseEndSet, StopSet); 
	LOOP
	  IF ElemInSet (CurSym, ExprSet) THEN
	    SubNodePos := CurPos; 
            CaseLabelList (LocalStopSet, LabelNode); 
	    Check (ColonSym, ': expected');
	    StatementSequence (StmtsStopSet, StmtsNode);
            put2 (Choice, SubNodePos, LabelNode, StmtsNode, LabelNode);
	    IF done THEN
	      put2 (ChoicelistElem, NodePos, LabelNode, DummyNode, ListNode2); 
	      append (ListNode1, ListNode2); ListNode1 := ListNode2;
	    ELSE
	      put2 (ChoicelistElem, NodePos, LabelNode, DummyNode, ChoiceNode); 
	      ListNode1 := ChoiceNode; done := TRUE;
	    END;
	  END;
	  IF CurSym = CaseSepSym THEN GetSym ELSE EXIT; END;
	END (* LOOP *);
	IF done THEN 
	  put0 (ChoicelistEnd, CurPos, ListNode2);
	  append (ListNode1, ListNode2);
	ELSE
	  put0 (ChoicelistEnd, CurPos, ChoiceNode);
	END;
	IF CurSym = ElseSym THEN
          SubNodePos := CurPos; GetSym; 
          StatementSequence (StopSet, StmtsNode);
	  put3 (StatementCaseElse, NodePos,
            ExprNode, ChoiceNode, StmtsNode, node);
        ELSE
	  put2 (StatementCaseSimple, NodePos, ExprNode, ChoiceNode, node);
        END;
	Check (EndSym, 'missing END of CASE statement');
      END CaseStatement;

      PROCEDURE WhileStatement (VAR node : Node);
	VAR 
          LocalStopSet : SetOfSymbols;
          CondNode, StmtsNode : Node;
	  NodePos : SourcePosition;
      BEGIN
      (* WhileStatement ::= 'WHILE' expression 'DO' StatementSequence 'END' *)
	NodePos := CurPos; GetSym;
        AddSets (LocalStopSet, DoSet, StopSet);
	Expression (LocalStopSet, CondNode);
	Check (DoSym, 'DO expected');
	StatementSequence (StopSet, StmtsNode);
	Check (EndSym, 'missing END of WHILE statement');
        put2 (StatementWhile, NodePos, CondNode, StmtsNode, node);
      END WhileStatement;

      PROCEDURE RepeatStatement (VAR node : Node);
	VAR
          LocalStopSet : SetOfSymbols;
          CondNode, StmtsNode : Node;
	  NodePos : SourcePosition;
      BEGIN
      (* RepeatStatement ::= 'REPEAT' StatementSequence 'UNTIL' expression *)
	NodePos := CurPos; GetSym; 
        AddSets (LocalStopSet, UntilSet, StopSet);
	StatementSequence (LocalStopSet, StmtsNode);
	Check (UntilSym, 'UNTIL expected');
	Expression (StopSet, CondNode);
        put2 (StatementRepeat, NodePos, CondNode, StmtsNode, node);
      END RepeatStatement;

      PROCEDURE LoopStatement (VAR node : Node);
        VAR
          StmtsNode : Node; NodePos : SourcePosition;
      BEGIN
      (* LoopStatement ::= 'LOOP' StatementSequence 'END' *)
	NodePos := CurPos; GetSym;
	StatementSequence (StopSet, StmtsNode);
	Check (EndSym, 'missing END of LOOP statement');
        put1 (StatementLoop, NodePos, StmtsNode, node);
      END LoopStatement;

      PROCEDURE ForStatement (VAR node : Node);
	VAR
          LocalStopSet : SetOfSymbols;
          IdNode, ExprNode1, 
          ExprNode2, ExprNode3, StmtsNode : Node;
          NodePos : SourcePosition;
       
        PROCEDURE PutDefaultBy (pos : SourcePosition; VAR node : Node);
          VAR ValueNode : Node;
        BEGIN
	  PutValue (pos, OneValue, ValueNode);
	  put1 (ExpressionIntNumber, pos, ValueNode, node);
        END PutDefaultBy;

      BEGIN
      (* ForStatement ::= 'FOR' ident ':=' expression 'TO' expression 
			  ['BY' expression] 'DO' StatementSequence 'END' *)
	NodePos := CurPos; GetSym; 
	IF CurSym = IdentSym THEN
	  PutIdent (CurPos, CurIdent, IdNode); GetSym;
	ELSE 
          ErrorMessage ('identifier expected', CurPos);
	  PutIdent (CurPos, ErrorIdent, IdNode);
	END;
	Check (BecomesSym, ':= expected');
	AddSets (LocalStopSet, ToSet, StopSet);
	Expression (LocalStopSet, ExprNode1);
	Check (ToSym, 'TO expected');
	AddSets (LocalStopSet, ByDoSet, StopSet);
	Expression (LocalStopSet, ExprNode2);
	IF CurSym = BySym THEN GetSym;
	  AddSets (LocalStopSet, DoSet, StopSet);
	  Expression (LocalStopSet, ExprNode3);
        ELSE
          PutDefaultBy (CurPos, ExprNode3); 
	END;
	Check (DoSym, 'DO expected');
	StatementSequence (StopSet, StmtsNode);
	Check (EndSym, 'missing END of FOR statement');
        put5 (StatementFor, NodePos, IdNode, 
          ExprNode1, ExprNode2, ExprNode3, StmtsNode, node);
      END ForStatement;

      PROCEDURE WithStatement (VAR node : Node);
	VAR
          LocalStopSet : SetOfSymbols;
          DesNode, StmtsNode : Node;
	  NodePos : SourcePosition;
      BEGIN
      (* WithStatement ::= 'WITH' designator 'DO' StatementSequence 'END' *)
	NodePos := CurPos; GetSym;
        AddSets (LocalStopSet, DoSet, StopSet);
	Designator (LocalStopSet, DesNode);
	Check (DoSym, 'DO expected');
	StatementSequence (StopSet, StmtsNode);
	Check (EndSym, 'missing END of WITH statement');
        put2 (StatementWith, NodePos, DesNode, StmtsNode, node);
      END WithStatement;

%( Modula_P
      PROCEDURE ParseReplicator (StopSet : SetOfSymbols; VAR node : Node);
      VAR id_Node, lwb_Node, upb_Node  : Node;
          LocalStopSet1, LocalStopSet2 : SetOfSymbols;
      BEGIN (* ParseReplicator *)
       (* Replicator ::= '[' ident ':' expression 'TO' expression ']' *)
       NodePos := CurPos; GetSym;
       AddSets (LocalStopSet1, ToRightBrackSet, StopSet);
       AddSets (LocalStopSet2, RightBrackSet,   StopSet);
       IF   CurSym = IdentSym 
       THEN PutIdent (CurPos, CurIdent, id_Node); GetSym
       ELSE ErrorMessage ("identifier expected", CurPos);
            PutIdent (CurPos, ErrorIdent, id_Node);
       END;
       Check (ColonSym, "':' expected"); 
       Expression (LocalStopSet1, lwb_Node); 
       Check (ToSym, "'TO' expected");
       Expression (LocalStopSet1, upb_Node); 
       Check (RightBrackSym, "']' expected");
       put3  (Replicator, NodePos, id_Node, lwb_Node, upb_Node, node);
      END ParseReplicator;

      PROCEDURE ParStatement (VAR node : Node);
      VAR NodePos, SubNodePos                : SourcePosition;
          ProcessList_Node, ProcessBody_Node : Node;
          List1_Node, List2_Node             : Node;
          LocalStopSet                       : SetOfSymbols;
          done                               : BOOLEAN;

        PROCEDURE ParseProcessBody (VAR StopSet : SetOfSymbols;VAR node : Node);
        VAR NodePos         : SourcePosition;
            StmtsNode       : Node;
            ReplicatorNode  : Node;
            Process_StopSet : SetOfSymbols;
        BEGIN (* ParseProcessBody *)
          (* ProcessBody ::= [Replicator] StatementSequence  *)
          NodePos := CurPos;
          AddSets (Process_StopSet, CaseSepEndSet, StopSet);

          IF   CurSym = LeftBrackSym
          THEN ParseReplicator (Process_StopSet, ReplicatorNode);
          ELSE put0 (ReplicatorEmpty, CurPos, ReplicatorNode)
          END;
         
          StatementSequence (Process_StopSet, StmtsNode);
          put2 (ProcessBody, NodePos, ReplicatorNode, StmtsNode, node);
        END ParseProcessBody;

      BEGIN (* ParStatement *)
        (* ParStatement ::= 'PAR' ProcessBody // '|' 'END' *)
        NodePos := CurPos; GetSym;
        AddSets (LocalStopSet, CaseSepEndSet, StopSet);
        done := FALSE;
        LOOP
          SubNodePos := CurPos;
          IF   ElemInSet (CurSym, StmtLeftBrackSet)
          THEN ParseProcessBody (LocalStopSet, ProcessBody_Node); 
               IF   done
               THEN put2 (ProcesslistElem, SubNodePos, 
                          ProcessBody_Node, DummyNode, List2_Node);
                    append (List1_Node, List2_Node);
                    List1_Node := List2_Node;
               ELSE put2 (ProcesslistElem, SubNodePos, 
                          ProcessBody_Node, DummyNode, ProcessList_Node);
                    List1_Node := ProcessList_Node;
                    done := TRUE;
               END;
          END;
         
          IF   CurSym = CaseSepSym THEN GetSym ELSE EXIT END; 
        END; (* LOOP *)
        IF   done
        THEN put0   (ProcesslistEnd, NodePos, List2_Node); 
             append (List1_Node, List2_Node);
        ELSE put0   (ProcesslistEnd, NodePos, ProcessList_Node); 
        END;
        put1   (StatementPar, NodePos, ProcessList_Node, node);
        Check  (EndSym, 'missing END of PAR statement');
      END ParStatement;

      PROCEDURE AltStatement (VAR node : Node);
      VAR NodePos, SubNodePos                : SourcePosition;
          AltList_Node, alternative_Node     : Node;
          ElsePart_Node                      : Node;
          List1_Node, List2_Node             : Node;
          LocalStopSet                       : SetOfSymbols;
          firstAlternative                   : BOOLEAN;
          exprKind                           : NodeKind;
          exprPos                            : SourcePosition;
          desigNode                          : Node;

        PROCEDURE ParseAlternative (VAR AltStopSet : SetOfSymbols;
                                    VAR node       : Node);
        VAR NodePos : SourcePosition;
            repNode, exprNode, inpStmtNode, bodyNode : Node;
            OldGlobalStopSet, LocalStopSet : SetOfSymbols;
             
            
          PROCEDURE DefaultBoolExpr (VAR node : Node);
          (* If the boolean expression of the guard is missing, it *)
          (* is assumed to be 'TRUE'                               *)
          (* A tree is build up, representing the constant TRUE    *)
          (* expression.                                           *)
          VAR Id_Node, DesigIdent_Node : Node;
              TrueIdent : Ident;
          BEGIN (* DefaultBoolExpr *)
            CreateIdent (TrueIdent, "TRUE");
            PutIdent (CurPos, TrueIdent, Id_Node);
            put1 (DesignatorIdent, CurPos, Id_Node, DesigIdent_Node); 
            put1 (ExpressionDesignator, CurPos, DesigIdent_Node, node);
          END DefaultBoolExpr;

          PROCEDURE ParseInputStmt (StopSet : SetOfSymbols;
                                    lhsNode : Node; VAR node : Node);
          (* Parse a a StatementTail for an input or delay statement. *)
          (* The lhs is given by 'lhsNode' and must be a designator.  *)
          (* If an error occurs, an 'AltEmptyInputStmt' is returned.  *)
          (* If no error occurs, an 'AltInputStmt' is returned.       *)
          VAR NodePos : SourcePosition;
              exprNode, DesNode, MessageSizeNode : Node;
              MsgNode, MsgSizeNode, ExprDesigNode, IdNode  : Node;
	      ExprDesigKind : NodeKind;
	      ExprDesigPos  : SourcePosition;
              LocalStopSet : SetOfSymbols;
          BEGIN (* ParseInputStmt *)
            (* StatementTail ::= '?' designator  
	     *                 | '?' expression ',' expression
	     *                 | '?' 'AFTER' expression 
	     *)
            NodePos := CurPos;
	    IF    CurSym = ChannelInputSym 
            THEN  NodePos := CurPos; GetSym;
                  IF   CurSym = AfterSym
                  THEN (* DelayStatement  *)
                       GetSym;
                       Expression (StopSet, exprNode);
                       put2 (StatementDelay, NodePos, lhsNode, exprNode, node);
                       put1 (AltInputStmt,   NodePos,  node, node);
                  ELSE (* channel input *)
	               AddSets (LocalStopSet, CommaSet, StopSet);
                       Expression (LocalStopSet, ExprDesigNode);
		       IF CurSym = CommaSym
		       THEN NodePos := CurPos; GetSym;
	                    Expression (StopSet, MessageSizeNode);
			    MsgNode := ExprDesigNode;
		       ELSE put0 (ExpressionNone, CurPos, MessageSizeNode);
			    (* check, that the expression ExprDesig is a true *)
			    (* Designator                                     *)
			    get (ExprDesigNode, ExprDesigKind, ExprDesigPos);
			    IF ExprDesigKind = ExpressionDesignator
			    THEN get1 (ExprDesigNode, MsgNode);
			    ELSE ERROR ("Variable expected", ExprDesigPos);
	                         PutIdent (ExprDesigPos, ErrorIdent, IdNode);
			         put1     (DesignatorIdent, ExprDesigPos,IdNode,
				           MsgNode)
			    END
                       END;
                       put3 (StatementChannelInput, NodePos, 
			     lhsNode, MsgNode, MessageSizeNode, node);
                       put1 (AltInputStmt, NodePos, node, node);
                  END
            ELSE ERROR ("missing channel input or delay statement", NodePos);
                 put0 (AltEmptyInputStmt, NodePos, node);
            END;
          END ParseInputStmt;

        BEGIN (* ParseAlternative *)
          (******************************************************************)
          (* alternative ::= [Replicator] guard ':' StatementSequence.      *)
          (* guard ::= expression |                                         *)
          (*           [expression ','] InputStatement   |                  *)
          (*           [expression ','] DelayStatement.                     *)
          (* InputStatement ::= designator '?' expression.                  *)
          (* DelayStatement ::= 'TIMER' '?' 'AFTER' expression.             *)
          (* The input or delay statement is simplyfied to SimpleStatement. *)
          (******************************************************************)

          NodePos := CurPos;
          AddSets (LocalStopSet, ChanInpCommaColonSet, AltStopSet);

          IF   CurSym = LeftBrackSym
          THEN ParseReplicator (LocalStopSet, repNode);
          ELSE put0 (ReplicatorEmpty, CurPos, repNode);
          END;

          (********************************************************************)
          (* The grammer for guards is not LL1, hence a special treatment is  *)
          (* used:                                                            *)
          (* actions for parsing the guard:                                   *)
          (*    try to parse an expression.                                   *)
          (*    If then the CurSym = CommaSym                                 *)
          (*    then  the result node represents the boolean part of the guard*)
          (*          then parse one statement.                               *)
          (*    elsif CurSym = ColonSym                                       *)
          (*    then  the result node represents the boolean part of the guard*)
          (*          but there is no input / delay statement.                *)
          (*    else  the boolean part is omitted, the result node must be    *)
          (*          a 'ExpressionDesignator', this designator is then used  *)
          (*          as a channel designator for the input statement.        *)
          (********************************************************************)
 
          Expression (LocalStopSet, exprNode); 
          IF    CurSym = CommaSym
          THEN  (* exprNode contains a 'real' expression *)
                GetSym;
                (* MUST change the global StopSet for the SimpleStatement *)
                OldGlobalStopSet := StopSet;
                StopSet := LocalStopSet; 
                SimpleStatement (inpStmtNode);
                StopSet := OldGlobalStopSet;
                put1 (AltInputStmt, NodePos, inpStmtNode, inpStmtNode);
          ELSIF CurSym = ColonSym
          THEN  (* just an expression, without any input statement *)
                put0 (AltEmptyInputStmt, NodePos, inpStmtNode);
          ELSE  (* boolean expression is ommited, with a input statement *)
                (* check that boolean expression is a designator *)
                get (exprNode, exprKind, exprPos);
                IF   exprKind = ExpressionDesignator
                THEN get1 (exprNode, desigNode);
                     ParseInputStmt (LocalStopSet, desigNode, inpStmtNode);
                     DefaultBoolExpr (exprNode);
                ELSE ERROR ("designator expected", exprPos);
                     DefaultBoolExpr (exprNode);
                     put0 (AltEmptyInputStmt, NodePos, inpStmtNode);
                END;
          END;
          Check (ColonSym, "missing ':'");
          StatementSequence (AltStopSet, bodyNode);
          put4 (Alternative, NodePos, repNode,     exprNode, 
                                      inpStmtNode, bodyNode, node);
        END ParseAlternative;

      BEGIN (* AltStatement *)
        (* AltStatement ::= 'ALT' alternative // '|'                    *)
        (*                        ['ELSE' StatementSequence] 'END'.     *)
        NodePos := CurPos; GetSym;
        AddSets (LocalStopSet, CaseSepElseEndSet, StopSet);
        firstAlternative := TRUE;
        LOOP
          IF   ElemInSet (CurSym, AlternativeSet)
          THEN SubNodePos := CurPos;
               ParseAlternative (LocalStopSet, alternative_Node);
               IF   firstAlternative
               THEN firstAlternative := FALSE;
                    put2 (AlternativelistElem, SubNodePos, alternative_Node,
                                               DummyNode,  AltList_Node);
                    List1_Node := AltList_Node;
               ELSE put2 (AlternativelistElem, SubNodePos, alternative_Node,
                                               DummyNode,  List2_Node);
                    append (List1_Node, List2_Node);
                    List1_Node := List2_Node;
               END;
          END;  
          IF CurSym = CaseSepSym THEN GetSym ELSE EXIT END;
        END; (* loop *)

        IF   firstAlternative
        THEN (* i.e. there is no alternative *)
             put0 (AlternativelistEnd, CurPos, AltList_Node);
        ELSE put0 (AlternativelistEnd, CurPos, List2_Node);
             append (List1_Node, List2_Node);
        END; 

        IF   CurSym = ElseSym
        THEN SubNodePos := CurPos; GetSym;
             StatementSequence (LocalStopSet, ElsePart_Node);
             put2 (StatementAltElse,   NodePos, AltList_Node,ElsePart_Node,node)
        ELSE put1 (StatementAltSimple, NodePos, AltList_Node, node)
        END;
        Check (EndSym, 'missing END of ALT statement'); 
      END AltStatement;

%)
    BEGIN 
    (* StatementSequence ::= [statement] // ; *)
      done := FALSE; StmtMissing := FALSE;
      LOOP
        NodePos := CurPos; 
	CASE CurSym OF 
	  IdentSym :  SimpleStatement (StmtNode);
	| IfSym :     IfStatement (StmtNode);
	| CaseSym :   CaseStatement (StmtNode);
	| WhileSym :  WhileStatement (StmtNode);
	| RepeatSym : RepeatStatement (StmtNode);
	| LoopSym :   LoopStatement (StmtNode);
	| ForSym :    ForStatement (StmtNode);
	| WithSym :   WithStatement (StmtNode);
	| ExitSym :   (* ExitStatement ::= 'EXIT' *) 
	    put0 (StatementExit, NodePos, StmtNode); GetSym;
	| ReturnSym : (* ReturnStatement ::= 'RETURN' [expression] *)
	    GetSym;
	    IF ElemInSet (CurSym, ExprSet) THEN
	      Expression (StopSet, ExprNode);
	      put1 (StatementReturnexpr, NodePos, ExprNode, StmtNode);
            ELSE
	      put0 (StatementReturnvoid, NodePos, StmtNode);
	    END;
%( Modula_P
        | ParSym   : ParStatement   (StmtNode);
        | AltSym   : AltStatement   (StmtNode);
%)
	ELSE
          StmtMissing := TRUE;
	END (* CASE *);
	IF StmtMissing THEN
          StmtMissing := FALSE;
	ELSIF done THEN
	  put2 (StatementlistElem, NodePos, StmtNode, DummyNode, ListNode2); 
	  append (ListNode1, ListNode2); ListNode1 := ListNode2;
        ELSE
	  put2 (StatementlistElem, NodePos, StmtNode, DummyNode, node); 
	  ListNode1 := node; done := TRUE;
	END;
	IF CurSym = SemicolonSym THEN GetSym; 
	ELSE
	  CheckSymbol1 (StopSet, 'error in statement');
	  IF CurSym = SemicolonSym THEN GetSym; 
          ELSIF ElemInSet (CurSym, StmtSet) THEN
            ErrorMessage ('; expected', CurPos);
	  ELSE EXIT
          END;
	END;
      END (* LOOP *);
      IF done THEN 
	put0 (StatementlistEnd, CurPos, ListNode2);
	append (ListNode1, ListNode2);
      ELSE
	put0 (StatementlistEnd, CurPos, node);
      END;
    END StatementSequence;

  BEGIN 
    (* body ::= ['BEGIN' StatementSequence] *)
    NodePos := CurPos;
    IF CurSym = BeginSym THEN GetSym;
      StatementSequence (BodyStopSet, StmtListNode);
    ELSE
      put0 (StatementlistEnd, CurPos, StmtListNode);
    END;
    put1 (Statementpart, NodePos, StmtListNode, obj^.body);
  END body;

  PROCEDURE InitBodies;
  BEGIN
    AddSets (BodyStopSet, EndSet, EofSet);
    AddSets (BodyStopSet, BeginSet, BodyStopSet);
    AddSets (BodyStopSet, SemicolonSet, BodyStopSet);
    AddSets (BodyStopSet, StmtSet, BodyStopSet);
    AddSets (BodyStopSet, DeclarationSet, BodyStopSet);
    CreateIdent (BitsetIdent, 'BITSET');
    calc1 (CalcIncr, ZeroValue, OneValue, success);
  END InitBodies;

END PaBodies.
