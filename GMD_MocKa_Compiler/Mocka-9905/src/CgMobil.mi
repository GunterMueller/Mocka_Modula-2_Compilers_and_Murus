  (**************************************************************) 
  (*   This module was generated by BEG V1.84        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
 IMPLEMENTATION MODULE CgMobil;
 
 
 IMPORT     IR;
 IMPORT     Emit;
(*++++++ start insertion IpIRConsStorage ++++++*)

FROM GcgStorage IMPORT ALLOCATE;


(*------ end   insertion IpIRConsStorage ------*)
 FROM       IR      IMPORT NonTerminal;
 FROM       IR      IMPORT OpCode;

(*++++++ start insertion IpNtTypes ++++++*)

FROM IR	IMPORT	MemAdr, AdrMode, AdrModeMode;


(*------ end   insertion IpNtTypes ------*)
(******* empty insertion IpText *******)
(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;
FROM Strings	IMPORT	String;


(*------ end   insertion IpTypes ------*)
(*++++++ start insertion IpCgMobil_i ++++++*)

FROM LREAL		IMPORT	LTRUNC, LFLOAT;
FROM MathLib		IMPORT	real, entierL;
FROM Strings		IMPORT	StrEq;
FROM SuErrors		IMPORT	ERROR;
FROM CgBase		IMPORT	GetLabel;
FROM CgTypeMap		IMPORT	ReservedParamFrameSize;
FROM CgUtilities	IMPORT	IsPowerOfTwo, Log2;
FROM Emit		IMPORT	SizeTable, SignedTable, NullSymb, DisplaySym,
				CurLevel, CallLevel, MaxCallLevel, CurPos,
				IsNilMemAdr;
FROM GcgStorage		IMPORT	InitGcgStorage;

CONST	FloatMaxCardinal = 4294967295.0;
	
VAR     optemp : Operand;	(* Temporaries for CONDITIONS etc. *)

VAR	ParamSize	: ARRAY [1..MaxCallLevel] OF LONGINT;
	CurParamOffset  : ARRAY [1..MaxCallLevel] OF LONGINT;
	arglist		: ARRAY [1..MaxCallLevel] OF Arglist;
	callee		: Address;
	r		: REAL;

PROCEDURE EqualMemAdr (a,b: MemAdr) : BOOLEAN;
BEGIN
  RETURN (a.offset = b.offset) AND
	 (a.faktor = b.faktor) AND
	 (a.base = b.base) AND
	 (a.index = b.index) AND
	 (a.symbol = b.symbol)
END EqualMemAdr;

PROCEDURE DeclareModule
   (    extern       : BOOLEAN;
    VAR CompUnitName : ARRAY OF CHAR; 
    VAR ref          : ModuleIndex);
BEGIN
   Emit.DeclareModule (extern, CompUnitName, ref);
END DeclareModule;


PROCEDURE DeclareProcedure
   (    extern       : BOOLEAN;
	isFunction   : BOOLEAN;
	ProcMode     : Mode;
    VAR ProcName     : ARRAY OF CHAR; 
        ProcNumber   : SHORTCARD;
        module       : ModuleIndex;
	level        : SHORTCARD;
	father       : ProcIndex;
    VAR ref          : ProcIndex);
BEGIN
  Emit.DeclareProcedure (extern, isFunction, ProcMode,
			 ProcName, ProcNumber, module, level, father, ref);
END DeclareProcedure;


PROCEDURE DeclareString
   (    length : SHORTCARD;
    VAR string : ARRAY OF CHAR; 
    VAR ref    : StringIndex);
BEGIN
  Emit.DeclareString (length, string, ref);
END DeclareString;


PROCEDURE DeclareLabel (VAR lab : CgBase.Label);
BEGIN
  GetLabel (lab);
END DeclareLabel;


PROCEDURE DeclareDataTempo (mode: CgBase.Mode; VAR tempo: CgBase.Tempo);
BEGIN
  Emit.DeclareTempo (mode, tempo);
END DeclareDataTempo;

  
PROCEDURE DeclareAddressTempo (VAR tempo: CgBase.Tempo);
BEGIN
  Emit.DeclareTempo (SignedLong, tempo);
END DeclareAddressTempo;
 

PROCEDURE Switch
   (mode         : Mode;
    lwb          : LONGINT;
    upb          : LONGINT;
    CaseLabels   : ARRAY OF CgBase.Label;
    DefaultLabel : CgBase.Label;
    op           : Operand);
(* Zunaechst wird die Label-Liste <CaseLabels> von der ARRAY-Struktur	*)
(* des Front-Ends in eine verkettete Liste <LabelList> umgespeichert.	*)
VAR   l,ll,l1 : CgBase.LabelList;
      i       : LONGINT;
BEGIN
   NEW (l); ll:=l;
   l^.label := CaseLabels[0];
   FOR i:=1 TO upb - lwb DO 
      NEW (l1); ll^.next := l1; ll :=l1;
      l1^.label := CaseLabels[i];
   END;
   ll^.next := NIL;
   Coerce (mode, UnsignedLong, op, op);
   SwitchL (UnsignedLong, lwb, upb, l, DefaultLabel, op);
END Switch;

PROCEDURE  BeginModule
   (AtModulName  :  ARRAY OF CHAR;
    AtFrameSize  :  LONGINT);
BEGIN
   InitGcgStorage;
   FirstAttr := NIL; MemExtend;
   Emit.BeginModule (AtModulName, AtFrameSize);
END BeginModule;


(*------ end   insertion IpCgMobil_i ------*)
 VAR
    FirstExpr, NextExpr, LastExpr    :  IR.Expression;
    FirstAttr, NextAttr, LastAttr    :  IR.Attributes;
    FirstGcg,  NextGcg,  LastGcg     :  IR.ExprAttributes;
 
 PROCEDURE MatchChainRules (e : IR.Expression);
 VAR   fired   : BOOLEAN;
       ga      : IR.ExprAttributes;
 BEGIN
    ga := e^.gcg;
      IF ga^.cost[ntSymPlusOffset] > ga^.cost[ntConstant] THEN
      (* RULE 219/332 *)
 ga^.SymPlusOffset.offset	:= e^.gcg^.Constant.val; ;
      ga^.cost[ntSymPlusOffset] :=  ga^.cost[ntConstant];
      ga^.rule[ntSymPlusOffset] := 219;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntSymPlusOffset] THEN
      (* RULE 233/336 *)
 ga^.RegPlusSymPlusOffset.offset	:= e^.gcg^.SymPlusOffset.offset; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntSymPlusOffset];
      ga^.rule[ntRegPlusSymPlusOffset] := 233;
   END;

      IF ga^.cost[ntRegOrIm] > ga^.cost[ntConstant] THEN
      (* RULE 266/418 *)
 ga^.RegOrIm.mode     := e^.gcg^.Constant.mode; ;
      ga^.cost[ntRegOrIm] :=  ga^.cost[ntConstant];
      ga^.rule[ntRegOrIm] := 266;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntConstant] THEN
      (* RULE 270/424 *)
 ga^.RegOrCMemOrIm.mode     := e^.gcg^.Constant.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntConstant];
      ga^.rule[ntRegOrCMemOrIm] := 270;
   END;

      IF ga^.cost[ntCMem] > ga^.cost[ntFloatConstant] THEN
      (* RULE 265/452 *)
   IF  e^.gcg^.FloatConstant.mode = FloatShort  THEN 
 ga^.CMem.mode := e^.gcg^.FloatConstant.mode; ;
      ga^.cost[ntCMem] :=  ga^.cost[ntFloatConstant];
      ga^.rule[ntCMem] := 265;
   END;
   END;

      IF ga^.cost[ntCMem] > ga^.cost[ntFloatConstant] THEN
      (* RULE 264/471 *)
   IF  e^.gcg^.FloatConstant.mode = FloatLong  THEN 
 ga^.CMem.mode := e^.gcg^.FloatConstant.mode; ;
      ga^.cost[ntCMem] :=  ga^.cost[ntFloatConstant];
      ga^.rule[ntCMem] := 264;
   END;
   END;

      IF ga^.cost[ntRegOrCMem] > ga^.cost[ntCMem] THEN
      (* RULE 268/403 *)
 ga^.RegOrCMem.mode    := e^.gcg^.CMem.mode; ;
      ga^.cost[ntRegOrCMem] :=  ga^.cost[ntCMem];
      ga^.rule[ntRegOrCMem] := 268;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 257/382 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 257;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg]+3 THEN
      (* RULE 241/363 *)
   IF  SizeTable[e^.gcg^.reg.mode] < 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg]+3;
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 241;
   END;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg] THEN
      (* RULE 242/357 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg];
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 242;
   END;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg]+3 THEN
      (* RULE 231/347 *)
   IF  SizeTable[e^.gcg^.reg.mode] < 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg]+3;
      ga^.rule[ntRegPlusSymPlusOffset] := 231;
   END;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntRegOrCMem] THEN
      (* RULE 271/409 *)
 ga^.RegOrCMemOrIm.mode    := e^.gcg^.RegOrCMem.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntRegOrCMem];
      ga^.rule[ntRegOrCMemOrIm] := 271;
   END;

      IF ga^.cost[ntreg] > ga^.cost[ntRegOrCMemOrIm]+2 THEN
      (* RULE 135/445 *)
 ga^.reg.mode := e^.gcg^.RegOrCMemOrIm.mode ;
      ga^.cost[ntreg] :=  ga^.cost[ntRegOrCMemOrIm]+2;
      ga^.rule[ntreg] := 135;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg] THEN
      (* RULE 232/341 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg];
      ga^.rule[ntRegPlusSymPlusOffset] := 232;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntRegPlusSymPlusOffset] THEN
      (* RULE 258/373 *)
 ga^.mem.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= 1; ;
      ga^.cost[ntmem] :=  ga^.cost[ntRegPlusSymPlusOffset];
      ga^.rule[ntmem] := 258;
   END;

      IF ga^.cost[ntreg] > ga^.cost[ntmem]+2 THEN
      (* RULE 136/430 *)
 ga^.reg.mode := SignedLong; ;
      ga^.cost[ntreg] :=  ga^.cost[ntmem]+2;
      ga^.rule[ntreg] := 136;
   END;

      IF ga^.cost[ntRegOrCMem] > ga^.cost[ntreg] THEN
      (* RULE 269/397 *)
 ga^.RegOrCMem.mode    := e^.gcg^.reg.mode; ;
      ga^.cost[ntRegOrCMem] :=  ga^.cost[ntreg];
      ga^.rule[ntRegOrCMem] := 269;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 257/382 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 257;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg]+3 THEN
      (* RULE 241/363 *)
   IF  SizeTable[e^.gcg^.reg.mode] < 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg]+3;
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 241;
   END;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg] THEN
      (* RULE 242/357 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg];
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 242;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 257/382 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 257;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg]+3 THEN
      (* RULE 231/347 *)
   IF  SizeTable[e^.gcg^.reg.mode] < 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg]+3;
      ga^.rule[ntRegPlusSymPlusOffset] := 231;
   END;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntRegOrCMem] THEN
      (* RULE 271/409 *)
 ga^.RegOrCMemOrIm.mode    := e^.gcg^.RegOrCMem.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntRegOrCMem];
      ga^.rule[ntRegOrCMemOrIm] := 271;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg] THEN
      (* RULE 232/341 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg];
      ga^.rule[ntRegPlusSymPlusOffset] := 232;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntRegPlusSymPlusOffset] THEN
      (* RULE 258/373 *)
 ga^.mem.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= 1; ;
      ga^.cost[ntmem] :=  ga^.cost[ntRegPlusSymPlusOffset];
      ga^.rule[ntmem] := 258;
   END;

      IF ga^.cost[ntreg] > ga^.cost[ntmem]+2 THEN
      (* RULE 136/430 *)
 ga^.reg.mode := SignedLong; ;
      ga^.cost[ntreg] :=  ga^.cost[ntmem]+2;
      ga^.rule[ntreg] := 136;
   END;

      IF ga^.cost[ntRegOrCMem] > ga^.cost[ntreg] THEN
      (* RULE 269/397 *)
 ga^.RegOrCMem.mode    := e^.gcg^.reg.mode; ;
      ga^.cost[ntRegOrCMem] :=  ga^.cost[ntreg];
      ga^.rule[ntRegOrCMem] := 269;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg]+3 THEN
      (* RULE 241/363 *)
   IF  SizeTable[e^.gcg^.reg.mode] < 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg]+3;
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 241;
   END;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg] THEN
      (* RULE 242/357 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg];
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 242;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 257/382 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 257;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg]+3 THEN
      (* RULE 231/347 *)
   IF  SizeTable[e^.gcg^.reg.mode] < 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg]+3;
      ga^.rule[ntRegPlusSymPlusOffset] := 231;
   END;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg] THEN
      (* RULE 232/341 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg];
      ga^.rule[ntRegPlusSymPlusOffset] := 232;
   END;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntRegOrCMem] THEN
      (* RULE 271/409 *)
 ga^.RegOrCMemOrIm.mode    := e^.gcg^.RegOrCMem.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntRegOrCMem];
      ga^.rule[ntRegOrCMemOrIm] := 271;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntRegPlusSymPlusOffset] THEN
      (* RULE 258/373 *)
 ga^.mem.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= 1; ;
      ga^.cost[ntmem] :=  ga^.cost[ntRegPlusSymPlusOffset];
      ga^.rule[ntmem] := 258;
   END;

      IF ga^.cost[ntfreg] > ga^.cost[ntCMem]+20 THEN
      (* RULE 169/490 *)
      ga^.cost[ntfreg] :=  ga^.cost[ntCMem]+20;
      ga^.rule[ntfreg] := 169;
   END;

      IF ga^.cost[ntfstack] > ga^.cost[ntfreg]+2 THEN
      (* RULE 170/497 *)
      ga^.cost[ntfstack] :=  ga^.cost[ntfreg]+2;
      ga^.rule[ntfstack] := 170;
   END;

      IF ga^.cost[ntRegOrIm] > ga^.cost[ntreg] THEN
      (* RULE 267/391 *)
 ga^.RegOrIm.mode    := e^.gcg^.reg.mode; ;
      ga^.cost[ntRegOrIm] :=  ga^.cost[ntreg];
      ga^.rule[ntRegOrIm] := 267;
   END;

 END MatchChainRules;

 PROCEDURE MemExtend;
 VAR i : CARDINAL;
     e,le : IR.Expression;
     a,la : IR.Attributes;
     g,lg : IR.ExprAttributes;
 BEGIN 
    NEW (NextAttr); NEW (NextExpr); NEW (NextGcg);
    NextAttr^.hashchain := NIL;
    NextExpr^.hashchain := NIL;
    NextGcg^. hashchain := NIL;
    la:=NextAttr; le:=NextExpr; lg:=NextGcg;
    FOR i:=1 TO 
(******* empty insertion IpMemSize *******)
        30
    DO 
        NEW (a); a^.hashchain := NextAttr; NextAttr := a;
        NEW (e); e^.hashchain := NextExpr; NextExpr := e;
        NEW (g); g^.hashchain := NextGcg;  NextGcg  := g;
    END;
    IF FirstAttr=NIL THEN 
       FirstAttr:=NextAttr; FirstExpr:=NextExpr; FirstGcg:=NextGcg;
    ELSE
       LastAttr^.hashchain := NextAttr;
       LastExpr^.hashchain := NextExpr;
       LastGcg^.hashchain  := NextGcg;
    END;
    LastAttr:=la; LastExpr := le; LastGcg  := lg;
 END MemExtend;

 PROCEDURE  ShortCardConstant (
                      Atc  :  SHORTCARD
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShortCardConstant;
   a^.ShortCardConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 193/507 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val  := e^.attr^.ShortCardConstant.c;
	  ga^.Constant.mode := UnsignedWord; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 193;
   END;
   MatchChainRules(e);
 END ShortCardConstant;


 PROCEDURE  LongCardConstant (
                      Atc  :  LONGCARD
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongCardConstant;
   a^.LongCardConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 192/511 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := INTEGER(e^.attr^.LongCardConstant.c);
	  ga^.Constant.mode := UnsignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 192;
   END;
   MatchChainRules(e);
 END LongCardConstant;


 PROCEDURE  ShortIntConstant (
                      Atc  :  SHORTINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShortIntConstant;
   a^.ShortIntConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 191/515 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.attr^.ShortIntConstant.c;
	  ga^.Constant.mode := SignedWord; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 191;
   END;
   MatchChainRules(e);
 END ShortIntConstant;


 PROCEDURE  LongIntConstant (
                      Atc  :  LONGINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongIntConstant;
   a^.LongIntConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 190/519 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.attr^.LongIntConstant.c;
	  ga^.Constant.mode := SignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 190;
   END;
   MatchChainRules(e);
 END LongIntConstant;


 PROCEDURE  RealConstant (
                      Atc  :  REAL
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRealConstant;
   a^.RealConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 200/523 *)
   IF 0 <   ga^.cost[ntFloatConstant]  THEN 
 ga^.FloatConstant.mode := FloatShort;
	  ga^.FloatConstant.val  := e^.attr^.RealConstant.c; ;
     ga^.cost[ntFloatConstant] := 0; 
     ga^.rule[ntFloatConstant] := 200;
   END;
   MatchChainRules(e);
 END RealConstant;


 PROCEDURE  LongRealConstant (
                      Atc  :  LONGREAL
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongRealConstant;
   a^.LongRealConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 199/527 *)
   IF 0 <   ga^.cost[ntFloatConstant]  THEN 
 ga^.FloatConstant.mode := FloatLong;
	  ga^.FloatConstant.val  := e^.attr^.LongRealConstant.c; ;
     ga^.cost[ntFloatConstant] := 0; 
     ga^.rule[ntFloatConstant] := 199;
   END;
   MatchChainRules(e);
 END LongRealConstant;


 PROCEDURE  CharConstant (
                      Atc  :  CHAR
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCharConstant;
   a^.CharConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 189/531 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := ORD (e^.attr^.CharConstant.c);
	  ga^.Constant.mode := UnsignedByte; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 189;
   END;
   MatchChainRules(e);
 END CharConstant;


 PROCEDURE  BoolConstant (
                      Atval  :  BOOLEAN
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBoolConstant;
   a^.BoolConstant.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 188/535 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 IF e^.attr^.BoolConstant.val THEN ga^.Constant.val := 1; 
	                      ELSE ga^.Constant.val := 0; END;
	  ga^.Constant.mode := UnsignedByte; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 188;
   END;
   MatchChainRules(e);
 END BoolConstant;


 PROCEDURE  SetConstant (
                      Atc  :  BITSET
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetConstant;
   a^.SetConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 187/540 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := LONGINT (e^.attr^.SetConstant.c);
	  ga^.Constant.mode := UnsignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 187;
   END;
   MatchChainRules(e);
 END SetConstant;


 PROCEDURE  NilConstant (
                         VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNilConstant;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 186/544 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := LONGINT (NIL);
	  ga^.Constant.mode := UnsignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 186;
   END;
   MatchChainRules(e);
 END NilConstant;


 PROCEDURE  ProcedureConstant (
                      Atindex  :  CgBase.ProcIndex
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opProcedureConstant;
   a^.ProcedureConstant.index := Atindex;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 218/548 *)
   IF 0 <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= 0; ;
     ga^.cost[ntSymPlusOffset] := 0; 
     ga^.rule[ntSymPlusOffset] := 218;
   END;
   MatchChainRules(e);
 END ProcedureConstant;


 PROCEDURE  StringAddr (
                      Atindex  :  CgBase.StringIndex
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opStringAddr;
   a^.StringAddr.index := Atindex;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 217/552 *)
   IF 0 <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= 0; ;
     ga^.cost[ntSymPlusOffset] := 0; 
     ga^.rule[ntSymPlusOffset] := 217;
   END;
   MatchChainRules(e);
 END StringAddr;


 PROCEDURE  LocalVariable (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLocalVariable;
   a^.LocalVariable.offset := Atoffset;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 211/559 *)
   IF 0 <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base.offset  := e^.attr^.LocalVariable.offset;
	  ga^.SimpleVariable.base.base	   := Regebp;
	  ga^.SimpleVariable.base.symbol  := NullSymb;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 0;
	  ga^.SimpleVariable.index.offset := 0;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := NullSymb;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := 0; 
     ga^.rule[ntSimpleVariable] := 211;
   END;
     (* RULE 230/571 *)
   IF 0 <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.attr^.LocalVariable.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := 0; 
     ga^.rule[ntRegPlusSymPlusOffset] := 230;
   END;
   MatchChainRules(e);
 END LocalVariable;


 PROCEDURE  GlobalVariable (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
 END GlobalVariable;


 PROCEDURE  StaticVariable (
                      Atmodule  :  CgBase.ModuleIndex;
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opStaticVariable;
   a^.StaticVariable.module := Atmodule;
   a^.StaticVariable.offset := Atoffset;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 210/579 *)
   IF 0 <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base.offset  := e^.attr^.StaticVariable.offset;
	  ga^.SimpleVariable.base.base	   := RegNil;
	  ga^.SimpleVariable.base.symbol  := e^.attr^.StaticVariable.module^.Statics;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 0;
	  ga^.SimpleVariable.index.offset := 0;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := NullSymb;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := 0; 
     ga^.rule[ntSimpleVariable] := 210;
   END;
     (* RULE 216/591 *)
   IF 0 <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.attr^.StaticVariable.offset; ;
     ga^.cost[ntSymPlusOffset] := 0; 
     ga^.rule[ntSymPlusOffset] := 216;
   END;
   MatchChainRules(e);
 END StaticVariable;


 PROCEDURE  LocalValueParam (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Atoffset, result);
 END LocalValueParam;


 PROCEDURE  LocalVarParam (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Atoffset, result);
      Content   (SignedLong, result, result)
 END LocalVarParam;


 PROCEDURE  LocalOpenArrayValueParam (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Atoffset, result);
      Content   (SignedLong, result, result)
 END LocalOpenArrayValueParam;


 PROCEDURE  GlobalValueParam (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
 END GlobalValueParam;


 PROCEDURE  GlobalVarParam (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
      Content   (SignedLong, result, result)
 END GlobalVarParam;


 PROCEDURE  GlobalOpenArrayValueParam (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
      Content   (SignedLong, result, result)
 END GlobalOpenArrayValueParam;


 PROCEDURE  UsePointer (
                         op1  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 result := op1 
 END UsePointer;


 PROCEDURE  FrameBase (
                      Atproc  :  CgBase.ProcIndex;
                      Atlevel  :  SHORTCARD
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFrameBase;
   a^.FrameBase.proc := Atproc;
   a^.FrameBase.level := Atlevel;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 134/620 *)
   IF 0 <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FrameBase.level = CurLevel  THEN 
 ga^.reg.mode := SignedLong; ;
     ga^.cost[ntreg] := 0; 
     ga^.rule[ntreg] := 134;
   END;
   END;
     (* RULE 263/624 *)
   IF 0 <   ga^.cost[ntCMem]  THEN 
   IF  e^.attr^.FrameBase.level < CurLevel  THEN 
 ga^.CMem.mode	:= SignedLong; ;
     ga^.cost[ntCMem] := 0; 
     ga^.rule[ntCMem] := 263;
   END;
   END;
   MatchChainRules(e);
 END FrameBase;


 PROCEDURE  ParamBase (
                      Atproc  :  CgBase.ProcIndex;
                      Atlevel  :  SHORTCARD
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
FrameBase (Atproc, Atlevel, result);
 END ParamBase;


 PROCEDURE  AddOffset (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 LongIntConstant (Atoffset, result);
       FixedPlus (SignedLong, op1, result, result); 
 END AddOffset;


 PROCEDURE  Subscript (
                      AtIndexMode  :  CgBase.Mode;
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode;
                      AtElemSize  :  LONGCARD
                      ;  op1  : Address
                      ;  op2  : Data
                      ;  op3  : Address
                      ;  op4  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
	       
     (* op1 = Base, op2 = Index, op3 = Lwb, op4 = Upb *)
	   Coerce (AtIndexMode, UnsignedLong, op2, op2);
	   LongCardConstant (AtElemSize, result);
	 FixedMult (UnsignedLong,  op2, result, result); 
       AddAddr (op1, result, result);
       e:=op3;
     AddOffset (-INTEGER(AtElemSize)*e^.gcg^.Constant.val, result, result);
		      (* op3 is known to be constant *) 
 END Subscript;


 PROCEDURE  AddAddr (
                         op1  : Address
                      ;  op2  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FixedPlus (UnsignedLong, op1, op2, result); 
 END AddAddr;


 PROCEDURE  SelectField (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
 END SelectField;


 PROCEDURE  AssignDataTempo (
                      Atmode  :  CgBase.Mode;
                      Attempo  :  CgBase.DataTempo
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Attempo, optemp); Assign (Atmode, optemp, op1);
 END AssignDataTempo;


 PROCEDURE  AssignAddressTempo (
                      Attempo  :  CgBase.AddressTempo
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AssignDataTempo (SignedLong, Attempo, op1)
 END AssignAddressTempo;


 PROCEDURE  UseDataTempo (
                      Atmode  :  CgBase.Mode;
                      Attempo  :  CgBase.DataTempo
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Attempo, result); Content (Atmode, result, result);
 END UseDataTempo;


 PROCEDURE  UseAddressTempo (
                      Attempo  :  CgBase.AddressTempo
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
UseDataTempo (SignedLong, Attempo, result);
 END UseAddressTempo;


 PROCEDURE  Content (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opContent;
   a^.Content.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 262/689 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntCMem]  THEN 
 ga^.CMem.mode := e^.attr^.Content.mode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 262;
   END;
   MatchChainRules(e);
 END Content;


 PROCEDURE  Assign (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAssign;
   a^.Assign.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 1/696 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode < FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 1;
   END;
   END;
     (* RULE 2/701 *)
    c:=  45+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode >= FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 2;
   END;
   END;
     (* RULE 3/709 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode = FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 3;
   END;
   END;
     (* RULE 4/717 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode = FloatLong  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 4;
   END;
   END;
     (* RULE 5/727 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.Assign.mode = FloatShort) AND (e^.son[2]^.gcg^.CMem.mode = FloatShort)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 5;
   END;
   END;
     (* RULE 6/736 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.Assign.mode = FloatLong) AND (e^.son[2]^.gcg^.CMem.mode = FloatLong)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 6;
   END;
   END;
     (* RULE 7/749 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 7;
   END;
   END;
   END;
     (* RULE 18/999 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[1]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 18;
   END;
   END;
   END;
   END;
     (* RULE 19/999 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[2]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 19;
   END;
   END;
   END;
   END;
     (* RULE 20/1013 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 20;
   END;
   END;
   END;
   END;
     (* RULE 21/1013 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 21;
   END;
   END;
   END;
   END;
     (* RULE 22/1026 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  c+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 22;
   END;
   END;
   END;
   END;
   END;
     (* RULE 23/1096 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMinus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[2]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 23;
   END;
   END;
   END;
   END;
     (* RULE 24/1110 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMinus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 24;
   END;
   END;
   END;
   END;
     (* RULE 25/1145 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[1]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 25;
   END;
   END;
   END;
   END;
     (* RULE 26/1145 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[2]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 26;
   END;
   END;
   END;
   END;
     (* RULE 27/1214 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (NOT SignedTable [e^.attr^.Assign.mode] OR (e^.son[2]^.son[1]^.gcg^.Constant.val > 0)) AND
	  IsPowerOfTwo (e^.son[2]^.son[1]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[1]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 27;
   END;
   END;
   END;
   END;
     (* RULE 28/1214 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (NOT SignedTable [e^.attr^.Assign.mode] OR (e^.son[2]^.son[2]^.gcg^.Constant.val > 0)) AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[2]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 28;
   END;
   END;
   END;
   END;
     (* RULE 29/1300 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  14+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  c+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 29;
   END;
   END;
   END;
   END;
   END;
     (* RULE 30/1373 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedDiv THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (NOT SignedTable [e^.attr^.Assign.mode]) AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[2]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 30;
   END;
   END;
   END;
   END;
     (* RULE 31/1396 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedDiv THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  SignedTable [e^.attr^.Assign.mode] AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[2]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 31;
   END;
   END;
   END;
   END;
     (* RULE 32/1467 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMod THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) & (NOT SignedTable[e^.attr^.Assign.mode])  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 32;
   END;
   END;
   END;
   END;
     (* RULE 33/1596 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetUnion THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 33;
   END;
   END;
   END;
   END;
     (* RULE 34/1596 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetUnion THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 34;
   END;
   END;
   END;
   END;
     (* RULE 35/1626 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetDifference THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntreg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 35;
   END;
   END;
   END;
   END;
     (* RULE 36/1640 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetDifference THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  3+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 36;
   END;
   END;
   END;
   END;
     (* RULE 37/1659 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetIntersection THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 37;
   END;
   END;
   END;
   END;
     (* RULE 38/1659 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetIntersection THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 38;
   END;
   END;
   END;
   END;
     (* RULE 39/1678 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetSymDifference THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 39;
   END;
   END;
   END;
   END;
     (* RULE 40/1678 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetSymDifference THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 40;
   END;
   END;
   END;
   END;
     (* RULE 41/1804 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opTrunc THEN 
    c:=  90+     e2^.son[1]^.gcg^.cost[ntfreg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 41;
   END;
   END;
     (* RULE 60/2791 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFunctionCall THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opPass THEN 
   IF e3^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e3^.son[2]^.gcg^.cost[ntfreg];
   IF e2^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  c+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entier') OR
	 StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entierL') OR
	 StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_entier') OR
	 StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_entierL')  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 60;
   END;
   END;
   END;
   END;
   END;
   END;
     (* RULE 61/2831 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFunctionCall THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opPass THEN 
   IF e3^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e3^.son[2]^.gcg^.cost[ntfreg];
   IF e2^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  c+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LTRUNC') OR
         StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'LTRUNC')  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 61;
   END;
   END;
   END;
   END;
   END;
   END;
   Emit.EmitInstruction (e);
 END Assign;


 PROCEDURE  AssignLong (
                      Atsize  :  LONGINT
                      ;  op1  : Address
                      ;  op2  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAssignLong;
   a^.AssignLong.size := Atsize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 8/773 *)
    c:=  20+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.AssignLong.size >= 4)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 8;
   END;
   END;
     (* RULE 9/807 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.AssignLong.size <= 8  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 9;
   END;
   END;
   Emit.EmitInstruction (e);
 END AssignLong;


 PROCEDURE  Inc1 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opInc1;
   a^.Inc1.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 10/838 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 10;
   END;
   Emit.EmitInstruction (e);
 END Inc1;


 PROCEDURE  Inc2 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opInc2;
   a^.Inc2.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 12/846 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 12;
   END;
   Emit.EmitInstruction (e);
 END Inc2;


 PROCEDURE  Dec1 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opDec1;
   a^.Dec1.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 11/842 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 11;
   END;
   Emit.EmitInstruction (e);
 END Dec1;


 PROCEDURE  Dec2 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opDec2;
   a^.Dec2.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 13/850 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 13;
   END;
   Emit.EmitInstruction (e);
 END Dec2;


 PROCEDURE  Incl (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (Atmode, UnsignedLong, op2, op2);
    InclL (op1, op2); 
 END Incl;


 PROCEDURE  Excl (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (Atmode, UnsignedLong, op2, op2);
    ExclL (op1, op2); 
 END Excl;


 PROCEDURE  InclL (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opInclL;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 14/865 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 14;
   END;
   Emit.EmitInstruction (e);
 END InclL;


 PROCEDURE  ExclL (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opExclL;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 15/882 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 15;
   END;
   Emit.EmitInstruction (e);
 END ExclL;


 PROCEDURE  SkipAddress (
                         op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSkipAddress;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 16/889 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 16;
   END;
   Emit.EmitInstruction (e);
 END SkipAddress;


 PROCEDURE  SkipData (
                         op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSkipData;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 17/892 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 17;
   END;
   Emit.EmitInstruction (e);
 END SkipData;


 PROCEDURE  FixedNegate (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedNegate;
   a^.FixedNegate.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 185/898 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := -e^.son[1]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 185;
   END;
     (* RULE 133/902 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedNegate.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 133;
   END;
   MatchChainRules(e);
 END FixedNegate;


 PROCEDURE  FixedPlus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedPlus;
   a^.FixedPlus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 209/634 *)
   IF e^.son[2]^.attr^.op = opFrameBase THEN 
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  e^.son[2]^.attr^.FrameBase.level < CurLevel  THEN 
 ga^.SimpleVariable.base.offset  := e^.son[1]^.gcg^.Constant.val;
	  ga^.SimpleVariable.base.base	   := RegNil;
	  ga^.SimpleVariable.base.symbol  := NullSymb;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 1;
	  ga^.SimpleVariable.index.offset := 4*e^.son[2]^.attr^.FrameBase.level;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := DisplaySym;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 209;
   END;
   END;
   END;
     (* RULE 208/634 *)
   IF e^.son[1]^.attr^.op = opFrameBase THEN 
    c:=       e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  e^.son[1]^.attr^.FrameBase.level < CurLevel  THEN 
 ga^.SimpleVariable.base.offset  := e^.son[2]^.gcg^.Constant.val;
	  ga^.SimpleVariable.base.base	   := RegNil;
	  ga^.SimpleVariable.base.symbol  := NullSymb;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 1;
	  ga^.SimpleVariable.index.offset := 4*e^.son[1]^.attr^.FrameBase.level;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := DisplaySym;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 208;
   END;
   END;
   END;
     (* RULE 183/935 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val + e^.son[2]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 183;
   END;
     (* RULE 215/939 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[2]^.gcg^.SymPlusOffset.offset + e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 215;
   END;
     (* RULE 214/939 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset + e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 214;
   END;
     (* RULE 229/943 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  SizeTable[e^.son[1]^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[2]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 229;
   END;
   END;
     (* RULE 228/943 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  SizeTable[e^.son[2]^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 228;
   END;
   END;
     (* RULE 227/949 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  SizeTable[e^.son[1]^.gcg^.reg.mode] < 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[2]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 227;
   END;
   END;
     (* RULE 226/949 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  SizeTable[e^.son[2]^.gcg^.reg.mode] < 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 226;
   END;
   END;
     (* RULE 225/959 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegPlusSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset + e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 225;
   END;
     (* RULE 224/959 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset + e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 224;
   END;
     (* RULE 240/964 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 240;
   END;
     (* RULE 239/964 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 239;
   END;
     (* RULE 256/970 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 256;
   END;
     (* RULE 255/970 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntRegPlusSymPlusOffset];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 255;
   END;
     (* RULE 254/979 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[2]^.gcg^.mem.offset + e^.son[1]^.gcg^.Constant.val;
	  ga^.mem.faktor	:= e^.son[2]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 254;
   END;
     (* RULE 253/979 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.mem.offset + e^.son[2]^.gcg^.Constant.val;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 253;
   END;
     (* RULE 207/988 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base	    := e^.son[2]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[2]^.gcg^.SimpleVariable.index;
	  ga^.SimpleVariable.base.offset  := e^.son[2]^.gcg^.SimpleVariable.base.offset + e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 207;
   END;
     (* RULE 206/988 *)
    c:=       e^.son[1]^.gcg^.cost[ntSimpleVariable]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.gcg^.SimpleVariable.index;
	  ga^.SimpleVariable.base.offset  := e^.son[1]^.gcg^.SimpleVariable.base.offset + e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 206;
   END;
     (* RULE 131/993 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedPlus.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 131;
   END;
     (* RULE 130/993 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedPlus.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 130;
   END;
     (* RULE 204/1190 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[2]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[2]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[1]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[1]^.son[2]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[1]^.son[2]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[1]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[1]^.son[1]^.gcg^.Constant.val = 1) OR (e^.son[1]^.son[1]^.gcg^.Constant.val = 2) OR (e^.son[1]^.son[1]^.gcg^.Constant.val = 4) OR (e^.son[1]^.son[1]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[2]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[1]^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 204;
   END;
   END;
   END;
   END;
   END;
     (* RULE 203/1190 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[2]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[2]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[1]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[1]^.son[1]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[1]^.son[1]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[1]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[1]^.son[2]^.gcg^.Constant.val = 1) OR (e^.son[1]^.son[2]^.gcg^.Constant.val = 2) OR (e^.son[1]^.son[2]^.gcg^.Constant.val = 4) OR (e^.son[1]^.son[2]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[2]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[1]^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 203;
   END;
   END;
   END;
   END;
   END;
     (* RULE 202/1190 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[1]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[2]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[2]^.son[2]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[2]^.son[2]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[2]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[2]^.son[1]^.gcg^.Constant.val = 1) OR (e^.son[2]^.son[1]^.gcg^.Constant.val = 2) OR (e^.son[2]^.son[1]^.gcg^.Constant.val = 4) OR (e^.son[2]^.son[1]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[2]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[2]^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 202;
   END;
   END;
   END;
   END;
   END;
     (* RULE 201/1190 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[1]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[2]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[2]^.son[1]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[2]^.son[1]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[2]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[2]^.son[2]^.gcg^.Constant.val = 1) OR (e^.son[2]^.son[2]^.gcg^.Constant.val = 2) OR (e^.son[2]^.son[2]^.gcg^.Constant.val = 4) OR (e^.son[2]^.son[2]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[2]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[2]^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 201;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END FixedPlus;


 PROCEDURE  FixedMinus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedMinus;
   a^.FixedMinus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 182/1041 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val - e^.son[2]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 182;
   END;
     (* RULE 213/1045 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 213;
   END;
     (* RULE 223/1049 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  (SizeTable[e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > MIN(LONGINT))  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 223;
   END;
   END;
     (* RULE 222/1055 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  SizeTable[e^.son[1]^.gcg^.reg.mode] < 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 222;
   END;
   END;
     (* RULE 221/1065 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 221;
   END;
     (* RULE 238/1070 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset - e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 238;
   END;
     (* RULE 252/1076 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.mem.offset - e^.son[2]^.gcg^.Constant.val;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 252;
   END;
     (* RULE 205/1085 *)
    c:=       e^.son[1]^.gcg^.cost[ntSimpleVariable]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.gcg^.SimpleVariable.index;
	  ga^.SimpleVariable.base.offset  := e^.son[1]^.gcg^.SimpleVariable.base.offset - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 205;
   END;
     (* RULE 129/1090 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMinus.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 129;
   END;
     (* RULE 181/1123 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opContent THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[2]^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[2]^.son[1]^.gcg^.SimpleVariable.index)  THEN 
 ga^.Constant.val := 0;
	  ga^.Constant.mode := e^.attr^.FixedMinus.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 181;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END FixedMinus;


 PROCEDURE  FixedMult (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedMult;
   a^.FixedMult.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 180/1131 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val * e^.son[2]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 180;
   END;
     (* RULE 179/1135 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 0  THEN 
 ga^.Constant.mode := e^.attr^.FixedMult.mode;
	  ga^.Constant.val  := 0; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 179;
   END;
   END;
     (* RULE 178/1135 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 0  THEN 
 ga^.Constant.mode := e^.attr^.FixedMult.mode;
	  ga^.Constant.val  := 0; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 178;
   END;
   END;
     (* RULE 128/1140 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 1  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 128;
   END;
   END;
     (* RULE 127/1140 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 1  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 127;
   END;
   END;
     (* RULE 126/1153 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 2  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 126;
   END;
   END;
     (* RULE 125/1153 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 2  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 125;
   END;
   END;
     (* RULE 124/1160 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 4  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 124;
   END;
   END;
     (* RULE 123/1160 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 4  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 123;
   END;
   END;
     (* RULE 237/1170 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[1]^.gcg^.Constant.val <= 8) AND
	 ((e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=0) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=1) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=2) OR
	  (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=4) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=8))  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 237;
   END;
   END;
     (* RULE 236/1170 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[2]^.gcg^.Constant.val <= 8) AND
	 ((e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=0) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=1) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=2) OR
	  (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=4) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=8))  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 236;
   END;
   END;
     (* RULE 251/1179 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[1]^.gcg^.Constant.val <= 9) AND
	 ((e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=3) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=5) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=9))  THEN 
 ga^.mem.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val - 1;
	  ga^.mem.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 251;
   END;
   END;
     (* RULE 250/1179 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[2]^.gcg^.Constant.val <= 9) AND
	 ((e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=3) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=5) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=9))  THEN 
 ga^.mem.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val - 1;
	  ga^.mem.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 250;
   END;
   END;
     (* RULE 122/1206 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (NOT SignedTable [e^.attr^.FixedMult.mode] OR (e^.son[1]^.gcg^.Constant.val > 0)) AND
	      IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val) AND (Log2(e^.son[1]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 122;
   END;
   END;
     (* RULE 121/1206 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (NOT SignedTable [e^.attr^.FixedMult.mode] OR (e^.son[2]^.gcg^.Constant.val > 0)) AND
	      IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 121;
   END;
   END;
     (* RULE 249/1229 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[2]^.gcg^.reg.mode] = 4) AND (e^.son[1]^.gcg^.Constant.val > 1) AND
	 (e^.son[1]^.gcg^.Constant.val MOD 3 = 0) AND IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val DIV 3)  THEN 
 ga^.mem.faktor := 2;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 249;
   END;
   END;
     (* RULE 248/1229 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > 1) AND
	 (e^.son[2]^.gcg^.Constant.val MOD 3 = 0) AND IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val DIV 3)  THEN 
 ga^.mem.faktor := 2;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 248;
   END;
   END;
     (* RULE 247/1244 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[2]^.gcg^.reg.mode] = 4) AND (e^.son[1]^.gcg^.Constant.val > 1) AND
	 (e^.son[1]^.gcg^.Constant.val MOD 5 = 0) AND IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val DIV 5)  THEN 
 ga^.mem.faktor := 4;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 247;
   END;
   END;
     (* RULE 246/1244 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > 1) AND
	 (e^.son[2]^.gcg^.Constant.val MOD 5 = 0) AND IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val DIV 5)  THEN 
 ga^.mem.faktor := 4;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 246;
   END;
   END;
     (* RULE 245/1259 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[2]^.gcg^.reg.mode] = 4) AND (e^.son[1]^.gcg^.Constant.val > 1) AND
	 (e^.son[1]^.gcg^.Constant.val MOD 9 = 0) AND IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val DIV 9)  THEN 
 ga^.mem.faktor := 8;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 245;
   END;
   END;
     (* RULE 244/1259 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > 1) AND
	 (e^.son[2]^.gcg^.Constant.val MOD 9 = 0) AND IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val DIV 9)  THEN 
 ga^.mem.faktor := 8;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 244;
   END;
   END;
     (* RULE 120/1274 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 120;
   END;
     (* RULE 119/1274 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 119;
   END;
     (* RULE 118/1281 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntRegOrCMem]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 118;
   END;
     (* RULE 117/1281 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 117;
   END;
     (* RULE 116/1287 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opContent THEN 
    c:=  13+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[2]^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[2]^.son[1]^.gcg^.SimpleVariable.index)  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 116;
   END;
   END;
   END;
   END;
     (* RULE 115/1317 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  NOT SignedTable [e^.attr^.FixedMult.mode]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 115;
   END;
   END;
   MatchChainRules(e);
 END FixedMult;


 PROCEDURE  FixedDiv (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedDiv;
   a^.FixedDiv.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 177/1338 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 IF e^.son[2]^.gcg^.Constant.val = 0 THEN ERROR ("DIV by 0", CurPos);
		      ELSE ga^.Constant.val := e^.son[1]^.gcg^.Constant.val DIV e^.son[2]^.gcg^.Constant.val END;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 177;
   END;
     (* RULE 114/1343 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 0  THEN 
 ERROR ("DIV by 0", CurPos);
	  ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 114;
   END;
   END;
     (* RULE 113/1349 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 1  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 113;
   END;
   END;
     (* RULE 235/1354 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor > 0) AND (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND
         (e^.son[2]^.gcg^.Constant.val <= 8) AND (e^.son[2]^.gcg^.Constant.val <> 0) AND
         (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor MOD e^.son[2]^.gcg^.Constant.val = 0) AND (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset MOD e^.son[2]^.gcg^.Constant.val = 0) AND
	 ((e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 1) OR (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 2) OR
	  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 4) OR (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 8))  THEN 
 ga^.OffsetPlusIndexMultFaktor.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset DIV e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 235;
   END;
   END;
     (* RULE 112/1365 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (NOT SignedTable [e^.attr^.FixedDiv.mode]) AND
	 IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) AND (Log2 (e^.son[2]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 112;
   END;
   END;
     (* RULE 111/1388 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (SignedTable [e^.attr^.FixedDiv.mode]) AND
	 IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) AND (Log2 (e^.son[2]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 111;
   END;
   END;
     (* RULE 176/1411 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opContent THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[2]^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[2]^.son[1]^.gcg^.SimpleVariable.index)  THEN 
 ga^.Constant.val := 1;
	  ga^.Constant.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 176;
   END;
   END;
   END;
   END;
     (* RULE 110/1419 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedDiv.mode = SignedLong  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 110;
   END;
   END;
     (* RULE 109/1431 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.FixedDiv.mode = UnsignedLong) OR (e^.attr^.FixedDiv.mode = UnsignedWord)  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 109;
   END;
   END;
     (* RULE 108/1443 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedDiv.mode = SignedWord  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 108;
   END;
   END;
   MatchChainRules(e);
 END FixedDiv;


 PROCEDURE  FixedMod (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedMod;
   a^.FixedMod.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 175/1455 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 IF e^.son[2]^.gcg^.Constant.val = 0 THEN ERROR ("MOD by 0", CurPos);
		      ELSE ga^.Constant.val := e^.son[1]^.gcg^.Constant.val MOD e^.son[2]^.gcg^.Constant.val END;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 175;
   END;
     (* RULE 107/1460 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) & (NOT SignedTable[e^.attr^.FixedMod.mode])  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 107;
   END;
   END;
     (* RULE 106/1481 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedMod.mode = SignedLong  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 106;
   END;
   END;
     (* RULE 105/1492 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.FixedMod.mode = UnsignedLong) OR (e^.attr^.FixedMod.mode = UnsignedWord)  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 105;
   END;
   END;
     (* RULE 104/1503 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedMod.mode = SignedWord  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 104;
   END;
   END;
   MatchChainRules(e);
 END FixedMod;


 PROCEDURE  FixedAbs (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedAbs;
   a^.FixedAbs.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 184/910 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 IF e^.son[1]^.gcg^.Constant.val < 0 THEN
	    IF e^.son[1]^.gcg^.Constant.val = MIN(LONGINT) THEN
	      ERROR ("ABS with this argument would raise overflow", CurPos);
	    ELSE
	      ga^.Constant.val := -e^.son[1]^.gcg^.Constant.val;
	    END;
	  ELSE
	    ga^.Constant.val := e^.son[1]^.gcg^.Constant.val
	  END;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 184;
   END;
     (* RULE 132/922 *)
    c:=  11+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  SignedTable[e^.attr^.FixedAbs.mode]  THEN 
 ga^.reg.mode := e^.attr^.FixedAbs.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 132;
   END;
   END;
   MatchChainRules(e);
 END FixedAbs;


 PROCEDURE  FloatNegate (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatNegate;
   a^.FloatNegate.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 168/1517 *)
    c:=  24+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 168;
   END;
   MatchChainRules(e);
 END FloatNegate;


 PROCEDURE  FloatPlus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatPlus;
   a^.FloatPlus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 167/1522 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 167;
   END;
     (* RULE 166/1522 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 166;
   END;
     (* RULE 165/1527 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 165;
   END;
     (* RULE 164/1527 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 164;
   END;
   MatchChainRules(e);
 END FloatPlus;


 PROCEDURE  FloatMinus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatMinus;
   a^.FloatMinus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 163/1532 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 163;
   END;
     (* RULE 162/1537 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 162;
   END;
     (* RULE 161/1542 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 161;
   END;
     (* RULE 160/1547 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 160;
   END;
   MatchChainRules(e);
 END FloatMinus;


 PROCEDURE  FloatMult (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatMult;
   a^.FloatMult.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 159/1552 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 159;
   END;
     (* RULE 158/1552 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 158;
   END;
     (* RULE 157/1557 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 157;
   END;
     (* RULE 156/1557 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 156;
   END;
   MatchChainRules(e);
 END FloatMult;


 PROCEDURE  FloatDiv (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatDiv;
   a^.FloatDiv.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 155/1562 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 155;
   END;
     (* RULE 154/1567 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 154;
   END;
     (* RULE 153/1572 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 153;
   END;
     (* RULE 152/1577 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 152;
   END;
   MatchChainRules(e);
 END FloatDiv;


 PROCEDURE  FloatAbs (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatAbs;
   a^.FloatAbs.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 151/1582 *)
    c:=  22+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 151;
   END;
   MatchChainRules(e);
 END FloatAbs;


 PROCEDURE  SetUnion (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetUnion;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 103/1590 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 103;
   END;
     (* RULE 102/1590 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 102;
   END;
   MatchChainRules(e);
 END SetUnion;


 PROCEDURE  SetDifference (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetDifference;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 101/1609 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 101;
   END;
     (* RULE 100/1618 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 100;
   END;
   MatchChainRules(e);
 END SetDifference;


 PROCEDURE  SetIntersection (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetIntersection;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 99/1653 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 99;
   END;
     (* RULE 98/1653 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 98;
   END;
   MatchChainRules(e);
 END SetIntersection;


 PROCEDURE  SetSymDifference (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetSymDifference;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 97/1672 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 97;
   END;
     (* RULE 96/1672 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 96;
   END;
   MatchChainRules(e);
 END SetSymDifference;


 PROCEDURE  SetPlusSingle (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (Atmode, UnsignedLong, op2, op2);
    SetPlusSingleL (op1, op2, result); 
 END SetPlusSingle;


 PROCEDURE  SetPlusSingleL (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetPlusSingleL;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 95/1695 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 95;
   END;
     (* RULE 94/1701 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 94;
   END;
   MatchChainRules(e);
 END SetPlusSingleL;


 PROCEDURE  SetPlusRange (
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetPlusRange;
   a^.SetPlusRange.LwbMode := AtLwbMode;
   a^.SetPlusRange.UpbMode := AtUpbMode;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 93/1707 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 93;
   END;
     (* RULE 92/1713 *)
    c:=  25+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[3]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 92;
   END;
   MatchChainRules(e);
 END SetPlusRange;


 PROCEDURE  Cap (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCap;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 91/1735 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 91;
   END;
   MatchChainRules(e);
 END Cap;


 PROCEDURE  Float (
                         op1  : Data
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloat;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 150/1748 *)
    c:=  60+     e^.son[1]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 150;
   END;
     (* RULE 149/1760 *)
    c:=  64+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 149;
   END;
     (* RULE 198/1774 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntFloatConstant]  THEN 
 ga^.FloatConstant.mode := FloatShort;
	  ga^.FloatConstant.val  := FLOAT(CARDINAL(e^.son[1]^.gcg^.Constant.val)); ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 198;
   END;
   MatchChainRules(e);
 END Float;


 PROCEDURE  Trunc (
                      Atopmode  :  CgBase.Mode;
                      Atresultmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTrunc;
   a^.Trunc.opmode := Atopmode;
   a^.Trunc.resultmode := Atresultmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 174/1778 *)
    c:=       e^.son[1]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (e^.son[1]^.gcg^.FloatConstant.val <= FloatMaxCardinal) AND
	  (e^.son[1]^.gcg^.FloatConstant.val >= LFLOAT(MIN(CARDINAL)))  THEN 
 ga^.Constant.mode := UnsignedLong;
	  r := e^.son[1]^.gcg^.FloatConstant.val;
	  ga^.Constant.val  := INTEGER(TRUNC(r)); ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 174;
   END;
   END;
     (* RULE 90/1785 *)
    c:=  94+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedLong; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 90;
   END;
   MatchChainRules(e);
 END Trunc;


 PROCEDURE  Adr (
                         op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 result := op1 
 END Adr;


 PROCEDURE  Coerce (
                      Atpremode  :  CgBase.Mode;
                      Atpostmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCoerce;
   a^.Coerce.premode := Atpremode;
   a^.Coerce.postmode := Atpostmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 173/1823 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort)  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 173;
   END;
   END;
     (* RULE 212/1828 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 212;
   END;
   END;
     (* RULE 220/1834 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 220;
   END;
   END;
     (* RULE 234/1841 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 234;
   END;
   END;
     (* RULE 243/1848 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.mem.offset;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 243;
   END;
   END;
     (* RULE 261/1859 *)
    c:=       e^.son[1]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntCMem]  THEN 
   IF  (SizeTable[e^.attr^.Coerce.premode] = SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.CMem.mode	:= e^.attr^.Coerce.postmode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 261;
   END;
   END;
     (* RULE 89/1868 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] < SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.reg.mode := e^.attr^.Coerce.postmode ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 89;
   END;
   END;
     (* RULE 88/1881 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.son[1]^.gcg^.reg.mode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.son[1]^.gcg^.reg.mode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.reg.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 88;
   END;
   END;
     (* RULE 197/1887 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode >= FloatShort)  THEN 
 ga^.FloatConstant.val := REAL(e^.son[1]^.gcg^.Constant.val);
	  ga^.FloatConstant.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 197;
   END;
   END;
     (* RULE 196/1892 *)
    c:=       e^.son[1]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  (e^.attr^.Coerce.premode = FloatShort) AND (e^.attr^.Coerce.postmode = FloatLong)  THEN 
 ga^.FloatConstant.val := e^.son[1]^.gcg^.FloatConstant.val;
	  ga^.FloatConstant.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 196;
   END;
   END;
     (* RULE 148/1897 *)
    c:=       e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  (e^.attr^.Coerce.premode >= FloatShort) AND (e^.attr^.Coerce.postmode >= FloatShort)  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 148;
   END;
   END;
     (* RULE 260/1901 *)
    c:=  45+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntCMem]  THEN 
   IF  (e^.attr^.Coerce.premode = FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort)  THEN 
 ga^.CMem.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 260;
   END;
   END;
     (* RULE 259/1917 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.cost[ntCMem]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode = FloatShort)  THEN 
 ga^.CMem.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 259;
   END;
   END;
   MatchChainRules(e);
 END Coerce;


 PROCEDURE  Check (
                      AtIndexMode  :  CgBase.Mode;
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode;
                      AtCheckLwb  :  BOOLEAN;
                      AtCheckUpb  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 IF SizeTable[AtIndexMode] = 1
         THEN Coerce (AtIndexMode, SignedLong, op1, op1);
	      AtIndexMode := SignedLong;
       END;
       CheckL (AtIndexMode, AtLwbMode, AtUpbMode, AtCheckLwb, AtCheckUpb,
	       op1, op2, op3, result);
     
 END Check;


 PROCEDURE  CheckL (
                      AtIndexMode  :  CgBase.Mode;
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode;
                      AtCheckLwb  :  BOOLEAN;
                      AtCheckUpb  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCheckL;
   a^.CheckL.IndexMode := AtIndexMode;
   a^.CheckL.LwbMode := AtLwbMode;
   a^.CheckL.UpbMode := AtUpbMode;
   a^.CheckL.CheckLwb := AtCheckLwb;
   a^.CheckL.CheckUpb := AtCheckUpb;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 87/1941 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.son[2]^.gcg^.Constant.val = 0) AND (e^.son[3]^.gcg^.Constant.val = -1)  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 87;
   END;
   END;
     (* RULE 86/1946 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (SignedTable[e^.attr^.CheckL.LwbMode] OR
	  ((e^.attr^.CheckL.LwbMode <= UnsignedWord) AND (e^.son[2]^.gcg^.Constant.val <= MAX(SHORTINT))) OR
	  ((e^.attr^.CheckL.LwbMode  = UnsignedLong) AND (e^.son[2]^.gcg^.Constant.val < 0))) AND
	 (SignedTable[e^.attr^.CheckL.UpbMode] OR
	  ((e^.attr^.CheckL.UpbMode <= UnsignedWord) AND (e^.son[3]^.gcg^.Constant.val <= MAX(SHORTINT))) OR
	  ((e^.attr^.CheckL.UpbMode  = UnsignedLong) AND (e^.son[3]^.gcg^.Constant.val < 0))) AND
         (SizeTable[e^.son[1]^.gcg^.reg.mode] > 1)   THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 86;
   END;
   END;
     (* RULE 85/1974 *)
    c:=  16+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[3]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  SignedTable[e^.attr^.CheckL.LwbMode] AND SignedTable[e^.attr^.CheckL.UpbMode] AND
         (SizeTable[e^.son[1]^.gcg^.reg.mode] > 1)   THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 85;
   END;
   END;
     (* RULE 84/1987 *)
    c:=  20+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[3]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.CheckL.LwbMode < FloatShort) AND (e^.attr^.CheckL.UpbMode < FloatShort)  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 84;
   END;
   END;
     (* RULE 147/2010 *)
    c:=  50+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem]+
     e^.son[3]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  e^.attr^.CheckL.IndexMode >= FloatShort  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 147;
   END;
   END;
   MatchChainRules(e);
 END CheckL;


 PROCEDURE  FixedCompare (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedCompare;
   a^.FixedCompare.mode := Atmode;
   a^.FixedCompare.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 83/2039 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 83;
   END;
     (* RULE 82/2047 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 82;
   END;
     (* RULE 81/2055 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 81;
   END;
   MatchChainRules(e);
 END FixedCompare;


 PROCEDURE  FloatCompare (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatCompare;
   a^.FloatCompare.mode := Atmode;
   a^.FloatCompare.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 80/2063 *)
    c:=  48+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 80;
   END;
     (* RULE 79/2075 *)
    c:=  48+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 79;
   END;
     (* RULE 78/2087 *)
    c:=  48+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 78;
   END;
   MatchChainRules(e);
 END FloatCompare;


 PROCEDURE  SetCompare (
                      Atrel  :  CgBase.Relation
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetCompare;
   a^.SetCompare.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 77/2105 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.SetCompare.rel <= RelUnequal  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 77;
   END;
   END;
     (* RULE 76/2114 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.SetCompare.rel > RelUnequal  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 76;
   END;
   END;
   MatchChainRules(e);
 END SetCompare;


 PROCEDURE  PointerCompare (
                      Atrel  :  CgBase.Relation
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FixedCompare (SignedLong, Atrel, op1, op2, result)
 END PointerCompare;


 PROCEDURE  TestMembership (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (AtElemMode, UnsignedLong, op1, op1);
       TestMembershipL (UnsignedLong, Atcond, op1, op2, result); 
 END TestMembership;


 PROCEDURE  TestMembershipL (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestMembershipL;
   a^.TestMembershipL.ElemMode := AtElemMode;
   a^.TestMembershipL.cond := Atcond;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 75/2146 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntRegOrIm]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 75;
   END;
   MatchChainRules(e);
 END TestMembershipL;


 PROCEDURE  TestOdd (
                      Atmode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestOdd;
   a^.TestOdd.mode := Atmode;
   a^.TestOdd.cond := Atcond;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 74/2158 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 74;
   END;
   MatchChainRules(e);
 END TestOdd;


 PROCEDURE  PlaceLabel (
                      Atlab  :  CgBase.Label
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPlaceLabel;
   a^.PlaceLabel.lab := Atlab;
   e^.arity := 0;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 42/2171 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 42;
   END;
   Emit.EmitInstruction (e);
 END PlaceLabel;


 PROCEDURE  Goto (
                      Attar  :  CgBase.Label
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opGoto;
   a^.Goto.tar := Attar;
   e^.arity := 0;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 43/2178 *)
   IF 7 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 7; 
     ga^.stmtrule := 43;
   END;
   Emit.EmitInstruction (e);
 END Goto;


 PROCEDURE  SwitchL (
                      Atmode  :  CgBase.Mode;
                      Atlwb  :  LONGINT;
                      Atupb  :  LONGINT;
                      AtCaseLabels  :  CgBase.LabelList;
                      AtDefaultLabel  :  CgBase.Label
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opSwitchL;
   a^.SwitchL.mode := Atmode;
   a^.SwitchL.lwb := Atlwb;
   a^.SwitchL.upb := Atupb;
   a^.SwitchL.CaseLabels := AtCaseLabels;
   a^.SwitchL.DefaultLabel := AtDefaultLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 44/2185 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 44;
   END;
   Emit.EmitInstruction (e);
 END SwitchL;


 PROCEDURE  TestAndBranch (
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestAndBranch;
   a^.TestAndBranch.cond := Atcond;
   a^.TestAndBranch.tar := Attar;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 45/2206 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 45;
   END;
     (* RULE 46/2215 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 46;
   END;
   Emit.EmitInstruction (e);
 END TestAndBranch;


 PROCEDURE  FixedCompareAndBranch (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedCompareAndBranch;
   a^.FixedCompareAndBranch.mode := Atmode;
   a^.FixedCompareAndBranch.rel := Atrel;
   a^.FixedCompareAndBranch.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 47/2224 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 47;
   END;
     (* RULE 48/2232 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 48;
   END;
     (* RULE 49/2240 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 49;
   END;
   Emit.EmitInstruction (e);
 END FixedCompareAndBranch;


 PROCEDURE  FloatCompareAndBranch (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatCompareAndBranch;
   a^.FloatCompareAndBranch.mode := Atmode;
   a^.FloatCompareAndBranch.rel := Atrel;
   a^.FloatCompareAndBranch.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 50/2248 *)
    c:=  51+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 50;
   END;
     (* RULE 51/2260 *)
    c:=  51+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 51;
   END;
     (* RULE 52/2272 *)
    c:=  51+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 52;
   END;
   Emit.EmitInstruction (e);
 END FloatCompareAndBranch;


 PROCEDURE  SetCompareAndBranch (
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetCompareAndBranch;
   a^.SetCompareAndBranch.rel := Atrel;
   a^.SetCompareAndBranch.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 53/2290 *)
    c:=  9+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.SetCompareAndBranch.rel <= RelUnequal  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 53;
   END;
   END;
     (* RULE 54/2299 *)
    c:=  11+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.SetCompareAndBranch.rel > RelUnequal  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 54;
   END;
   END;
   Emit.EmitInstruction (e);
 END SetCompareAndBranch;


 PROCEDURE  PointerCompareAndBranch (
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FixedCompareAndBranch (SignedLong, Atrel, Attar, op1, op2)
 END PointerCompareAndBranch;


 PROCEDURE  TestMembershipAndBranch (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (AtElemMode, UnsignedLong, op1, op1);
       TestMembershipAndBranchL (UnsignedLong, Atcond, Attar, op1, op2); 
 END TestMembershipAndBranch;


 PROCEDURE  TestMembershipAndBranchL (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestMembershipAndBranchL;
   a^.TestMembershipAndBranchL.ElemMode := AtElemMode;
   a^.TestMembershipAndBranchL.cond := Atcond;
   a^.TestMembershipAndBranchL.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 55/2331 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntRegOrIm]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 55;
   END;
   Emit.EmitInstruction (e);
 END TestMembershipAndBranchL;


 PROCEDURE  TestOddAndBranch (
                      Atmode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestOddAndBranch;
   a^.TestOddAndBranch.mode := Atmode;
   a^.TestOddAndBranch.cond := Atcond;
   a^.TestOddAndBranch.tar := Attar;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 56/2343 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 56;
   END;
   Emit.EmitInstruction (e);
 END TestOddAndBranch;


 PROCEDURE  PreCall (
                      AtParamSize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 INC(CallLevel); 
       IF CallLevel > MaxCallLevel
        THEN ERROR ("Compilerlimit exceeded: Backend: nesting of PROCEDURE-calls to deep!", CurPos)
       END;
       CurParamOffset[CallLevel] := AtParamSize + ReservedParamFrameSize;
       ParamSize     [CallLevel] := AtParamSize;
       callee := NIL;
       Nil (arglist[CallLevel]); 
 END PreCall;


 PROCEDURE  PassValue (
                      Atmode  :  CgBase.Mode;
                      Atoffset  :  LONGINT
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 IF SizeTable[Atmode] < 4 THEN
	 IF SignedTable[Atmode] THEN
	   Coerce (Atmode, SignedLong, op1, op1);
	   Atmode := SignedLong;
	 ELSE
	   Coerce (Atmode, UnsignedLong, op1, op1);
	   Atmode := UnsignedLong;
	 END;
       END;
       Pass (Atmode, Atoffset,
	     arglist[CallLevel], op1, arglist[CallLevel]);
       CurParamOffset[CallLevel] := Atoffset; 
 END PassValue;


 PROCEDURE  PassLongValue (
                      Atsize  :  LONGINT;
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 PassLong (Atsize, Atoffset, CurParamOffset[CallLevel] - Atoffset, 
		 arglist[CallLevel], op1, arglist[CallLevel]);
       CurParamOffset[CallLevel] := Atoffset; 
 END PassLongValue;


 PROCEDURE  PassOpenArrayValue (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
PassValue (SignedLong, Atoffset, op1)
 END PassOpenArrayValue;


 PROCEDURE  PassStringValue (
                      AtSourceLength  :  LONGINT;
                      AtTargetLength  :  LONGINT;
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
PassLongValue (AtSourceLength, Atoffset, op1)
 END PassStringValue;


 PROCEDURE  PassAddress (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
PassValue (SignedLong, Atoffset, op1)
 END PassAddress;


 PROCEDURE  Call (
                         op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 callee := op1; 
 END Call;


 PROCEDURE  SysCall (
                      Atsysproc  :  CgBase.SysProc
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 RTSCall (ParamSize[CallLevel], Atsysproc, arglist[CallLevel]);
       callee := NIL; 
 END SysCall;


 PROCEDURE  PostCall (
                      Atparamsize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 IF callee # NIL
         THEN ProcedureCall (ParamSize[CallLevel], arglist[CallLevel], callee);
       END;
       DEC (CallLevel); 
 END PostCall;


 PROCEDURE  FunctionResult (
                      Atmode  :  CgBase.Mode
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FunctionCall (ParamSize[CallLevel], Atmode, 
		     arglist[CallLevel], callee, result);
       callee := NIL; 
 END FunctionResult;


 PROCEDURE  Nil (
                         VAR result : Arglist);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNil;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 278/2416 *)
   IF 0 <   ga^.cost[ntarglist]  THEN 
     ga^.cost[ntarglist] := 0; 
     ga^.rule[ntarglist] := 278;
   END;
     (* RULE 279/2668 *)
   IF 2 <   ga^.cost[ntloadln2]  THEN 
     ga^.cost[ntloadln2] := 2; 
     ga^.rule[ntloadln2] := 279;
   END;
   MatchChainRules(e);
 END Nil;


 PROCEDURE  SkipArglist (
                         op1  : Arglist
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSkipArglist;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

   Emit.EmitInstruction (e);
 END SkipArglist;


 PROCEDURE  Pass (
                      Atmode  :  CgBase.Mode;
                      Atoffset  :  LONGINT
                      ;  op1  : Arglist
                      ;  op2  : Data
                      ;  VAR result : Arglist);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPass;
   a^.Pass.mode := Atmode;
   a^.Pass.offset := Atoffset;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 277/2418 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  SizeTable[e^.attr^.Pass.mode] = 4  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 277;
   END;
   END;
     (* RULE 276/2436 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntarglist]  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 276;
   END;
     (* RULE 275/2442 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  e^.attr^.Pass.mode = FloatLong  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 275;
   END;
   END;
     (* RULE 274/2452 *)
    c:=  47+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  e^.attr^.Pass.mode >= FloatShort  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 274;
   END;
   END;
   MatchChainRules(e);
 END Pass;


 PROCEDURE  PassLong (
                      Atsize  :  LONGINT;
                      Atoffset  :  LONGINT;
                      Atspace  :  LONGINT
                      ;  op1  : Arglist
                      ;  op2  : Data
                      ;  VAR result : Arglist);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPassLong;
   a^.PassLong.size := Atsize;
   a^.PassLong.offset := Atoffset;
   a^.PassLong.space := Atspace;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 273/2461 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  e^.attr^.PassLong.size <= 4  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 273;
   END;
   END;
     (* RULE 272/2471 *)
    c:=  20+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntarglist]  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 272;
   END;
   MatchChainRules(e);
 END PassLong;


 PROCEDURE  ProcedureCall (
                      Atparamsize  :  LONGINT
                      ;  op1  : Arglist
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opProcedureCall;
   a^.ProcedureCall.paramsize := Atparamsize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 57/2483 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 57;
   END;
     (* RULE 58/2495 *)
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 58;
   END;
   END;
   Emit.EmitInstruction (e);
 END ProcedureCall;


 PROCEDURE  FunctionCall (
                      Atparamsize  :  LONGINT;
                      Atmode  :  CgBase.Mode
                      ;  op1  : Arglist
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFunctionCall;
   a^.FunctionCall.paramsize := Atparamsize;
   a^.FunctionCall.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 73/2507 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FunctionCall.mode < FloatShort  THEN 
 ga^.reg.mode := e^.attr^.FunctionCall.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 73;
   END;
   END;
     (* RULE 72/2522 *)
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FunctionCall.mode < FloatShort  THEN 
 ga^.reg.mode := e^.attr^.FunctionCall.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 72;
   END;
   END;
   END;
     (* RULE 146/2537 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  e^.attr^.FunctionCall.mode >= FloatShort  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 146;
   END;
   END;
     (* RULE 145/2552 *)
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  e^.attr^.FunctionCall.mode >= FloatShort  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 145;
   END;
   END;
   END;
     (* RULE 144/2592 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sqrt') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sqrtL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_sqrt') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_sqrtL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 144;
   END;
   END;
   END;
   END;
   END;
     (* RULE 143/2603 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_exp') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_expL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_exp') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_expL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 143;
   END;
   END;
   END;
   END;
   END;
     (* RULE 142/2641 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
    c:=  5+     e2^.son[1]^.gcg^.cost[ntloadln2]+
     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_ln') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_lnL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_ln') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_lnL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 142;
   END;
   END;
   END;
   END;
     (* RULE 141/2675 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sin') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sinL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_sin') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_sinL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 141;
   END;
   END;
   END;
   END;
   END;
     (* RULE 140/2686 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_cos') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_cosL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_cos') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_cosL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 140;
   END;
   END;
   END;
   END;
   END;
     (* RULE 139/2697 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_arctan') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_arctanL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_arctan') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_arctanL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 139;
   END;
   END;
   END;
   END;
   END;
     (* RULE 138/2713 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntCMem];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_real') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LFLOAT') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_real') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'LFLOAT')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 138;
   END;
   END;
   END;
   END;
   END;
     (* RULE 137/2728 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  10+     e2^.son[2]^.gcg^.cost[ntreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_real') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LFLOAT') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_real') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'LFLOAT')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 137;
   END;
   END;
   END;
   END;
   END;
     (* RULE 195/2745 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LFLOAT') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'LFLOAT')  THEN 
 ga^.FloatConstant.mode := FloatLong;
	  ga^.FloatConstant.val  := LFLOAT(e^.son[1]^.son[2]^.gcg^.Constant.val); ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 195;
   END;
   END;
   END;
   END;
   END;
     (* RULE 194/2755 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_real') OR
         StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_real')  THEN 
 ga^.FloatConstant.mode := FloatShort;
	  ga^.FloatConstant.val  := real(e^.son[1]^.son[2]^.gcg^.Constant.val); ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 194;
   END;
   END;
   END;
   END;
   END;
     (* RULE 71/2763 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  10+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entier') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entierL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_entier') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_entierL')  THEN 
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 71;
   END;
   END;
   END;
   END;
   END;
     (* RULE 172/2779 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntFloatConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entier') OR
	  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entierL') OR
	  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_entier') OR
	  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'MathLib_entierL')) AND
	 (e^.son[1]^.son[2]^.gcg^.FloatConstant.val <= LFLOAT(MAX(INTEGER))) AND
	 (e^.son[1]^.son[2]^.gcg^.FloatConstant.val >= LFLOAT(MIN(INTEGER)))  THEN 
 ga^.Constant.mode := SignedLong;
	  ga^.Constant.val  := entierL (e^.son[1]^.son[2]^.gcg^.FloatConstant.val); ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 172;
   END;
   END;
   END;
   END;
   END;
     (* RULE 70/2807 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  10+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LTRUNC') OR
         StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'LTRUNC')  THEN 
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 70;
   END;
   END;
   END;
   END;
   END;
     (* RULE 171/2821 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntFloatConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LTRUNC') OR
          StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, 'LTRUNC')) AND
	 (e^.son[1]^.son[2]^.gcg^.FloatConstant.val <= LFLOAT(MAX(INTEGER))) AND
	 (e^.son[1]^.son[2]^.gcg^.FloatConstant.val >= LFLOAT(MIN(INTEGER)))  THEN 
 ga^.Constant.mode := SignedLong;
	  ga^.Constant.val  := LTRUNC(e^.son[1]^.son[2]^.gcg^.FloatConstant.val); ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 171;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END FunctionCall;


 PROCEDURE  RTSCall (
                      Atparamsize  :  LONGINT;
                      Atsysproc  :  CgBase.SysProc
                      ;  op1  : Arglist
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRTSCall;
   a^.RTSCall.paramsize := Atparamsize;
   a^.RTSCall.sysproc := Atsysproc;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 59/2567 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 59;
   END;
   Emit.EmitInstruction (e);
 END RTSCall;


 PROCEDURE  BeginProcedure (
                      Atindex  :  CgBase.ProcIndex;
                      Atlevel  :  SHORTCARD;
                      AtFrameSize  :  LONGINT;
                      AtParamSize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opBeginProcedure;
   a^.BeginProcedure.index := Atindex;
   a^.BeginProcedure.level := Atlevel;
   a^.BeginProcedure.FrameSize := AtFrameSize;
   a^.BeginProcedure.ParamSize := AtParamSize;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 62/2848 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 62;
   END;
   Emit.EmitInstruction (e);
 END BeginProcedure;


 PROCEDURE  CopyOpenArray (
                      AtDataOffset  :  LONGINT;
                      AtHighOffset  :  LONGINT;
                      Atelemsize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opCopyOpenArray;
   a^.CopyOpenArray.DataOffset := AtDataOffset;
   a^.CopyOpenArray.HighOffset := AtHighOffset;
   a^.CopyOpenArray.elemsize := Atelemsize;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 63/2952 *)
   IF 20 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 20; 
     ga^.stmtrule := 63;
   END;
   Emit.EmitInstruction (e);
 END CopyOpenArray;


 PROCEDURE  Return (
                      AtParamSize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opReturn;
   a^.Return.ParamSize := AtParamSize;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 64/3000 *)
   IF 20 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 20; 
     ga^.stmtrule := 64;
   END;
   Emit.EmitInstruction (e);
 END Return;


 PROCEDURE  ReturnValueL (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opReturnValueL;
   a^.ReturnValueL.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 65/3033 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.ReturnValueL.mode < FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 65;
   END;
   END;
     (* RULE 66/3036 *)
    c:=       e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.ReturnValueL.mode >= FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 66;
   END;
   END;
   Emit.EmitInstruction (e);
 END ReturnValueL;


 PROCEDURE  ReturnValue (
                      Atmode  :  CgBase.Mode;
                      AtParamSize  :  LONGINT
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
ReturnValueL (Atmode, op1);
      Return (AtParamSize);
 END ReturnValue;


 PROCEDURE  EndProcedure (
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opEndProcedure;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 67/3042 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 67;
   END;
   Emit.EmitInstruction (e);
 END EndProcedure;


 PROCEDURE  EndModule (
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opEndModule;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 68/3052 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 68;
   END;
   Emit.EmitInstruction (e);
 END EndModule;


 PROCEDURE  Mark (
                      Atline  :  SHORTCARD;
                      Atcol  :  SHORTCARD
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opMark;
   a^.Mark.line := Atline;
   a^.Mark.col := Atcol;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 69/3078 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 69;
   END;
   Emit.EmitInstruction (e);
 END Mark;


 BEGIN 
    FirstAttr := NIL; MemExtend;
(******* empty insertion IpIRConsInit *******)
 
 END CgMobil.
