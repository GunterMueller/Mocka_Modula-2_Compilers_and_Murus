  (**************************************************************) 
  (*   This module was generated by BEG V1.84        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
IMPLEMENTATION MODULE Emit;
IMPORT IR;
IMPORT  RegAlloc;
FROM    RegAlloc IMPORT Spilllocation, Action;
(******* empty insertion IpInOut *******)
FROM    InOut IMPORT Write, WriteLn, WriteInt, WriteCard, WriteString;
FROM IR      IMPORT PrintRegister;
FROM IR      IMPORT PrintINTEGER, PrintCARDINAL, PrintBOOLEAN;
(*++++++ start insertion IpTestImport ++++++*)

FROM	Prints	IMPORT	PrintSHORTCARD, PrintLONGCARD, PrintSHORTINT,
			PrintLONGINT, PrintDataTempo, PrintAddressTempo,
			PrintSysProc, PrintLabelList, PrintLabel,
			PrintMode, PrintString, PrintStringIndex, PrintLONGREAL,
			PrintREAL, PrintBITSET, PrintProcIndex, PrintRelation,
			PrintModuleIndex, PrintCHAR, PrintADDRESS,
			PrintRelSymb, PrintMemAdr, PrintAdrMode;


(*------ end   insertion IpTestImport ------*)
FROM    IR      IMPORT NonTerminal, RegisterSet, Register;
(*++++++ start insertion IpNtTypes ++++++*)

FROM IR	IMPORT	MemAdr, AdrMode, AdrModeMode;


(*------ end   insertion IpNtTypes ------*)
(******* empty insertion IpText *******)
(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;
FROM Strings	IMPORT	String;


(*------ end   insertion IpTypes ------*)
(*++++++ start insertion IpEmit_i ++++++*)

FROM	SysLib		IMPORT	exit;
FROM	BasicIO		IMPORT	Erase;
FROM	SuBase		IMPORT	BuildLibraryFileName, KindAssemblerSourceFile,
				FileName, AssemblerScript, LibraryDirectory,
				DefineOption, Enabled, DebugOption,
				SystemCommand;
FROM	SuErrors	IMPORT	ERROR, CompilerError, UndefSourcePos, OK;
FROM	GcgStorage	IMPORT	ALLOCATE;
FROM	CgBase		IMPORT	Tempo, Mode, SysProc, Relation, MakeRelSymb,
				GetLabel, ElfOption, InitCgBase;
FROM	CgTypeMap	IMPORT	ByteSize, WordSize, LongSize,
				SizeREAL, SizeLONGREAL,
				CprocNumber, CompUnitProcNumber;
FROM	CgMobil		IMPORT	UndefOperand;
FROM	CgUtilities	IMPORT	StringAssign, StringLength,
				StringAppend1, StringAppend2, StringConcat2, 
				ConvertLONGINTtoString, ConvertREALtoString,
				IsPowerOfTwo, Log2;
FROM	CgAssOut	IMPORT	AssInt, AssLn, AssChar, AssString, AssHString,
				AssOpen, AssClose;

(* Control lines for the dottool: *)
..* AssRegister(%)
..p AssRegister2 (%)
..w AssWordRegister (%)
..b AssByteRegister (%)
..i AssInt (%)
..c AssChar (%)
..s AssString(%)
..$ AssLn
..% AssHString('%')
..m AssMemAdr(%)
..M AssSuffix(%)
..S AssSigned(%)
..a AssAdrMode(%)
..l AssString(%^)


TYPE	RoundMode	 = (RndNearest, RndZero, RndInf, RndNegInf, RndUnknown);

CONST	MaxDisplay	 = 15;		(* Max. nesting Level of procedures *)
	MaxFloatTempo	 = 64;		(* Max. size of Float-Stack	    *)
	MaxPowerTable	 = 31;
	NoTempo		 = 1111111111;
	Kommentar	 = FALSE;	(* Kommentare ein/aus		    *)

VAR
    RelationTable    : ARRAY CgBase.Relation OF
			 ARRAY [FALSE..TRUE] OF ARRAY [0..2] OF CHAR;
			   (* maps Relation into e,ne,g,ge,l,le,a,ae,b,be  *)

    Reverse	     : ARRAY CgBase.Relation OF CgBase.Relation;
			   (* maps Relation into reverse Relation	   *)
    
    PowerTable       : ARRAY [0 .. MaxPowerTable] OF LONGINT;
                           (* powers of two, 1 <= 2^n <= 2^MaxPowerTable   *)

    WordReg, ByteReg : ARRAY Register OF ARRAY [0..4] OF CHAR;
			   (* maps to register parts                       *)

    SaveDisplay	     : ARRAY [0 .. MaxDisplay] OF BOOLEAN;
                           (* SaveDisplay [i] = TRUE <==> save display of  *)
                           (* current procedure level                      *)

    FStackTempo	     : ARRAY [0 .. MaxFloatTempo-1] OF CgBase.Tempo;
			   (* temporaries if FloatingPoint-Stack overflows *)

    TransferTempo    : CgBase.Tempo;
			   (* temporary for reg <-> freg transfers *)
			  
    oEmitIR, oEmitMatch, oRegAlloc, oAssemblerListing, oCCall : CARDINAL;

    AsmListFileName	: FileName;
    ModName		: ARRAY [0..80] OF CHAR;

    CurFrameSize	: LONGINT;
    CurRoundMode	: RoundMode;

    CurFStackSize	: INTEGER;
    FStackStart		: INTEGER;
	
    ProcLabel		: CgBase.Label;

(* local Variables for Emit-Routines *)
VAR   
	lab, lab2	: CgBase.Label;
	i,j             : LONGINT;
	k		: SHORTCARD;
	str, cmd        : ARRAY [0..255] OF CHAR;
	ok		: BOOLEAN;	
	tr1		: RECORD 
			    CASE : BOOLEAN OF
			    | TRUE : r : REAL;
			    | FALSE : c : LONGINT;
			    END;
			  END;
	tr2		: RECORD 
			    CASE : BOOLEAN OF
			    | TRUE : r : LONGREAL;
			    | FALSE : c2, c1 : LONGINT;
			    END;
			  END;


PROCEDURE   LR  (to, from : Register);
(*  Copy Register from into Register to *)
BEGIN
. 	movl	{*from}, {*to}
	IF Kommentar THEN
.					/* LR */
	END;
END LR;

PROCEDURE   Spill (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
.	pushl	{*reg}
	IF Kommentar THEN
.					/* Spill */
	END;
  ELSE
	IF Kommentar THEN
. 					/* Spill {*reg} */
	END;
  END;
END Spill;

PROCEDURE   Restore (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
.	popl	{*reg}
	IF Kommentar THEN
.					/* Restore */
	END;
  ELSE
	IF Kommentar THEN
. 					/* Restore {*reg} */
	END;
  END;
END Restore;


PROCEDURE SpillFStack;
  VAR i : INTEGER;
BEGIN
  FOR i:=0 TO CurFStackSize - 1 DO
    DeclareTempo (FloatLong, FStackTempo[FStackStart + i]);
.	fstpl	{i FStackTempo[FStackStart + i]}(%ebp)
    IF Kommentar THEN
.					/* SpillFstack */
    END;
  END;
  CurFStackSize := 0;
END SpillFStack;

PROCEDURE PushFStack;
(* Ueberpruefung auf Floating-Point-Stack Ueberlauf *)
(* wird vor jedem push auf den 387 Stack aufgerufen *)
BEGIN
  IF CurFStackSize = 8 THEN
    (* tiefstes Stackelement als Tempo in den Speicher legen *)
    DeclareTempo (FloatLong, FStackTempo[FStackStart + 7]);
.	fxch	%st(7)
.	fstl	{i FStackTempo[FStackStart + 7]}(%ebp)
.	fxch	%st(7)
.	ffree	%st(7)
  ELSE
    INC (CurFStackSize);
  END;
  DEC (FStackStart);
  FStackTempo[FStackStart] := NoTempo;
END PushFStack;

PROCEDURE PopFStack;
(* wird nach jedem pop auf den 387 Stack aufgerufen *)
BEGIN
  INC (FStackStart);
  DEC (CurFStackSize);
END PopFStack;

PROCEDURE FloatOperation (VAR op: ARRAY OF CHAR);
BEGIN
  INC (FStackStart);
  IF FStackTempo[FStackStart] # NoTempo THEN
.	{s op}l	{i FStackTempo[FStackStart]}(%ebp)
    FStackTempo[FStackStart] := NoTempo;
  ELSE
.	{s op}p	%st,%st(1)
    DEC (CurFStackSize);
  END;
END FloatOperation;

PROCEDURE CheckRoundMode (newmode: RoundMode);
BEGIN
  IF CurRoundMode <> newmode THEN
    CASE newmode OF
    | RndNearest:
.	fldcw	fpucw_round_to_nearest
    | RndZero:
.	fldcw	fpucw_round_to_zero
    | RndInf:
.	fldcw	fpucw_round_to_inf
    | RndNegInf:
.	fldcw	fpucw_round_to_neginf
    ELSE
      CompilerError ("Unknown Round Mode");
    END;
    CurRoundMode := newmode;
  END;
END CheckRoundMode;

PROCEDURE CheckRoundMode2 (newmode1, newmode2: RoundMode);
BEGIN
  IF (CurRoundMode <> newmode1) AND (CurRoundMode <> newmode2) THEN
    CheckRoundMode (newmode1);
  END;
END CheckRoundMode2;


PROCEDURE IsNilMemAdr (a: MemAdr) : BOOLEAN;
BEGIN
  RETURN (a.offset = 0) AND
	 (a.faktor = 0) AND
	 (a.base = RegNil) AND
	 (a.symbol = NullSymb)
END IsNilMemAdr;

PROCEDURE EmitIndex (VAR base : MemAdr; index : MemAdr; reg : Register);
BEGIN
  IF NOT IsNilMemAdr (index)
   THEN base.index := reg;
.	movl	{m index},{*reg}
  END (* IF *);
END EmitIndex;


PROCEDURE AssRegister (r : Register);
BEGIN
   AssChar ('%');
   IF r # Regst1
     THEN AssString (IR.RegNameTable[r]);
     ELSE AssString ('st(1)');
   END;
END AssRegister;

PROCEDURE AssRegister2 (r : Register; mode: CgBase.Mode);
BEGIN
  CASE SizeTable[mode] OF
  | 1: AssString (ByteReg[r]);
  | 2: AssString (WordReg[r]);
  | 4,8: AssChar ('%'); AssString (IR.RegNameTable[r]);
    ELSE CompilerError ('Backend: Unknown Register Size');
  END;
END AssRegister2;

PROCEDURE AssWordRegister (r : Register);
BEGIN
   AssString (WordReg[r])
END AssWordRegister;

PROCEDURE AssByteRegister (r : Register);
BEGIN
   AssString (ByteReg[r])
END AssByteRegister;

PROCEDURE AssPlusInt  (i : LONGINT);
BEGIN
   IF i>=0 THEN
      AssString (' + ')
   ELSE
      AssString (' - ')
   END;
   AssInt (ABS (i));
END AssPlusInt;

PROCEDURE AssMemAdr (am: MemAdr);
BEGIN
  WITH am DO
    IF symbol # NullSymb
      THEN AssString (symbol^);
	   IF offset # 0
	     THEN AssPlusInt (offset)
	   END;
      ELSE IF offset # 0
	     THEN AssInt (offset)
	   END;
    END;
    IF (base > RegNil) OR ((index > RegNil) AND (faktor > 0))
      THEN IF (base = RegNil) AND (faktor = 1)
	     THEN base := index;
		  faktor := 0;
	   END; (* IF *)
	   AssChar ('(');
	   IF (base > RegNil)
	     THEN AssRegister(base);
	   END;
	   IF (index > RegNil) AND (faktor > 0)
	     THEN AssChar (',');
		  AssRegister (index);
		  AssChar (',');
		  AssInt (faktor);
	   END;
	   AssChar (')');
    END;
  END;
END AssMemAdr;

PROCEDURE AssAdrMode (am: AdrMode);
BEGIN
  WITH am DO
    CASE kind OF
    | Mconst : AssChar ('$'); AssInt (constant);
    | Mreg   : AssRegister2 (reg,mode);
    | Mmem   : AssMemAdr (mem);
    END;
  END;
END AssAdrMode;

PROCEDURE AssSuffix (s: CgBase.Mode);
BEGIN
  AssChar (SuffixTable[s]);
END AssSuffix;

PROCEDURE AssSigned (s: CgBase.Mode);
BEGIN
  IF SignedTable[s]
    THEN AssChar ('s')
    ELSE AssChar ('z')
  END;
END AssSigned;


PROCEDURE DeclareModule
   (    extern       : BOOLEAN;
    VAR CompUnitName : ARRAY OF CHAR; 
    VAR ref          : CgBase.ModuleIndex);
  VAR str : String;
BEGIN
   NEW (ref);
   WITH ref^ DO
     Extern := extern;
     IF Enabled (ElfOption) THEN
       Name := MakeRelSymb (CompUnitName);
       StringAssign (str, CompUnitName);
       StringAppend1 (str, '_s');
     ELSE
       StringAssign (str,'_');
       StringAppend1 (str, CompUnitName);      
       Name := MakeRelSymb (str);
       StringAppend1 (str,'_s');
     END;
     Statics := MakeRelSymb (str);
   END;
END DeclareModule;


PROCEDURE DeclareProcedure
   (    extern       : BOOLEAN;
	isFunction   : BOOLEAN;
	ProcMode     : CgBase.Mode;
    VAR ProcName     : ARRAY OF CHAR; 
        ProcNumber   : SHORTCARD;
        module       : CgBase.ModuleIndex;
	level        : SHORTCARD;
	father       : CgBase.ProcIndex;
    VAR ref          : CgBase.ProcIndex);
  VAR s,t : String;
BEGIN
  NEW (ref);
  WITH ref^ DO 
     Extern := extern; IsFunction := isFunction;
     Name := MakeRelSymb (ProcName); Number := ProcNumber;
     Module := module; Level := level; Father := father;

     IF ProcNumber # CprocNumber THEN 

 	IF level = 0 THEN 
	   StringAssign (t,module^.Name^);
	ELSE
	   StringAssign (t,father^.Entry^);
	END;

        IF StringLength(t)+1+StringLength(ProcName)>=80 THEN 
	   (* Produce Name and Number   *)
	   ConvertLONGINTtoString (ProcNumber,s);
	   StringAssign (t,module^.Name^);
	   StringAppend1(t,'_');
	   StringAppend1(t,ProcName);
	   StringAppend1(t,'_');
	   StringAppend1(t,s);                  
	ELSE
	   IF ProcNumber # CompUnitProcNumber
	     THEN StringAppend2 (t,'_',ProcName);
	   END;
	END;
	Entry := MakeRelSymb (t);
     ELSE (* ProcNumber = CprocNumber *)
	IF Enabled (ElfOption) THEN
	  Entry := MakeRelSymb (ProcName);
	ELSE
	  StringConcat2 (t,'_',ProcName);
	  Entry := MakeRelSymb (t);
	END;
     END;
.	.globl	{l Entry}
  END;
END DeclareProcedure;


PROCEDURE DeclareString
   (    length : SHORTCARD;
    VAR string : ARRAY OF CHAR; 
    VAR ref    : CgBase.StringIndex);
  VAR l   : CARDINAL;
      c   : CHAR;
      numbersNeedRestart: BOOLEAN;
BEGIN
   numbersNeedRestart:=FALSE;
   GetLabel (ref);
.	.data
.{l ref}:
. 	.ascii	"-
   FOR l := 0 TO length - 1 DO
      c := string[l];
      IF numbersNeedRestart AND ('0'<=c) AND (c<='9') THEN	(* Restart *)
."
.	.ascii	"-
      END;
      IF (' ' <= c) AND (c <= 'z') AND (c # 42C) AND (c # '\') THEN 
	 AssChar (c);
         numbersNeedRestart:=FALSE;
      ELSE
	 IF l < length - 1 THEN
	    AssChar ('\');
.{i ORD (c) DIV 64}{i (ORD (c) MOD 64) DIV 8}{i ORD (c) MOD 8}-
	 END;
         numbersNeedRestart:=TRUE;
      END;
   END;
   AssString ('\000"'); AssLn;
.	.text
END DeclareString;


PROCEDURE DeclareTempo (mode: CgBase.Mode; VAR tempo: CgBase.Tempo);
BEGIN
  IF mode = FloatLong
    THEN INC(CurFrameSize, 8);
    ELSE INC(CurFrameSize, 4);
  END;
  tempo := -CurFrameSize;
END DeclareTempo;

PROCEDURE DeclareTransferTempo;
BEGIN
  IF TransferTempo = NoTempo
    THEN DeclareTempo (FloatShort, TransferTempo);
  END;
END DeclareTransferTempo;

PROCEDURE  BeginModule
   (AtModulName  :  ARRAY OF CHAR;
    AtFrameSize  :  LONGINT);
BEGIN
   CallLevel := 0;
   CurPos.line := 0;
   CurPos.col := 0;

   DisplaySym := MakeRelSymb ('DISPLAY_');

   FOR i := 0 TO MaxDisplay DO SaveDisplay [i] := FALSE; END;

   IR.OptEmitIR		:= Enabled (oEmitIR);
   IR.OptEmitMatch	:= Enabled (oEmitMatch);
   IR.OptRegAlloc	:= Enabled (oRegAlloc);

   BuildLibraryFileName (AtModulName,
			 KindAssemblerSourceFile, AsmListFileName);
   AssOpen (AsmListFileName);
   StringAssign (ModName, AtModulName);

   InitCgBase;

   IF AtFrameSize > 0 THEN
     AssHString('	.comm ');
     IF NOT Enabled(ElfOption) THEN
       AssChar ('_')
     END;
     AssString( AtModulName);
     AssHString('_s, ');
     AssInt ( 4 * ((ABS(AtFrameSize)+3) DIV 4)); AssLn;
   END;
 AssHString('	.text'); AssLn;
END BeginModule;


(*------ end   insertion IpEmit_i ------*)

 VAR ai : CARDINAL;
      localavail : RegisterSet;

(******* empty insertion IpEmit *******)
TYPE   NtAttributes = RECORD
           CASE  : IR.NonTerminal OF 
    | ntreg : reg : RECORD
     END;
    | ntfreg : freg : RECORD
     END;
    | ntfstack : fstack : RECORD
     END;
    | ntConstant : Constant : RECORD
     END;
    | ntFloatConstant : FloatConstant : RECORD
     END;
    | ntSimpleVariable : SimpleVariable : RECORD
     END;
    | ntSymPlusOffset : SymPlusOffset : RECORD
                     symbol  :  CgBase.RelSymb;
     END;
    | ntRegPlusSymPlusOffset : RegPlusSymPlusOffset : RECORD
                     base  :  Register;
                     symbol  :  CgBase.RelSymb;
     END;
    | ntOffsetPlusIndexMultFaktor : OffsetPlusIndexMultFaktor : RECORD
                     index  :  Register;
     END;
    | ntmem : mem : RECORD
                     am  :  MemAdr;
     END;
    | ntCMem : CMem : RECORD
                     am  :  MemAdr;
     END;
    | ntRegOrIm : RegOrIm : RECORD
                     am  :  AdrMode;
     END;
    | ntRegOrCMem : RegOrCMem : RECORD
                     am  :  AdrMode;
     END;
    | ntRegOrCMemOrIm : RegOrCMemOrIm : RECORD
                     am  :  AdrMode;
     END;
    | ntarglist : arglist : RECORD
     END;
    | ntloadln2 : loadln2 : RECORD
     END;
           END;
   END;

PROCEDURE PerformActions (ai : RegAlloc.AllocIndex);
VAR i : CARDINAL;
BEGIN
   WITH RegAlloc.allocation [ai] DO
      FOR i:=1 TO num DO 
	 WITH a[i] DO
	    IF action=aLr THEN   
             LR (regto, regfrom);
    IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (regfrom);
                WriteString (' into ');
                PrintRegister (regto);
                WriteLn;
    END;
	    ELSE 
	       Restore (reg, spilllocation);
    IF IR.OptEmitMatch THEN 
                WriteString (' Restore Register ');
                PrintRegister (reg);
                WriteString (' from ');
                WriteInt (spilllocation,1);
                WriteLn;
    END;
         END;
	 END;
     END;
  END;
END PerformActions;
 
PROCEDURE WriteNest (i : INTEGER);
VAR j : INTEGER;
BEGIN
   FOR j:=1 TO i DO WriteString ('.  '); END;
END WriteNest;
PROCEDURE WriteAttrreg (at: NtAttributes);
BEGIN
END WriteAttrreg;
PROCEDURE WriteAttrfreg (at: NtAttributes);
BEGIN
END WriteAttrfreg;
PROCEDURE WriteAttrfstack (at: NtAttributes);
BEGIN
END WriteAttrfstack;
PROCEDURE WriteAttrConstant (at: NtAttributes);
BEGIN
END WriteAttrConstant;
PROCEDURE WriteAttrFloatConstant (at: NtAttributes);
BEGIN
END WriteAttrFloatConstant;
PROCEDURE WriteAttrSimpleVariable (at: NtAttributes);
BEGIN
END WriteAttrSimpleVariable;
PROCEDURE WriteAttrSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('symbol=');
       PrintRelSymb ( at.SymPlusOffset.symbol ); 
       Write (' ');
END WriteAttrSymPlusOffset;
PROCEDURE WriteAttrRegPlusSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('base=');
       PrintRegister ( at.RegPlusSymPlusOffset.base ); 
       Write (' ');
       WriteString ('symbol=');
       PrintRelSymb ( at.RegPlusSymPlusOffset.symbol ); 
       Write (' ');
END WriteAttrRegPlusSymPlusOffset;
PROCEDURE WriteAttrOffsetPlusIndexMultFaktor (at: NtAttributes);
BEGIN
       WriteString ('index=');
       PrintRegister ( at.OffsetPlusIndexMultFaktor.index ); 
       Write (' ');
END WriteAttrOffsetPlusIndexMultFaktor;
PROCEDURE WriteAttrmem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.mem.am ); 
       Write (' ');
END WriteAttrmem;
PROCEDURE WriteAttrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.CMem.am ); 
       Write (' ');
END WriteAttrCMem;
PROCEDURE WriteAttrRegOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrIm.am ); 
       Write (' ');
END WriteAttrRegOrIm;
PROCEDURE WriteAttrRegOrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMem.am ); 
       Write (' ');
END WriteAttrRegOrCMem;
PROCEDURE WriteAttrRegOrCMemOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMemOrIm.am ); 
       Write (' ');
END WriteAttrRegOrCMemOrIm;
PROCEDURE WriteAttrarglist (at: NtAttributes);
BEGIN
END WriteAttrarglist;
PROCEDURE WriteAttrloadln2 (at: NtAttributes);
BEGIN
END WriteAttrloadln2;

PROCEDURE EmitNtreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntreg] OF 
   | 70 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 70/2807 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	subl	$4,%esp
	CheckRoundMode (RndZero);
.	fistpl	(%esp)
.	popl	{*RegAlloc.allocation[ai].reg}
	PopFStack;
	
   | 71 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 71/2763 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	subl	$4,%esp
	CheckRoundMode (RndNegInf);
.	fistpl	(%esp)
.	popl	{*RegAlloc.allocation[ai].reg}
	PopFStack;
	
   | 72 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 72/2522 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
.	call	{l e^.son[2]^.attr^.ProcedureConstant.index^.Entry}
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.FunctionCall.paramsize}, %esp
	END;
	
   | 73 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 73/2507 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
.	call	{*RegAlloc.allocation[ai].op[2]}
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.FunctionCall.paramsize}, %esp
	END;
	
   | 74 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 74/2158 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestOdd ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	and{M e^.attr^.TestOdd.mode}	$1,{p RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode}
	IF NOT e^.attr^.TestOdd.cond THEN
.	xor{M e^.attr^.TestOdd.mode}	$1,{p RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode}
	END;
	
   | 75 : 
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 75/2146 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestMembershipL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	btl	{a AT0.RegOrIm.am},{a AT1.RegOrCMem.am}
	IF e^.attr^.TestMembershipL.cond THEN
.	setb	{b RegAlloc.allocation[ai].reg}
	ELSE
.	setnb	{b RegAlloc.allocation[ai].reg}
	END;
	
   | 76 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 76/2114 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	movl	{*RegAlloc.allocation[ai].op[1]},{*RegAlloc.allocation[ai].scr[1]}
	CASE e^.attr^.SetCompare.rel OF
	| RelLess:
.	or	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[ai].scr[1]}
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelLessOrEqual:
.	and	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[ai].scr[1]}
	e^.attr^.SetCompare.rel := RelEqual;
	| RelGreater:
.	and	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[ai].scr[1]}
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelGreaterOrEqual:
.	or	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[ai].scr[1]}
	e^.attr^.SetCompare.rel := RelEqual;
	END;
.	cmpl	{*RegAlloc.allocation[ai].scr[1]},{*RegAlloc.allocation[ai].op[1]}
.	set{s RelationTable[e^.attr^.SetCompare.rel][FALSE]}	{b RegAlloc.allocation[ai].reg}
	
   | 77 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 77/2105 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cmpl	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[ai].op[1]}
.	set{s RelationTable[e^.attr^.SetCompare.rel][FALSE]}	{b RegAlloc.allocation[ai].reg}
	
   | 78 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 78/2087 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
.	fcompl	{i FStackTempo[FStackStart]}(%ebp)
	  DEC (CurFStackSize);
	ELSE
.	fcompp
	  DEC (CurFStackSize, 2);
	END;
.	fstsw	%ax
.	sahf
.	set{s RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]}	{b RegAlloc.allocation[ai].reg}
	
   | 79 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 79/2075 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	fcomp{M e^.son[1]^.gcg^.CMem.mode}	{m AT0.CMem.am}
.	fstsw	%ax
.	sahf
.	set{s RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]}	{b RegAlloc.allocation[ai].reg}
	PopFStack;
	
   | 80 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 80/2063 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	fcomp{M e^.son[2]^.gcg^.CMem.mode}	{m AT1.CMem.am}
.	fstsw	%ax
.	sahf
.	set{s RelationTable[e^.attr^.FloatCompare.rel][SignedTable[e^.attr^.FloatCompare.mode]]}	{b RegAlloc.allocation[ai].reg}
	PopFStack;
	
   | 81 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 81/2055 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cmp{M e^.attr^.FixedCompare.mode}	${i e^.son[1]^.gcg^.Constant.val},{a AT1.RegOrCMem.am}
.	set{s RelationTable[Reverse[e^.attr^.FixedCompare.rel]][SignedTable[e^.attr^.FixedCompare.mode]]}	{b RegAlloc.allocation[ai].reg}
	
   | 82 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 82/2047 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cmp{M e^.attr^.FixedCompare.mode}	{a AT1.RegOrIm.am},{m AT0.CMem.am}
.	set{s RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]}	{b RegAlloc.allocation[ai].reg}
	
   | 83 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 83/2039 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cmp{M e^.attr^.FixedCompare.mode}	{a AT1.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedCompare.mode}
.	set{s RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]}	{b RegAlloc.allocation[ai].reg}
	
   | 84 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 84/1987 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
.	cmp{M e^.attr^.CheckL.LwbMode}	{a AT1.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[1],e^.attr^.CheckL.LwbMode}
.	j{s RelationTable[RelLess][SignedTable[e^.attr^.CheckL.LwbMode]]}	{l lab2}
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
.	cmp{M e^.attr^.CheckL.UpbMode}	{a AT2.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[1],e^.attr^.CheckL.UpbMode}
.	j{s RelationTable[RelLessOrEqual][SignedTable[e^.attr^.CheckL.UpbMode]]}	{l lab}
	ELSE
.	jmp	{l lab}
	END;
.{l lab2}:
.   	call	BoundErr_		
.{l lab}:
	
   | 85 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 85/1974 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	push{M e^.son[1]^.gcg^.reg.mode}	{a AT2.RegOrCMemOrIm.am}
.	push{M e^.son[1]^.gcg^.reg.mode}	{a AT1.RegOrCMemOrIm.am}
.	bound{M e^.son[1]^.gcg^.reg.mode}	{p RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode},(%esp)
.	addl	${i 2*SizeTable[e^.son[1]^.gcg^.reg.mode]},%esp
	
   | 86 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 86/1946 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
.	.data
	CASE SizeTable[e^.son[1]^.gcg^.reg.mode] OF
	| 4:
.	.align 4
.{l lab}:
.	.long	{i e^.son[2]^.gcg^.Constant.val},{i e^.son[3]^.gcg^.Constant.val}
	| 2:
.	.align 2
.{l lab}:
.	.word	{i e^.son[2]^.gcg^.Constant.val},{i e^.son[3]^.gcg^.Constant.val}
	END;
.	.text
.	bound{M e^.son[1]^.gcg^.reg.mode}	{p RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode},{l lab}
	
   | 87 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 87/1941 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 88 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 88/1881 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 89 : 
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 89/1868 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF SignedTable[e^.attr^.Coerce.premode] AND SignedTable[e^.attr^.Coerce.postmode] THEN
.	movs{M e^.son[1]^.gcg^.RegOrCMem.mode}{M e^.attr^.Coerce.postmode}	{a AT0.RegOrCMem.am},{p RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode}
	ELSE
.	movz{M e^.son[1]^.gcg^.RegOrCMem.mode}{M e^.attr^.Coerce.postmode}	{a AT0.RegOrCMem.am},{p RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode}
	END;
	
   | 90 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 90/1785 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Trunc ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
.	fcoml	TwoExp31_
.	fstsw	%ax
.	sahf
.	jb	{l lab}
.	fsubl	TwoExp32_
.{l lab}:
.	subl	$4,%esp
	CheckRoundMode2 (RndZero, RndNegInf);
.	fistpl	(%esp)
.	popl	{*RegAlloc.allocation[ai].reg}
	PopFStack;
	
   | 91 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 91/1735 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Cap ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 GetLabel(lab);
.	cmpb	${i ORD('a')},{b RegAlloc.allocation[ai].op[1]}
.	jl	{l lab}
.	cmpb	${i ORD('z')},{b RegAlloc.allocation[ai].op[1]}
.	jg	{l lab}
.	subb	${i ORD('a') - ORD('A')},{b RegAlloc.allocation[ai].op[1]}
.{l lab}:
	
   | 92 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtreg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 92/1713 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 GetLabel(lab);
. 	sub{M e^.attr^.SetPlusRange.LwbMode} 	{a AT1.RegOrCMemOrIm.am},{p Regecx,e^.attr^.SetPlusRange.LwbMode}
. 	jl	{l lab}
.	incb	%cl
.	movl	$-1,{*RegAlloc.allocation[ai].scr[1]}
.	shll	%cl,{*RegAlloc.allocation[ai].scr[1]}
.	notl	{*RegAlloc.allocation[ai].scr[1]}
.	mov{M e^.attr^.SetPlusRange.LwbMode}	{a AT1.RegOrCMemOrIm.am},{p Regecx,e^.attr^.SetPlusRange.LwbMode}
.	shll	%cl,{*RegAlloc.allocation[ai].scr[1]}
.	orl	{*RegAlloc.allocation[ai].scr[1]},{*RegAlloc.allocation[ai].op[1]}
.{l lab}:
       
   | 93 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 93/1707 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	orl	${i PowerTable[e^.son[3]^.gcg^.Constant.val+1]-PowerTable[e^.son[2]^.gcg^.Constant.val]},{*RegAlloc.allocation[ai].op[1]} 
   | 94 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 94/1701 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	btsl	{a AT1.RegOrIm.am}, {*RegAlloc.allocation[ai].op[1]} 
   | 95 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 95/1695 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	orl	${i PowerTable[e^.son[2]^.gcg^.Constant.val]}, {*RegAlloc.allocation[ai].op[1]} 
   | 96 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 96/1672 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	xorl	{a AT1.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[1]} 
   | 97 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 97/1672 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	xorl	{a AT0.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[2]} 
   | 98 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 98/1653 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	andl	{a AT1.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[1]} 
   | 99 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 99/1653 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	andl	{a AT0.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[2]} 
   | 100 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 100/1618 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

. 	andl	${i INTEGER(BITSET(-1) - BITSET(e^.son[2]^.gcg^.Constant.val))}, {*RegAlloc.allocation[ai].op[1]}
	
   | 101 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 101/1609 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	notl	{*RegAlloc.allocation[ai].op[2]}
. 	andl	{a AT0.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[2]}
	
   | 102 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 102/1590 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	orl	{a AT1.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[1]} 
   | 103 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 103/1590 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	orl	{a AT0.RegOrCMemOrIm.am}, {*RegAlloc.allocation[ai].op[2]} 
   | 104 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 104/1503 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cwd
.	idiv{M e^.attr^.FixedMod.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode}
	
   | 105 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 105/1492 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	xor{M e^.attr^.FixedMod.mode}	{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode},{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode}
.	div{M e^.attr^.FixedMod.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode}
	
   | 106 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 106/1481 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cdq
.	idiv{M e^.attr^.FixedMod.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode}
	
   | 107 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 107/1460 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	and{M e^.attr^.FixedMod.mode}	${i e^.son[2]^.gcg^.Constant.val-1}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMod.mode} 
   | 108 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 108/1443 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cwd
.	idiv{M e^.attr^.FixedDiv.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode}
	
   | 109 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 109/1431 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	xor{M e^.attr^.FixedDiv.mode}	{p Regedx,e^.attr^.FixedDiv.mode},{p Regedx,e^.attr^.FixedDiv.mode}
.	div{M e^.attr^.FixedDiv.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode}
	
   | 110 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 110/1419 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	cdq
.	idiv{M e^.attr^.FixedDiv.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode}
	
   | 111 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 111/1388 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	sar{M e^.attr^.FixedDiv.mode}	${i Log2 (e^.son[2]^.gcg^.Constant.val)}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode} 
   | 112 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 112/1365 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	shr{M e^.attr^.FixedDiv.mode}	${i Log2 (e^.son[2]^.gcg^.Constant.val)}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode} 
   | 113 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 113/1349 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 114 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 114/1343 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 115 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 115/1317 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	mul{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode} 
   | 116 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 116/1287 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

EmitIndex (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[ai].reg);
.	mov{M e^.attr^.FixedMult.mode}	{m e^.son[1]^.son[1]^.gcg^.SimpleVariable.base},{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode}
.	imul{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode},{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode}
	
   | 117 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 117/1281 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	imul{M e^.attr^.FixedMult.mode}	${i e^.son[1]^.gcg^.Constant.val},{a AT1.RegOrCMem.am},{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode} 
   | 118 : 
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 118/1281 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	imul{M e^.attr^.FixedMult.mode}	${i e^.son[2]^.gcg^.Constant.val},{a AT0.RegOrCMem.am},{p RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode} 
   | 119 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 119/1274 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	imul{M e^.attr^.FixedMult.mode}	{a AT1.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode} 
   | 120 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 120/1274 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	imul{M e^.attr^.FixedMult.mode}	{a AT0.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode} 
   | 121 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 121/1206 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[2]^.gcg^.Constant.val)}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode} 
   | 122 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 122/1206 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[1]^.gcg^.Constant.val)}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode} 
   | 123 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 123/1160 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	add{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}
.	add{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}
	
   | 124 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 124/1160 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	add{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}
.	add{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}
	
   | 125 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 125/1153 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	add{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode} 
   | 126 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 126/1153 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	add{M e^.attr^.FixedMult.mode}	{p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode} 
   | 127 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 127/1140 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 128 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 128/1140 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 129 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 129/1090 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMinus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	sub{M e^.son[2]^.gcg^.RegOrCMemOrIm.mode}	{a AT1.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode} 
   | 130 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 130/993 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	add{M e^.son[2]^.gcg^.RegOrCMemOrIm.mode}	{a AT1.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode} 
   | 131 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 131/993 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
. 	add{M e^.son[1]^.gcg^.RegOrCMemOrIm.mode}	{a AT0.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].op[2],e^.son[1]^.gcg^.RegOrCMemOrIm.mode} 
   | 132 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 132/922 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedAbs ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
.	cmp{M e^.attr^.FixedAbs.mode}	$0,{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode}
.	jg	{l lab}
.	neg{M e^.attr^.FixedAbs.mode}	{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode}
.{l lab}:
	
   | 133 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 133/902 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedNegate ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	neg{M e^.attr^.FixedNegate.mode}	{p RegAlloc.allocation[ai].op[1],e^.attr^.FixedNegate.mode}
	
   | 134 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 134/620 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FrameBase ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 135 : 
  EmitNtRegOrCMemOrIm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 135/445 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' RegOrCMemOrIm ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	mov{M e^.gcg^.RegOrCMemOrIm.mode}	{a AT0.RegOrCMemOrIm.am},{p RegAlloc.allocation[ai].reg,e^.gcg^.RegOrCMemOrIm.mode}
	
   | 136 : 
  EmitNtmem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 136/430 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' mem ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF (AT0.mem.am.offset = 0) AND
	   (AT0.mem.am.faktor = 1) AND
	   (AT0.mem.am.symbol = NullSymb) AND
	   (((AT0.mem.am.base  = RegAlloc.allocation[ai].reg) AND (AT0.mem.am.index = RegNil)) OR
	    ((AT0.mem.am.index = RegAlloc.allocation[ai].reg) AND (AT0.mem.am.base  = RegNil))) THEN
	  (* skip leal (reg),reg *)
	ELSE
.	leal	{m AT0.mem.am},{*RegAlloc.allocation[ai].reg}
	END;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtreg;

PROCEDURE EmitNtfreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfreg] OF 
   | 137 : 
  EmitNtreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 137/2728 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
.	pushl	{*RegAlloc.allocation[ai].op[1]}
.	fildl	(%esp)
.	addl	$4,%esp
	
   | 138 : 
  EmitNtCMem(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 138/2713 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
.	fildl	{m AT0.CMem.am}
	
   | 139 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 139/2697 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
.	flds	RealOne_
.	fpatan
	PopFStack;
	
   | 140 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 140/2686 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fcos
   | 141 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 141/2675 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fsin
   | 142 : 
  EmitNtloadln2(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 142/2641 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF CurFStackSize < 2 THEN
	(* Es wurde RealLn2_ zwar geladen, aber dann wegen Funktionsaufrufen *)
	(* als Tempo in den Speicher ausgelagert. Deshalb wird RealLn2_      *)
	(* hier erneut geladen, die ersten beiden Stackregister vertauscht,  *)
	(* und die Markierung als Tempo (die Speicherstelle) geloescht.      *)
	(* Im Normalfall wird durch das Nichtterminalloadln2 die Konstante   *)
	(* RealLn2_ vor (!) der Auswertung des Funktionsarguments in RegAlloc.allocation[ai].reg*)
	(* auf den Floating-Point-Stack geladen.			     *)
.	fldl	RealLn2_
.	fxch	%st(1)
	FStackTempo[FStackStart+1] := NoTempo;
	INC (CurFStackSize);
	END;
.	fyl2x
	PopFStack;
	
   | 143 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 143/2603 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	(* e^x = 2^(x * log2e) *) 
.	fmull	RealLog2e_
	(* Normierung noetig: Fuer f2xm1 muss -0.5 <= st <= +0.5 gelten *)
	(* Daher Aufteilung von x = hi + lo mit |lo| <= 0.5		*)
	(* Neues Register fuer hi, weil x noch gebraucht wird 		*)
	PushFStack;
.	fld	%st
	(* Rundung hier zur naechsten ganzen Zahl, deshalb Aenderung    *)
	(* des Steuerwortes						*)
	CheckRoundMode (RndNearest);
.	frndint
	(* Neues Register fuer lo, weil hi noch gebraucht wird 		*)
	PushFStack;
.	fld	%st
	(* Differenz von x und hi -> lo					*)
.	fsubr	%st(2),%st
	(* Berechnung von 2^lo						*)
.	f2xm1
.	fadds	RealOne_
	(* Berechnung 2^hi * 2^lo					*)
.	fscale
	(* Benutzte Register wieder poppen (und Ergebnis weitergeben)	*)
.	fstp	%st(1)
	PopFStack;
.	fstp	%st(1)
	PopFStack;
	
   | 144 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 144/2592 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fsqrt
   | 145 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 145/2552 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
.	call	{l e^.son[2]^.attr^.ProcedureConstant.index^.Entry}
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.FunctionCall.paramsize}, %esp
	END;
	PushFStack;
	
   | 146 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 146/2537 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
.	call	{*RegAlloc.allocation[ai].op[2]}
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.FunctionCall.paramsize}, %esp
	END;
	PushFStack;
	
   | 147 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
  EmitNtCMem(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 147/2010 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CheckL ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
.	fcom{M e^.attr^.CheckL.LwbMode}	{m AT1.CMem.am}
.	fstsw	%ax
.	sahf
.	jb	{l lab2}
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
.	fcom{M e^.attr^.CheckL.UpbMode}	{m AT2.CMem.am}
.	fstsw	%ax
.	sahf
.	jbe	{l lab}
	ELSE
.	jmp	{l lab}
	END;
.{l lab2}:
.   	call	BoundErr_		
.{l lab}:
	
   | 148 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 148/1897 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Coerce ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 149 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 149/1760 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	PushFStack;
.	pushl	{*RegAlloc.allocation[ai].op[1]}
.	fildl	(%esp)
.	addl	$4,%esp
.	cmpl	$0x7fffffff,{*RegAlloc.allocation[ai].op[1]}
.	jbe	{l lab}
.	faddl	TwoExp32_
.{l lab}:
	
   | 150 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 150/1748 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	PushFStack;
.	fildl	{m AT0.CMem.am}
.	cmpl	$0x7fffffff,{m AT0.CMem.am}
.	jbe	{l lab}
.	faddl	TwoExp32_
.{l lab}:
	
   | 151 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 151/1582 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatAbs ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fabs 
   | 152 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 152/1577 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fdivr'); 
   | 153 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 153/1572 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fdiv'); 
   | 154 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 154/1567 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fdivr{M e^.attr^.FloatDiv.mode}	{m AT0.CMem.am} 
   | 155 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 155/1562 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fdiv{M e^.attr^.FloatDiv.mode}	{m AT1.CMem.am} 
   | 156 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 156/1557 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fmul'); 
   | 157 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 157/1557 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fmul'); 
   | 158 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 158/1552 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fmul{M e^.attr^.FloatMult.mode}	{m AT1.CMem.am} 
   | 159 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 159/1552 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fmul{M e^.attr^.FloatMult.mode}	{m AT0.CMem.am} 
   | 160 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 160/1547 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fsub'); 
   | 161 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 161/1542 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fsubr'); 
   | 162 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 162/1537 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fsubr{M e^.attr^.FloatMinus.mode}	{m AT0.CMem.am} 
   | 163 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 163/1532 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fsub{M e^.attr^.FloatMinus.mode}	{m AT1.CMem.am} 
   | 164 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 164/1527 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fadd'); 
   | 165 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 165/1527 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fadd'); 
   | 166 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 166/1522 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fadd{M e^.attr^.FloatPlus.mode}	{m AT1.CMem.am} 
   | 167 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 167/1522 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fadd{M e^.attr^.FloatPlus.mode}	{m AT0.CMem.am} 
   | 168 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 168/1517 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatNegate ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
.	fchs 
   | 169 : 
  EmitNtCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 169/490 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CMem ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
.	fld{M e^.gcg^.CMem.mode}	{m AT0.CMem.am}
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrfreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfreg;

PROCEDURE EmitNtfstack (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfstack] OF 
   | 170 : 
  EmitNtfreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 170/497 Cost=');
          WriteInt    (e^.gcg^.cost [ntfstack],1);
          WriteString (' freg ->   fstack');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF Kommentar THEN
.					/* Kettenregel {*RegAlloc.allocation[ai].op[1]} -> {*RegAlloc.allocation[ai].reg} */
	END;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrfstack (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfstack;

PROCEDURE EmitNtConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntConstant] OF 
   | 171 : 
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 171/2821 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 172 : 
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 172/2779 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 173 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 173/1823 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Coerce ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 174 : 
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 174/1778 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Trunc ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 175 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 175/1455 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMod ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 176 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 176/1411 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 177 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 177/1338 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 178 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 178/1135 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 179 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 179/1135 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 180 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 180/1131 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 181 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 181/1123 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 182 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 182/1041 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 183 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 183/935 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedPlus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 184 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 184/910 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedAbs ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 185 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 185/898 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedNegate ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 186 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 186/544 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' NilConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 187 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 187/540 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' SetConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 188 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 188/535 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' BoolConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 189 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 189/531 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' CharConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 190 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 190/519 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 191 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 191/515 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 192 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 192/511 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 193 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 193/507 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrConstant (resAttributes);
       WriteLn;
   END;
END EmitNtConstant;

PROCEDURE EmitNtFloatConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntFloatConstant] OF 
   | 194 : 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 194/2755 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 195 : 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 195/2745 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 196 : 
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 196/1892 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 197 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 197/1887 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 198 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 198/1774 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Float ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 199 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 199/527 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' LongRealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 200 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 200/523 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' RealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrFloatConstant (resAttributes);
       WriteLn;
   END;
END EmitNtFloatConstant;

PROCEDURE EmitNtSimpleVariable (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntSimpleVariable] OF 
   | 201 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 201/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 202 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1]^.son[1],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 202/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 203 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 203/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 204 : 
  EmitNtConstant(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[1]^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 204/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 205 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 205/1085 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedMinus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 206 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 206/988 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 207 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 207/988 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 208 : 
  EmitNtConstant(e^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 208/634 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 SaveDisplay [e^.son[1]^.attr^.FrameBase.level] := TRUE; 
   | 209 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 209/634 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 SaveDisplay [e^.son[2]^.attr^.FrameBase.level] := TRUE; 
   | 210 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 210/579 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' StaticVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 211 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 211/559 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' LocalVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrSimpleVariable (resAttributes);
       WriteLn;
   END;
END EmitNtSimpleVariable;

PROCEDURE EmitNtSymPlusOffset (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntSymPlusOffset] OF 
   | 212 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 212/1828 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Coerce ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 213 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 213/1045 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedMinus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 214 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 214/939 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 215 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 215/939 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol; 
   | 216 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 216/591 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StaticVariable ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StaticVariable.module^.Statics; 
   | 217 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 217/552 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StringAddr ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StringAddr.index; 
   | 218 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 218/548 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' ProcedureConstant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.ProcedureConstant.index^.Entry; 
   | 219 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 219/332 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Constant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= NullSymb; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtSymPlusOffset;

PROCEDURE EmitNtRegPlusSymPlusOffset (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegPlusSymPlusOffset] OF 
   | 220 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 220/1834 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' Coerce ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 221 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 221/1065 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 222 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 222/1055 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
	resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
.	mov{S e^.son[1]^.gcg^.reg.mode}{M e^.son[1]^.gcg^.reg.mode}l	{p RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode},{*RegAlloc.allocation[ai].op[1]}
	
   | 223 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 223/1049 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb; 
   | 224 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 224/959 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 225 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 225/959 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.RegPlusSymPlusOffset.symbol; 
   | 226 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 226/949 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[2];
	resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
.	mov{S e^.son[2]^.gcg^.reg.mode}{M e^.son[2]^.gcg^.reg.mode}l	{p RegAlloc.allocation[ai].op[2],e^.son[2]^.gcg^.reg.mode},{*RegAlloc.allocation[ai].op[2]}
	
   | 227 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 227/949 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
	resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol;
.	mov{S e^.son[1]^.gcg^.reg.mode}{M e^.son[1]^.gcg^.reg.mode}l	{p RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode},{*RegAlloc.allocation[ai].op[1]}
	
   | 228 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 228/943 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[2];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 229 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 229/943 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol; 
   | 230 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 230/571 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' LocalVariable ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= Regebp;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb; 
   | 231 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 231/347 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
.	mov{S e^.gcg^.reg.mode}{M e^.gcg^.reg.mode}l	{p RegAlloc.allocation[ai].op[1],e^.gcg^.reg.mode},{*RegAlloc.allocation[ai].op[1]}
	
   | 232 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 232/341 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	  resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1]; 
   | 233 : 
  EmitNtSymPlusOffset(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 233/336 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' SymPlusOffset ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegNil;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegPlusSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtRegPlusSymPlusOffset;

PROCEDURE EmitNtOffsetPlusIndexMultFaktor (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntOffsetPlusIndexMultFaktor] OF 
   | 234 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 234/1841 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' Coerce ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 235 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 235/1354 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedDiv ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index; 
   | 236 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 236/1170 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index; 
   | 237 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 237/1170 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT1.OffsetPlusIndexMultFaktor.index; 
   | 238 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 238/1070 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMinus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 239 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 239/964 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 240 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 240/964 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT1.OffsetPlusIndexMultFaktor.index; 
   | 241 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 241/363 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.OffsetPlusIndexMultFaktor.index		:= RegAlloc.allocation[ai].op[1];
.	mov{S e^.gcg^.reg.mode}{M e^.gcg^.reg.mode}l	{p RegAlloc.allocation[ai].op[1],e^.gcg^.reg.mode},{*RegAlloc.allocation[ai].op[1]}
	
   | 242 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 242/357 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrOffsetPlusIndexMultFaktor (resAttributes);
       WriteLn;
   END;
END EmitNtOffsetPlusIndexMultFaktor;

PROCEDURE EmitNtmem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntmem] OF 
   | 243 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 243/1848 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' Coerce ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 244 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 244/1259 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[2]^.gcg^.Constant.val DIV 9)}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 245 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 245/1259 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[1]^.gcg^.Constant.val DIV 9)}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 246 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 246/1244 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[2]^.gcg^.Constant.val DIV 5)}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 247 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 247/1244 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[1]^.gcg^.Constant.val DIV 5)}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 248 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 248/1229 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[2]^.gcg^.Constant.val DIV 3)}, {p RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode}
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 249 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 249/1229 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	shl{M e^.attr^.FixedMult.mode}	${i Log2(e^.son[1]^.gcg^.Constant.val DIV 3)}, {p RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode}
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 250 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 250/1179 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb; 
   | 251 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 251/1179 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb; 
   | 252 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 252/1076 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMinus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset - e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 253 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 253/979 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset + e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 254 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 254/979 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT1.mem.am.offset + e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT1.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT1.mem.am.base;
	  resAttributes.mem.am.index	:= AT1.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT1.mem.am.symbol; 
   | 255 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 255/970 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT1.RegPlusSymPlusOffset.symbol; 
   | 256 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 256/970 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 257 : 
  EmitNtOffsetPlusIndexMultFaktor(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 257/382 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' OffsetPlusIndexMultFaktor ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  resAttributes.mem.am.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= RegNil;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= NullSymb; 
   | 258 : 
  EmitNtRegPlusSymPlusOffset(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 258/373 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' RegPlusSymPlusOffset ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= 1;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= RegNil;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrmem (resAttributes);
       WriteLn;
   END;
END EmitNtmem;

PROCEDURE EmitNtCMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntCMem] OF 
   | 259 : 
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 259/1917 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
.	mov{M e^.attr^.Coerce.premode}	{a AT0.RegOrIm.am},{m resAttributes.CMem.am}
	
   | 260 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 260/1901 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
.	fstp{M e^.attr^.Coerce.premode}	{m resAttributes.CMem.am}
	PopFStack;
	
   | 261 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 261/1859 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am.offset	:= AT0.CMem.am.offset;
	  resAttributes.CMem.am.faktor	:= AT0.CMem.am.faktor;
	  resAttributes.CMem.am.base	:= AT0.CMem.am.base;
	  resAttributes.CMem.am.index	:= AT0.CMem.am.index;
	  resAttributes.CMem.am.symbol	:= AT0.CMem.am.symbol; 
   | 262 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 262/689 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Content ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am	 := AT0.mem.am; 
   | 263 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 263/624 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FrameBase ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am.offset	:= 4*e^.attr^.FrameBase.level;
	  resAttributes.CMem.am.faktor	:= 0;
	  resAttributes.CMem.am.base	:= RegNil;
	  resAttributes.CMem.am.index	:= RegNil;
	  resAttributes.CMem.am.symbol	:= DisplaySym;
	  SaveDisplay [e^.attr^.FrameBase.level] := TRUE; 
   | 264 : 
  EmitNtFloatConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 264/471 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr2.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
.	.data
.	.align 4
.{l lab}:
.	.long	{i tr2.c2},{i tr2.c1}		# {s str}
.	.text
	
   | 265 : 
  EmitNtFloatConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 265/452 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr1.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
.	.data
.	.align 4
.{l lab}:
.	.long	{i tr1.c}		# {s str}
.	.text
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtCMem;

PROCEDURE EmitNtRegOrIm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrIm] OF 
   | 266 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 266/418 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' Constant ->   RegOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrIm.am.kind  := Mconst;
	  resAttributes.RegOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrIm.am.constant := e^.gcg^.Constant.val; 
   | 267 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 267/391 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' reg ->   RegOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrIm.am.kind := Mreg;
	  resAttributes.RegOrIm.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrIm.am.reg  := RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrIm;

PROCEDURE EmitNtRegOrCMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrCMem] OF 
   | 268 : 
  EmitNtCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 268/403 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' CMem ->   RegOrCMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMem.am.kind := Mmem;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.CMem.mode;
	  resAttributes.RegOrCMem.am.mem  := AT0.CMem.am; 
   | 269 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 269/397 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' reg ->   RegOrCMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMem.am.kind := Mreg;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrCMem.am.reg  := RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMem;

PROCEDURE EmitNtRegOrCMemOrIm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrCMemOrIm] OF 
   | 270 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 270/424 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' Constant ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMemOrIm.am.kind  := Mconst;
	  resAttributes.RegOrCMemOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrCMemOrIm.am.constant := e^.gcg^.Constant.val; 
   | 271 : 
  EmitNtRegOrCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 271/409 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' RegOrCMem ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMemOrIm.am.kind := AT0.RegOrCMem.am.kind;
	  resAttributes.RegOrCMemOrIm.am.mode := e^.gcg^.RegOrCMem.mode;
	  IF AT0.RegOrCMem.am.kind = Mreg
	    THEN resAttributes.RegOrCMemOrIm.am.reg := AT0.RegOrCMem.am.reg;
	    ELSE resAttributes.RegOrCMemOrIm.am.mem := AT0.RegOrCMem.am.mem;
	  END; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrCMemOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMemOrIm;

PROCEDURE EmitNtarglist (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntarglist] OF 
   | 272 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 272/2471 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	subl	${i e^.attr^.PassLong.space},%esp
.	movl	%esp,%edi
.	movl	${i (e^.attr^.PassLong.size + 3) DIV 4},%ecx
.	cld
.	repz
.	movsl
	
   | 273 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 273/2461 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF e^.attr^.PassLong.space > 4 THEN
.	subl	${i e^.attr^.PassLong.space - 4},%esp
	END;	
.	pushl	{m AT1.mem.am}
	
   | 274 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 274/2452 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	subl	${i SizeTable[e^.attr^.Pass.mode]},%esp
.	fstp{M e^.attr^.Pass.mode}	(%esp)
	PopFStack;
	
   | 275 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 275/2442 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	INC (AT1.CMem.am.offset, 4);
.	pushl	{m AT1.CMem.am}
	DEC (AT1.CMem.am.offset, 4);
.	pushl	{m AT1.CMem.am}
	
   | 276 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 276/2436 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	pushl	${i e^.son[2]^.gcg^.Constant.val}
	
   | 277 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 277/2418 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

.	pushl	{a AT1.RegOrCMemOrIm.am}
	
   | 278 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 278/2416 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Nil ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrarglist (resAttributes);
       WriteLn;
   END;
END EmitNtarglist;

PROCEDURE EmitNtloadln2 (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR

BEGIN
   CASE e^.gcg^.rule [ntloadln2] OF 
   | 279 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 279/2668 Cost=');
          WriteInt    (e^.gcg^.cost [ntloadln2],1);
          WriteString (' Nil ->   loadln2');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
.	fldl	RealLn2_
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrloadln2 (resAttributes);
       WriteLn;
   END;
END EmitNtloadln2;

PROCEDURE EmitStatement (e : IR.Expression);
CONST nest = 0;  
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

VAR   i        : INTEGER;
BEGIN
   ai := RegAlloc.ai;
   IF e^.gcg^.stmtcost >= IR.infcost THEN 
     (*************** Compiler Error ******************)
     (******** No code selected, no cover found *******)
     WriteString ('no code selected'); WriteLn;
     IR.PrintInstrCosts (e);
     WriteLn;
     IR.Error ('internal error');
     i := 0; i := 1 DIV i; HALT;
   ELSE
     CASE e^.gcg^.stmtrule OF 
     | 1 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 1/696 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	mov{M e^.attr^.Assign.mode}	{a AT1.RegOrIm.am},{m AT0.mem.am} 
     | 2 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 2/701 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

.	fstp{M e^.attr^.Assign.mode}	{m AT0.mem.am}
	PopFStack;
	
     | 3 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 3/709 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr1.r := e^.son[2]^.gcg^.FloatConstant.val;
.	movl	${i tr1.c},{m AT0.mem.am}
	
     | 4 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 4/717 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr2.r := e^.son[2]^.gcg^.FloatConstant.val;
.	movl	${i tr2.c2},{m AT0.mem.am}
	INC (AT0.mem.am.offset, 4);
.	movl	${i tr2.c1},{m AT0.mem.am}	
	
     | 5 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 5/727 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

.	movl	{m AT1.CMem.am},{*RegAlloc.allocation[1].scr[1]}
.	movl	{*RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	
     | 6 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 6/736 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

.	movl	{m AT1.CMem.am},{*RegAlloc.allocation[1].scr[1]}
.	movl	{*RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	INC (AT0.mem.am.offset, 4);
	INC (AT1.CMem.am.offset, 4);
.	movl	{m AT1.CMem.am},{*RegAlloc.allocation[1].scr[1]}
.	movl	{*RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	
     | 7 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 7/749 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 8 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 8/773 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

.	leal	{m AT1.mem.am},%esi
.	leal	{m AT0.mem.am},%edi
	IF AT0.mem.am.offset MOD 4 >= 1 THEN
	  DEC (e^.attr^.AssignLong.size, 4-(AT0.mem.am.offset MOD 4));
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
.	movl	${i e^.attr^.AssignLong.size DIV 4},%ecx
	END;
.	cld
	IF AT0.mem.am.offset MOD 2 = 1 THEN
.	movsb
	END;
	IF (AT0.mem.am.offset MOD 4 = 1) OR (AT0.mem.am.offset MOD 4 = 2) THEN
.	movsw
	END;
	IF e^.attr^.AssignLong.size >= 8 THEN
.	repz
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
.	movsl
	END;
	IF e^.attr^.AssignLong.size MOD 4 >= 2 THEN
.	movsw
	END;
	IF e^.attr^.AssignLong.size MOD 2 >= 1 THEN
.	movsb
	END;
	
     | 9 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 9/807 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.AssignLong.size >= 4 THEN
.	movl	{m AT1.mem.am},{*RegAlloc.allocation[1].scr[1]}
.	movl	{*RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	INC (AT1.mem.am.offset, 4);
	INC (AT0.mem.am.offset, 4);
	DEC (e^.attr^.AssignLong.size, 4);
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
.	movl	{m AT1.mem.am},{*RegAlloc.allocation[1].scr[1]}
.	movl	{*RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	INC (AT1.mem.am.offset, 4);
	INC (AT0.mem.am.offset, 4);
	DEC (e^.attr^.AssignLong.size, 4);
	END;
	IF e^.attr^.AssignLong.size DIV 2 > 0 THEN
.	movw	{m AT1.mem.am},{w RegAlloc.allocation[1].scr[1]}
.	movw	{w RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	INC (AT1.mem.am.offset, 2);
	INC (AT0.mem.am.offset, 2);
	END;
	IF e^.attr^.AssignLong.size MOD 2 > 0 THEN
.	movb	{m AT1.mem.am},{b RegAlloc.allocation[1].scr[1]}
.	movb	{b RegAlloc.allocation[1].scr[1]},{m AT0.mem.am}
	END;
	
     | 10 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 10/838 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc1');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	inc{M e^.attr^.Inc1.mode}	{m AT0.mem.am} 
     | 11 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 11/842 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec1');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	dec{M e^.attr^.Dec1.mode}	{m AT0.mem.am} 
     | 12 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 12/846 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc2');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	add{M e^.attr^.Inc2.mode}	{a AT1.RegOrIm.am},{m AT0.mem.am} 
     | 13 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 13/850 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec2');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	sub{M e^.attr^.Dec2.mode}	{a AT1.RegOrIm.am},{m AT0.mem.am} 
     | 14 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 14/865 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' InclL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	btsl	{a AT1.RegOrIm.am},{m AT0.mem.am} 
     | 15 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 15/882 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ExclL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
.	btrl	{a AT1.RegOrIm.am},{m AT0.mem.am} 
     | 16 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 16/889 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipAddress');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 17 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 17/892 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipData');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 18 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 18/999 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	inc{M e^.attr^.Assign.mode}	{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 19 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 19/999 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	inc{M e^.attr^.Assign.mode}	{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 20 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 20/1013 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	add{M e^.attr^.Assign.mode}	{a AT1.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 21 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 21/1013 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	add{M e^.attr^.Assign.mode}	{a AT2.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 22 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 22/1026 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	shl{M e^.attr^.Assign.mode}	$1, {m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 23 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 23/1096 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	dec{M e^.attr^.Assign.mode}	{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 24 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 24/1110 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	sub{M e^.attr^.Assign.mode}	{a AT2.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 25 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 25/1145 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 26 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 26/1145 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 27 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 27/1214 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	shl{M e^.attr^.Assign.mode}	${i Log2(e^.son[2]^.son[1]^.gcg^.Constant.val)}, {m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 28 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 28/1214 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	shl{M e^.attr^.Assign.mode}	${i Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)}, {m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 29 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 29/1300 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	mov{M e^.attr^.Assign.mode}	{m e^.son[1]^.gcg^.SimpleVariable.base},{p RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode}
.	imul{M e^.attr^.Assign.mode}	{p RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode},{p RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode}
.	mov{M e^.attr^.Assign.mode}	{p RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 30 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 30/1373 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	shr{M e^.attr^.Assign.mode}	${i Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)}, {m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 31 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 31/1396 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	sar{M e^.attr^.Assign.mode}	${i Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)}, {m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 32 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 32/1467 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	and{M e^.attr^.Assign.mode}	${i e^.son[2]^.son[2]^.gcg^.Constant.val-1}, {m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 33 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 33/1596 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	orl	{a AT1.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 34 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 34/1596 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	orl	{a AT2.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 35 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtreg(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 35/1626 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	notl	{*RegAlloc.allocation[1].op[3]}
. 	andl	{*RegAlloc.allocation[1].op[3]},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 36 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 36/1640 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
. 	andl	${i INTEGER(BITSET(-1) - BITSET(e^.son[2]^.son[2]^.gcg^.Constant.val))},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 37 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 37/1659 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	andl	{a AT1.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 38 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 38/1659 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	andl	{a AT2.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 39 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 39/1678 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	xorl	{a AT1.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 40 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 40/1678 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
.	xorl	{a AT2.RegOrIm.am},{m e^.son[1]^.gcg^.SimpleVariable.base}
	
     | 41 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 41/1804 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel(lab);
.	fcoml	TwoExp31_
.	fstsw	%ax
.	sahf
.	jb	{l lab}
.	fsubl	TwoExp32_
.{l lab}:
	CheckRoundMode2 (RndZero, RndNegInf);
.	fistpl	{m AT0.mem.am }
	PopFStack;
	
     | 42 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 42/2171 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' PlaceLabel');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.{l e^.attr^.PlaceLabel.lab}:
	
     | 43 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 43/2178 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Goto');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	jmp	{l e^.attr^.Goto.tar}
	
     | 44 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 44/2185 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SwitchL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel (lab);
.	.data
.	.align 4
.{l lab}:
	WHILE e^.attr^.SwitchL.CaseLabels # NIL DO
.	.long	{l e^.attr^.SwitchL.CaseLabels^.label}
	  e^.attr^.SwitchL.CaseLabels := e^.attr^.SwitchL.CaseLabels^.next;
	END;
.	.text
	CurRoundMode := RndUnknown;
.	sub{M e^.attr^.SwitchL.mode}	${i e^.attr^.SwitchL.lwb},{p RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode}
.	j{s RelationTable[RelLess][SignedTable[e^.attr^.SwitchL.mode]]}	{l e^.attr^.SwitchL.DefaultLabel}
.	cmp{M e^.attr^.SwitchL.mode}	${i e^.attr^.SwitchL.upb - e^.attr^.SwitchL.lwb},{p RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode}
.	j{s RelationTable[RelGreater][SignedTable[e^.attr^.SwitchL.mode]]}	{l e^.attr^.SwitchL.DefaultLabel}
.	jmp	*{l lab}(,{*RegAlloc.allocation[1].op[1]},4)
	
     | 45 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 45/2206 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
	CurRoundMode := RndUnknown;
.	cmpb	${i k},{b RegAlloc.allocation[1].op[1]}
.	je	{l e^.attr^.TestAndBranch.tar}
	
     | 46 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 46/2215 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
	CurRoundMode := RndUnknown;
.	cmpb	${i k},{m AT0.CMem.am}
.	je	{l e^.attr^.TestAndBranch.tar}
	
     | 47 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 47/2224 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	cmp{M e^.attr^.FixedCompareAndBranch.mode}	{a AT1.RegOrCMemOrIm.am},{p RegAlloc.allocation[1].op[1],e^.attr^.FixedCompareAndBranch.mode}
.	j{s RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]}	{l e^.attr^.FixedCompareAndBranch.tar}
	
     | 48 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 48/2232 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	cmp{M e^.attr^.FixedCompareAndBranch.mode}	{a AT1.RegOrIm.am},{m AT0.CMem.am}
.	j{s RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]}	{l e^.attr^.FixedCompareAndBranch.tar}
	
     | 49 :
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 49/2240 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	cmp{M e^.attr^.FixedCompareAndBranch.mode}	${i e^.son[1]^.gcg^.Constant.val},{a AT1.RegOrCMem.am}
.	j{s RelationTable[Reverse[e^.attr^.FixedCompareAndBranch.rel]][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]}	{l e^.attr^.FixedCompareAndBranch.tar}
	
     | 50 :
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 50/2248 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	fcomp{M e^.son[2]^.gcg^.CMem.mode}	{m AT1.CMem.am}
.	fstsw	%ax
.	sahf
.	j{s RelationTable[e^.attr^.FloatCompareAndBranch.rel][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]}	{l e^.attr^.FloatCompareAndBranch.tar}
	PopFStack;
	
     | 51 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 51/2260 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	fcomp{M e^.son[1]^.gcg^.CMem.mode}	{m AT0.CMem.am}
.	fstsw	%ax
.	sahf
.	j{s RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]}	{l e^.attr^.FloatCompareAndBranch.tar}
	PopFStack;
	
     | 52 :
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 52/2272 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
.	fcompl	{i FStackTempo[FStackStart]}(%ebp)
	  DEC (CurFStackSize);
	ELSE
.	fcompp
	  DEC (CurFStackSize, 2);
	END;
.	fstsw	%ax
.	sahf
.	j{s RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]}	{l e^.attr^.FloatCompareAndBranch.tar}
	
     | 53 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 53/2290 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	cmpl	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[1].op[1]}
.	j{s RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]}	{l e^.attr^.SetCompareAndBranch.tar}
	
     | 54 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 54/2299 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	movl	{*RegAlloc.allocation[1].op[1]},{*RegAlloc.allocation[1].scr[1]}
	CASE e^.attr^.SetCompareAndBranch.rel OF
	| RelLess:
.	or	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[1].scr[1]}
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelLessOrEqual:
.	and	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[1].scr[1]}
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	| RelGreater:
.	and	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[1].scr[1]}
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelGreaterOrEqual:
.	or	{a AT1.RegOrCMemOrIm.am},{*RegAlloc.allocation[1].scr[1]}
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	END;
.	cmpl	{*RegAlloc.allocation[1].scr[1]},{*RegAlloc.allocation[1].op[1]}
.	j{s RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]}	{l e^.attr^.SetCompareAndBranch.tar}
	
     | 55 :
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 55/2331 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestMembershipAndBranchL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	btl	{a AT0.RegOrIm.am},{a AT1.RegOrCMem.am}
	IF e^.attr^.TestMembershipAndBranchL.cond THEN
.	jc	{l e^.attr^.TestMembershipAndBranchL.tar}
	ELSE
.	jnc	{l e^.attr^.TestMembershipAndBranchL.tar}
	END;
	
     | 56 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 56/2343 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestOddAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	and{M e^.attr^.TestOddAndBranch.mode}	$1,{p RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode}
	IF NOT e^.attr^.TestOddAndBranch.cond THEN
.	xor{M e^.attr^.TestOddAndBranch.mode}	$1,{p RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode}
	END;
.	jnz	{l e^.attr^.TestOddAndBranch.tar}
	
     | 57 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 57/2483 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	call	{*RegAlloc.allocation[1].op[2]}
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN 
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.ProcedureCall.paramsize}, %esp
	END;
	
     | 58 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 58/2495 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
.	call	{l e^.son[2]^.attr^.ProcedureConstant.index^.Entry}
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN 
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.ProcedureCall.paramsize}, %esp
	END;
	
     | 59 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 59/2567 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' RTSCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
	CASE e^.attr^.RTSCall.sysproc OF 
	      | SysProcHALT : 
.	call	exit_
	      | SysProcTransfer : 
.	call	Transfer_
	      | SysProcNewprocess : 
.	call	NewProcess_
	      | SysProcCaseError : 
.	call	CaseErr_
	      | SysProcReturnError : 
.	call	ReturnErr_
	END;
	IF e^.attr^.RTSCall.paramsize # 0 THEN 
	(* e^.attr^.RTSCall.paramsize := (e^.attr^.RTSCall.paramsize+3) DIV 4 * 4; *)
.	addl	${i e^.attr^.RTSCall.paramsize}, %esp
	END;
	
     | 60 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 60/2791 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CheckRoundMode (RndNegInf);
.	fistpl	{m AT0.mem.am}
	PopFStack;
	
     | 61 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 61/2831 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CheckRoundMode (RndZero);
.	fistpl	{m AT0.mem.am}
	PopFStack;
	
     | 62 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 62/2848 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' BeginProcedure');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   UndefOperand := IR.emptyExpression;
   CurLevel := e^.attr^.BeginProcedure.level;
   CurFrameSize := 4 * ((ABS(e^.attr^.BeginProcedure.FrameSize)+3) DIV 4);
   CurRoundMode := RndUnknown;
   IF CurLevel > MaxDisplay THEN 
      ERROR ('too many nested procedures', CurPos);
      CurLevel := 0;
   END;
   CurFStackSize := 0;
   FStackStart := MaxFloatTempo;
   TransferTempo := NoTempo;

(* -------------------------------------------------------------------- *)
(* Die Daten werden bei Prozeduren wie folgt auf dem Stack abgelegt :	*)
(*		------------------------- <--- Stackanfang (MaxAdr)	*)
(*		|			|				*)
(*		|	.......		|				*)
(*		|			|				*)
(*	    .	|-----------------------|				*)
(*	    .	|	Parameter	|				*)
(*	    .	| (bei OpenArrays nur	|				*)
(*	    8	|  Adresse und Laenge)	|				*)
(*		|-----------------------|				*)
(*	    4	|    Return-Adresse	|				*)
(*		|-----------------------|				*)
(*	    0	|   alter BasePointer   | <--- BasePointer (ebp)	*)
(*		|-----------------------|   )				*)
(*	   -4	| alter DV [CurLevel]	|   )				*)
(*		|-----------------------|   )				*)
(*	   -8	| lokale Variablen	|   )  Activation Record (AR)	*)
(*	    .	|-----------------------|   )				*)
(*	    .	| evtl.temporaere Werte	|   )				*)
(*	    .	|-----------------------|   )				*)
(*		| evtl. OpenArrays	|   )				*)
(*		|-----------------------|   )				*)
(*		| Platz fuer Sicherungen|   )				*)
(*		|-----------------------| <--- StackPointer (esp)	*)
(*									*)
(* Der DisplayVector DV enthaelt jeweils den aktuellen BP der zuletzt	*)
(* auf dem jeweiligen Level ausgefuehrten Prozedur.			*)
(* Der DisplayVector steht ab der Stelle DISPLAY_ im Speicher,		*)
(* durch das sich die Adresse vom DisplayVector des Levels i, also	*)
(* DV [i], als DISPLAY_ + i*4 errechnen laesst.				*)
(* Aus Optimierungsgruenden wird jedoch der DV nicht in jedem Level	*)
(* gespeichert und geladen, sondern nur, falls eine Prozedur des Levels *)
(* i auf eine nicht-globale Variable des Levels j (j < i) zugreift.	*)
(* -------------------------------------------------------------------- *)

(* Zunaechst den Label bestimmen, an dem der die Groesse des Activation *)
(* Records bei EndProcedure gespeichert wird. Diese kann durch die un-	*)
(* gewisse Zahl der benoetigten temporaeren Werte erst am Schluss	*)
(* bestimmt werden.							*)
	GetLabel (ProcLabel);
(* Startlabel der Prozedur eintragen *)
.	.align 4
.{l e^.attr^.BeginProcedure.index^.Entry}:
(* Alten BP sichern *)
.	pushl	%ebp
(* Neuer BP fuer neuen Activation Record *)
.	movl	%esp,%ebp
(* Platz fuer alten DisplayVector[CurLevel], lokale Variablen und	*)
(* temporaere Werte schaffen.						*)
.	subl	${l ProcLabel}, %esp
     IF SaveDisplay [CurLevel] THEN
(* Aktualisieren des DisplayVectors,  wird fuer andere Prozedur benoetigt. *)
(* Laden des momentanen DisplayVectors [CurLevel] *)
.	movl	DISPLAY_+{i 4 * CurLevel},%ecx
(* Sichern des alten Wertes des DisplayVectors [CurLevel] *)
.	movl	%ecx,-4(%ebp)
(* Schreiben des aktuellen DisplayVectors [CurLevel] *)
.	movl	%ebp,DISPLAY_+{i 4 * CurLevel}
     END;

(* !!!!!!!!!! Registersicherung bei Funktionsaufrufen !!!!!!!!!!
   Linux/BSD: edi, esi, ebx werden in aufgerufener Funktion gesichert,
	      ecx, edx werden in aufrufender Funktion gesichert,
	      eax oder st behinhaltet den Rueckgabewert
   MOCKA:     edi, esi, ebx, ecx, edx werden in aufrufender Funktion gesichert,
	      eax oder st behinhaltet den Rueckgabewert
   Dieser Unterschied ist unwesentlich bei Aufruf von C-Funktionen
   (z.B. libc) aus MOCKA-Programmen. Im umgekehrten Fall (Aufruf von MOCKA-
   Funktionen von C aus, z.B. von atexit-Funktionen) fuehrt dies zu Fehlern.
   Abhilfe: Die CcallsMocka Option
   Diese sichert immer edi, esi, ebx, egal ob sie veraendert werden oder
   nicht (was genau geaendert wird, weiss man bei einem 1-Pass Compiler
   leider nicht). Dies ist im Normalfall ueberfluessig, und sollte daher
   aus Performancegruenden auf die Funktionen beschraenkt werden, die
   von C aus aufgerufen werden.						*)
     IF Enabled (oCCall) THEN
.	pushl %edi
.	pushl %esi
.	pushl %ebx
     END;

     IF Kommentar THEN
.	/* --------------------------------------------------------- */
.	/* Level : {i CurLevel} */
.	/* --------------------------------------------------------- */
     END;
	
     | 63 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 63/2952 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' CopyOpenArray');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF Kommentar THEN
.	/* Copy Open Array Begin */
	END;
   IF (e^.attr^.CopyOpenArray.elemsize # ByteSize) & ODD (e^.attr^.CopyOpenArray.elemsize) THEN INC (e^.attr^.CopyOpenArray.elemsize); END;
   (* Lade letzten Index (= Laenge - 1) des Stringparameter *)
.	movl	{i e^.attr^.CopyOpenArray.HighOffset}(%ebp),%ecx
   (* Bestimme Laenge des Stringparameters *)
.	incl	%ecx
   (* Ermittle Platzbedarf fuer den Stringparameter.			*)
   (* Das Resultat steht in Register ecx.				*)
      IF e^.attr^.CopyOpenArray.elemsize # ByteSize THEN
      (* Multiplikation Elementanzahl * Elementgroesse = Platzbedarf	*)
      (* durchfuehren.							*)
	 IF IsPowerOfTwo (e^.attr^.CopyOpenArray.elemsize) THEN
.	shll	${i Log2 (e^.attr^.CopyOpenArray.elemsize)}, %ecx
	 ELSE
.	imull	${i e^.attr^.CopyOpenArray.elemsize},%ecx
	 END
      END;
   (* Platzbedarf auf durch 4 teilbare Adresse aufrunden *)
.	addl	$3,%ecx
.	andl	$0xfffffffc, %ecx
   (* Schaffe auf dem Stack entsprechenden Platz *)
.	subl 	%ecx,%esp
   (* Startadresse des zu kopierenden ARRAYs				*)
.	movl	%esp,%edi
   (* Lade Startadresse des OpenArrays *)
.	movl	{i e^.attr^.CopyOpenArray.DataOffset}(%ebp),%esi
    (* Ersetze im Parameterteil der Prozedur die Startadresse des Parameter-
       strings durch die Adresse dessen Kopie auf das OpenArray         *)
.	movl	%edi,{i e^.attr^.CopyOpenArray.DataOffset}(%ebp)
     (* Kopiere Stringparameter in den OpenArray-Platz der Prozedur     *)
     (* Register ecx enthaelt die Groesse				*)
     (* Register esi die Quelladresse,					*)
     (* Register edi die Zieladresse.					*)
.	shrl	$2,%ecx
.	cld
.	repz
.	movsl
	IF Kommentar THEN
.	/* Copy Open Array End */
	END;
	
     | 64 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 64/3000 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Return');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 
	IF (CurFStackSize <> 0) AND OK THEN
.	ERROR: CurFStackSize <> 0
	AssClose;
	CompilerError ("Something's going wrong in fp expression");
	END;	
	CurRoundMode := RndUnknown;
	IF SaveDisplay [CurLevel] THEN
	(* Alten Wert von DisplayVector [CurLevel] laden, wurde veraendert *)
.	movl	-4(%ebp),%ecx
	(* Diesen Wert wieder in DisplayVector [CurLevel] eintragen *)
.	movl	%ecx,DISPLAY_+{i 4 * CurLevel}
	END;
	(* Bei Aufruf von MOCKA Prozeduren von C Programmen 
	   (z.B. atexitHandler) muessen diese in BeginProcedure
	   gesicherten Register wiederhergestellt werden. *)
	IF Enabled (oCCall) THEN
.	popl %ebx
.	popl %esi
.	popl %edi
	END;
	(* Ruecksprung aus der Prozedur *)
.	leave
.	ret
	
     | 65 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 65/3033 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 66 :
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 66/3036 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	PopFStack;
	
     | 67 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 67/3042 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndProcedure');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	SaveDisplay [CurLevel] := FALSE; 
	CurFrameSize :=   4 * ((ABS(CurFrameSize)+3) DIV 4);
.	{l ProcLabel} = {i CurFrameSize}
	
     | 68 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 68/3052 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndModule');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   AssClose;
   IF OK (* no Errors *) THEN 
      StringAssign  (cmd, 'cd '); 
      StringAppend2 (cmd, LibraryDirectory, '; ');
      StringAppend1 (cmd, AssemblerScript);
      IF Enabled (ElfOption) THEN
	 StringAppend1 (cmd,' -elf');
      END;
      IF Enabled (DebugOption) THEN
	 StringAppend1 (cmd,' -g');
      END;
      StringAppend2 (cmd, ' ', ModName); 
      SystemCommand (cmd,ok);
      IF NOT ok THEN 
	 WriteString ("Assembler terminated with error"); WriteLn;
	 exit (1);
      END;
   END;
   IF NOT Enabled (oAssemblerListing) THEN
      Erase (AsmListFileName,ok);
   END;
	
     | 69 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 69/3078 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Mark');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CurPos.line := e^.attr^.Mark.line; CurPos.col := e^.attr^.Mark.col; 
    END;
  END;
END EmitStatement;

PROCEDURE EmitInstruction (e : IR.Expression);
BEGIN
   IF IR.OptEmitIR THEN IR.PrintExpression (e); END;
(*++++++ start insertion IpEmitI1 ++++++*)

      localavail[0] := { ORD (Regeax)-0,  ORD (Regebx)-0,  ORD (Regecx)-0,  ORD (Regedx)-0,  ORD (Regesi)-0,  ORD (Regedi)-0,  ORD (Regst)-0, ORD (Regst1)-0};


(*------ end   insertion IpEmitI1 ------*)
   RegAlloc.RegAllo (e, localavail);
(******* empty insertion IpEmitI2 *******)
   EmitStatement (e);
END EmitInstruction;
 VAR  RegisterSetEmpty : RegisterSet;
BEGIN
  RegisterSetEmpty [0] := {};
(*++++++ start insertion IpEmitInit ++++++*)

    SizeTable [UnsignedByte] := ByteSize;
    SizeTable [UnsignedWord] := WordSize;
    SizeTable [UnsignedLong] := LongSize;
    SizeTable [SignedByte]   := ByteSize;
    SizeTable [SignedWord]   := WordSize;
    SizeTable [SignedLong]   := LongSize;
    SizeTable [FloatShort]   := SizeREAL;
    SizeTable [FloatLong]    := SizeLONGREAL;

    SuffixTable [UnsignedByte] := 'b';
    SuffixTable [UnsignedWord] := 'w';
    SuffixTable [UnsignedLong] := 'l';
    SuffixTable [SignedByte]   := 'b';
    SuffixTable [SignedWord]   := 'w';
    SuffixTable [SignedLong]   := 'l';
    SuffixTable [FloatShort]   := 's';
    SuffixTable [FloatLong]    := 'l';

    SignedTable [UnsignedByte] := FALSE;
    SignedTable [UnsignedWord] := FALSE;
    SignedTable [UnsignedLong] := FALSE;
    SignedTable [SignedByte]   := TRUE;
    SignedTable [SignedWord]   := TRUE;
    SignedTable [SignedLong]   := TRUE;
    SignedTable [FloatShort]   := FALSE;
    SignedTable [FloatLong]    := FALSE;

    RelationTable [RelEqual]	     [FALSE] := 'e';
    RelationTable [RelUnequal]	     [FALSE] := 'ne';
    RelationTable [RelLess]	     [FALSE] := 'b';
    RelationTable [RelLessOrEqual]   [FALSE] := 'be';
    RelationTable [RelGreater]	     [FALSE] := 'a';
    RelationTable [RelGreaterOrEqual][FALSE] := 'ae';
    RelationTable [RelEqual]	     [TRUE ] := 'e';
    RelationTable [RelUnequal]	     [TRUE ] := 'ne';
    RelationTable [RelLess]	     [TRUE ] := 'l';
    RelationTable [RelLessOrEqual]   [TRUE ] := 'le';
    RelationTable [RelGreater]	     [TRUE ] := 'g';
    RelationTable [RelGreaterOrEqual][TRUE ] := 'ge';

    Reverse [RelEqual]		:= RelEqual;
    Reverse [RelUnequal]	:= RelUnequal;
    Reverse [RelLess]		:= RelGreater;
    Reverse [RelLessOrEqual]	:= RelGreaterOrEqual;
    Reverse [RelGreater]	:= RelLess;
    Reverse [RelGreaterOrEqual]	:= RelLessOrEqual;

    PowerTable [0] := 1;
    FOR i := 1 TO MaxPowerTable DO PowerTable [i] := 2 * PowerTable [i-1] END;

    WordReg[Regeax] := '%ax';
    WordReg[Regebx] := '%bx';
    WordReg[Regecx] := '%cx';
    WordReg[Regedx] := '%dx';
    WordReg[Regesi] := '%si';
    WordReg[Regedi] := '%di';
    ByteReg[Regeax] := '%al';
    ByteReg[Regebx] := '%bl';
    ByteReg[Regecx] := '%cl';
    ByteReg[Regedx] := '%dl';

    DefineOption (oEmitIR, 'EmitIR', FALSE, FALSE);
    DefineOption (oEmitMatch, 'EmitMatch', FALSE, FALSE);
    DefineOption (oRegAlloc, 'RegAlloc', FALSE, FALSE);
    DefineOption (oCCall, 'CcallsMocka', FALSE, FALSE);    
    DefineOption (ElfOption, 'elf', FALSE, TRUE);
    DefineOption (oAssemblerListing, 'S', FALSE, TRUE);


(*------ end   insertion IpEmitInit ------*)
END Emit.
