  (**************************************************************) 
  (*   This module was generated by BEG V1.75        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
IMPLEMENTATION MODULE Emit;
IMPORT IR;
IMPORT  RegAlloc;
FROM    RegAlloc IMPORT Spilllocation, Action;
(******* empty insertion IpInOut *******)
FROM    InOut IMPORT Write, WriteLn, WriteInt, WriteCard, WriteString;
FROM IR      IMPORT PrintRegister;
FROM IR      IMPORT PrintINTEGER, PrintCARDINAL, PrintBOOLEAN;
(*++++++ start insertion IpTestImport ++++++*)

FROM	Prints	IMPORT	PrintSHORTCARD, PrintLONGCARD, PrintSHORTINT,
			PrintLONGINT, PrintDataTempo, PrintAddressTempo,
			PrintSysProc, PrintLabelList, PrintLabel,
			PrintMode, PrintString, PrintStringIndex, PrintLONGREAL,
			PrintREAL, PrintBITSET, PrintProcIndex, PrintRelation,
			PrintModuleIndex, PrintCHAR, PrintADDRESS,
			PrintRelSymb, PrintMemAdr, PrintAdrMode;


(*------ end   insertion IpTestImport ------*)
FROM    IR      IMPORT NonTerminal, RegisterSet, Register;
(*++++++ start insertion IpNtTypes ++++++*)

FROM IR	IMPORT	MemAdr, AdrMode, AdrModeMode;


(*------ end   insertion IpNtTypes ------*)
(******* empty insertion IpText *******)
(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;
FROM Strings	IMPORT	String;


(*------ end   insertion IpTypes ------*)
(*++++++ start insertion IpEmit_i ++++++*)

FROM	SysLib		IMPORT	exit;
FROM	BasicIO		IMPORT	Erase;
FROM	SuBase		IMPORT	BuildLibraryFileName, KindAssemblerSourceFile,
				FileName, AssemblerScript, LibraryDirectory,
				DefineOption, Enabled, DebugOption,
				SystemCommand;
FROM	SuErrors	IMPORT	ERROR, CompilerError, UndefSourcePos, OK;
FROM	GcgStorage	IMPORT	ALLOCATE;
FROM	CgBase		IMPORT	Tempo, Mode, SysProc, Relation, MakeRelSymb,
				GetLabel, ElfOption, InitCgBase;
FROM	CgTypeMap	IMPORT	ByteSize, WordSize, LongSize,
				SizeREAL, SizeLONGREAL,
				CprocNumber, CompUnitProcNumber;
FROM	CgMobil		IMPORT	UndefOperand;
FROM	CgUtilities	IMPORT	StringAssign, StringLength,
				StringAppend1, StringAppend2, StringConcat2, 
				ConvertLONGINTtoString, ConvertREALtoString,
				IsPowerOfTwo, Log2;
FROM	CgAssOut	IMPORT	AssInt, AssLn, AssChar, AssString, AssHString,
				AssOpen, AssClose;

(* Control lines for the dottool: *)
















TYPE	RoundMode	 = (RndNearest, RndZero, RndInf, RndNegInf, RndUnknown);

CONST	MaxDisplay	 = 15;		(* Max. nesting Level of procedures *)
	MaxFloatTempo	 = 64;		(* Max. size of Float-Stack	    *)
	MaxPowerTable	 = 31;
	NoTempo		 = 1111111111;
	Kommentar	 = FALSE;	(* Kommentare ein/aus		    *)

VAR
    RelationTable    : ARRAY CgBase.Relation OF
			 ARRAY [FALSE..TRUE] OF ARRAY [0..2] OF CHAR;
			   (* maps Relation into e,ne,g,ge,l,le,a,ae,b,be  *)

    Reverse	     : ARRAY CgBase.Relation OF CgBase.Relation;
			   (* maps Relation into reverse Relation	   *)
    
    PowerTable       : ARRAY [0 .. MaxPowerTable] OF LONGINT;
                           (* powers of two, 1 <= 2^n <= 2^MaxPowerTable   *)

    WordReg, ByteReg : ARRAY Register OF ARRAY [0..4] OF CHAR;
			   (* maps to register parts                       *)

    SaveDisplay	     : ARRAY [0 .. MaxDisplay] OF BOOLEAN;
                           (* SaveDisplay [i] = TRUE <==> save display of  *)
                           (* current procedure level                      *)

    FStackTempo	     : ARRAY [0 .. MaxFloatTempo-1] OF CgBase.Tempo;
			   (* temporaries if FloatingPoint-Stack overflows *)

    TransferTempo    : CgBase.Tempo;
			   (* temporary for reg <-> freg transfers *)
			  
    oEmitIR, oEmitMatch, oRegAlloc, oAssemblerListing, oCCall : CARDINAL;

    AsmListFileName	: FileName;
    ModName		: ARRAY [0..80] OF CHAR;

    CurFrameSize	: LONGINT;
    CurRoundMode	: RoundMode;

    CurFStackSize	: INTEGER;
    FStackStart		: INTEGER;
	
    ProcLabel		: CgBase.Label;

(* local Variables for Emit-Routines *)
VAR   
	lab, lab2	: CgBase.Label;
	i,j             : LONGINT;
	k		: SHORTCARD;
	str, cmd        : ARRAY [0..255] OF CHAR;
	ok		: BOOLEAN;	
	tr1		: RECORD 
			    CASE : BOOLEAN OF
			    | TRUE : r : REAL;
			    | FALSE : c : LONGINT;
			    END;
			  END;
	tr2		: RECORD 
			    CASE : BOOLEAN OF
			    | TRUE : r : LONGREAL;
			    | FALSE : c2, c1 : LONGINT;
			    END;
			  END;


PROCEDURE   LR  (to, from : Register);
(*  Copy Register from into Register to *)
BEGIN
 AssHString(' 	movl	'); AssRegister(from); AssHString(', '); AssRegister(to); AssLn;
	IF Kommentar THEN
 AssHString('					/* LR */'); AssLn;
	END;
END LR;

PROCEDURE   Spill (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
 AssHString('	pushl	'); AssRegister(reg); AssLn;
	IF Kommentar THEN
 AssHString('					/* Spill */'); AssLn;
	END;
  ELSE
	IF Kommentar THEN
 AssHString(' 					/* Spill '); AssRegister(reg); AssHString(' */'); AssLn;
	END;
  END;
END Spill;

PROCEDURE   Restore (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
 AssHString('	popl	'); AssRegister(reg); AssLn;
	IF Kommentar THEN
 AssHString('					/* Restore */'); AssLn;
	END;
  ELSE
	IF Kommentar THEN
 AssHString(' 					/* Restore '); AssRegister(reg); AssHString(' */'); AssLn;
	END;
  END;
END Restore;


PROCEDURE SpillFStack;
  VAR i : INTEGER;
BEGIN
  FOR i:=0 TO CurFStackSize - 1 DO
    DeclareTempo (FloatLong, FStackTempo[FStackStart + i]);
 AssHString('	fstpl	'); AssInt ( FStackTempo[FStackStart + i]); AssHString('(%ebp)'); AssLn;
    IF Kommentar THEN
 AssHString('					/* SpillFstack */'); AssLn;
    END;
  END;
  CurFStackSize := 0;
END SpillFStack;

PROCEDURE PushFStack;
(* Ueberpruefung auf Floating-Point-Stack Ueberlauf *)
(* wird vor jedem push auf den 387 Stack aufgerufen *)
BEGIN
  IF CurFStackSize = 8 THEN
    (* tiefstes Stackelement als Tempo in den Speicher legen *)
    DeclareTempo (FloatLong, FStackTempo[FStackStart + 7]);
 AssHString('	fxch	%st(7)'); AssLn;
 AssHString('	fstl	'); AssInt ( FStackTempo[FStackStart + 7]); AssHString('(%ebp)'); AssLn;
 AssHString('	fxch	%st(7)'); AssLn;
 AssHString('	ffree	%st(7)'); AssLn;
  ELSE
    INC (CurFStackSize);
  END;
  DEC (FStackStart);
  FStackTempo[FStackStart] := NoTempo;
END PushFStack;

PROCEDURE PopFStack;
(* wird nach jedem pop auf den 387 Stack aufgerufen *)
BEGIN
  INC (FStackStart);
  DEC (CurFStackSize);
END PopFStack;

PROCEDURE FloatOperation (VAR op: ARRAY OF CHAR);
BEGIN
  INC (FStackStart);
  IF FStackTempo[FStackStart] # NoTempo THEN
 AssHString('	'); AssString( op); AssHString('l	'); AssInt ( FStackTempo[FStackStart]); AssHString('(%ebp)'); AssLn;
    FStackTempo[FStackStart] := NoTempo;
  ELSE
 AssHString('	'); AssString( op); AssHString('p	%st,%st(1)'); AssLn;
    DEC (CurFStackSize);
  END;
END FloatOperation;

PROCEDURE CheckRoundMode (newmode: RoundMode);
BEGIN
  IF CurRoundMode <> newmode THEN
    CASE newmode OF
    | RndNearest:
 AssHString('	fldcw	fpucw_round_to_nearest'); AssLn;
    | RndZero:
 AssHString('	fldcw	fpucw_round_to_zero'); AssLn;
    | RndInf:
 AssHString('	fldcw	fpucw_round_to_inf'); AssLn;
    | RndNegInf:
 AssHString('	fldcw	fpucw_round_to_neginf'); AssLn;
    ELSE
      CompilerError ("Unknown Round Mode");
    END;
    CurRoundMode := newmode;
  END;
END CheckRoundMode;

PROCEDURE CheckRoundMode2 (newmode1, newmode2: RoundMode);
BEGIN
  IF (CurRoundMode <> newmode1) AND (CurRoundMode <> newmode2) THEN
    CheckRoundMode (newmode1);
  END;
END CheckRoundMode2;


PROCEDURE IsNilMemAdr (a: MemAdr) : BOOLEAN;
BEGIN
  RETURN (a.offset = 0) AND
	 (a.faktor = 0) AND
	 (a.base = RegNil) AND
	 (a.symbol = NullSymb)
END IsNilMemAdr;

PROCEDURE EmitIndex (VAR base : MemAdr; index : MemAdr; reg : Register);
BEGIN
  IF NOT IsNilMemAdr (index)
   THEN base.index := reg;
 AssHString('	movl	'); AssMemAdr( index); AssHString(','); AssRegister(reg); AssLn;
  END (* IF *);
END EmitIndex;


PROCEDURE AssRegister (r : Register);
BEGIN
   AssChar ('%');
   IF r # Regst1
     THEN AssString (IR.RegNameTable[r]);
     ELSE AssString ('st(1)');
   END;
END AssRegister;

PROCEDURE AssRegister2 (r : Register; mode: CgBase.Mode);
BEGIN
  CASE SizeTable[mode] OF
  | 1: AssString (ByteReg[r]);
  | 2: AssString (WordReg[r]);
  | 4,8: AssChar ('%'); AssString (IR.RegNameTable[r]);
    ELSE CompilerError ('Backend: Unknown Register Size');
  END;
END AssRegister2;

PROCEDURE AssWordRegister (r : Register);
BEGIN
   AssString (WordReg[r])
END AssWordRegister;

PROCEDURE AssByteRegister (r : Register);
BEGIN
   AssString (ByteReg[r])
END AssByteRegister;

PROCEDURE AssPlusInt  (i : LONGINT);
BEGIN
   IF i>=0 THEN
      AssString (' + ')
   ELSE
      AssString (' - ')
   END;
   AssInt (ABS (i));
END AssPlusInt;

PROCEDURE AssMemAdr (am: MemAdr);
BEGIN
  WITH am DO
    IF symbol # NullSymb
      THEN AssString (symbol^);
	   IF offset # 0
	     THEN AssPlusInt (offset)
	   END;
      ELSE IF offset # 0
	     THEN AssInt (offset)
	   END;
    END;
    IF (base > RegNil) OR ((index > RegNil) AND (faktor > 0))
      THEN IF (base = RegNil) AND (faktor = 1)
	     THEN base := index;
		  faktor := 0;
	   END; (* IF *)
	   AssChar ('(');
	   IF (base > RegNil)
	     THEN AssRegister(base);
	   END;
	   IF (index > RegNil) AND (faktor > 0)
	     THEN AssChar (',');
		  AssRegister (index);
		  AssChar (',');
		  AssInt (faktor);
	   END;
	   AssChar (')');
    END;
  END;
END AssMemAdr;

PROCEDURE AssAdrMode (am: AdrMode);
BEGIN
  WITH am DO
    CASE kind OF
    | Mconst : AssChar ('$'); AssInt (constant);
    | Mreg   : AssRegister2 (reg,mode);
    | Mmem   : AssMemAdr (mem);
    END;
  END;
END AssAdrMode;

PROCEDURE AssSuffix (s: CgBase.Mode);
BEGIN
  AssChar (SuffixTable[s]);
END AssSuffix;

PROCEDURE AssSigned (s: CgBase.Mode);
BEGIN
  IF SignedTable[s]
    THEN AssChar ('s')
    ELSE AssChar ('z')
  END;
END AssSigned;


PROCEDURE DeclareModule
   (    extern       : BOOLEAN;
    VAR CompUnitName : ARRAY OF CHAR; 
    VAR ref          : CgBase.ModuleIndex);
  VAR str : String;
BEGIN
   NEW (ref);
   WITH ref^ DO
     Extern := extern;
     IF Enabled (ElfOption) THEN
       Name := MakeRelSymb (CompUnitName);
       StringAssign (str, '_');
       StringAppend2 (str, CompUnitName, '_s');
     ELSE
       StringAssign (str,'_');
       StringAppend1 (str, CompUnitName);      
       Name := MakeRelSymb (str);
       StringAppend1 (str,'_s');
     END;
     Statics := MakeRelSymb (str);
   END;
END DeclareModule;


PROCEDURE DeclareProcedure
   (    extern       : BOOLEAN;
	isFunction   : BOOLEAN;
	ProcMode     : CgBase.Mode;
    VAR ProcName     : ARRAY OF CHAR; 
        ProcNumber   : SHORTCARD;
        module       : CgBase.ModuleIndex;
	level        : SHORTCARD;
	father       : CgBase.ProcIndex;
    VAR ref          : CgBase.ProcIndex);
  VAR s,t : String;
BEGIN
  NEW (ref);
  WITH ref^ DO 
     Extern := extern; IsFunction := isFunction;
     Name := MakeRelSymb (ProcName); Number := ProcNumber;
     Module := module; Level := level; Father := father;

     IF ProcNumber # CprocNumber THEN 

 	IF level = 0 THEN 
	   StringAssign (t,module^.Name^);
	ELSE
	   StringAssign (t,father^.Entry^);
	END;

        IF StringLength(t)+1+StringLength(ProcName)>=80 THEN 
	   (* Produce Name and Number   *)
	   ConvertLONGINTtoString (ProcNumber,s);
	   StringAssign (t,module^.Name^);
	   StringAppend1(t,'_');
	   StringAppend1(t,ProcName);
	   StringAppend1(t,'_');
	   StringAppend1(t,s);                  
	ELSE
	   IF ProcNumber # CompUnitProcNumber
	     THEN StringAppend2 (t,'_',ProcName);
	   END;
	END;
	Entry := MakeRelSymb (t);
     ELSE (* ProcNumber = CprocNumber *)
	IF Enabled (ElfOption) THEN
	  Entry := MakeRelSymb (ProcName);
	ELSE
	  StringConcat2 (t,'_',ProcName);
	  Entry := MakeRelSymb (t);
	END;
     END;
 AssHString('	.globl	'); AssString( Entry^); AssLn;
  END;
END DeclareProcedure;


PROCEDURE DeclareString
   (    length : SHORTCARD;
    VAR string : ARRAY OF CHAR; 
    VAR ref    : CgBase.StringIndex);
  VAR l   : CARDINAL;
      c   : CHAR;
      numbersNeedRestart: BOOLEAN;
BEGIN
   numbersNeedRestart:=FALSE;
   GetLabel (ref);
 AssHString('	.data'); AssLn;
 AssString( ref^); AssHString(':'); AssLn;
 AssHString(' 	.ascii	"');
   FOR l := 0 TO length - 1 DO
      c := string[l];
      IF numbersNeedRestart AND ('0'<=c) AND (c<='9') THEN	(* Restart *)
 AssHString('"'); AssLn;
 AssHString('	.ascii	"');
      END;
      IF (' ' <= c) AND (c <= 'z') AND (c # 42C) AND (c # '\') THEN 
	 AssChar (c);
         numbersNeedRestart:=FALSE;
      ELSE
	 IF l < length - 1 THEN
	    AssChar ('\');
 AssInt ( ORD (c) DIV 64); AssInt ( (ORD (c) MOD 64) DIV 8); AssInt ( ORD (c) MOD 8);
	 END;
         numbersNeedRestart:=TRUE;
      END;
   END;
   AssString ('\000"'); AssLn;
 AssHString('	.text'); AssLn;
END DeclareString;


PROCEDURE DeclareTempo (mode: CgBase.Mode; VAR tempo: CgBase.Tempo);
BEGIN
  IF mode = FloatLong
    THEN INC(CurFrameSize, 8);
    ELSE INC(CurFrameSize, 4);
  END;
  tempo := -CurFrameSize;
END DeclareTempo;

PROCEDURE DeclareTransferTempo;
BEGIN
  IF TransferTempo = NoTempo
    THEN DeclareTempo (FloatShort, TransferTempo);
  END;
END DeclareTransferTempo;

PROCEDURE  BeginModule
   (AtModulName  :  ARRAY OF CHAR;
    AtFrameSize  :  LONGINT);
BEGIN
   CallLevel := 0;
   CurPos.line := 0;
   CurPos.col := 0;

   DisplaySym := MakeRelSymb ('DISPLAY_');

   FOR i := 0 TO MaxDisplay DO SaveDisplay [i] := FALSE; END;

   IR.OptEmitIR		:= Enabled (oEmitIR);
   IR.OptEmitMatch	:= Enabled (oEmitMatch);
   IR.OptRegAlloc	:= Enabled (oRegAlloc);

   BuildLibraryFileName (AtModulName,
			 KindAssemblerSourceFile, AsmListFileName);
   AssOpen (AsmListFileName);
   StringAssign (ModName, AtModulName);

   InitCgBase;

   IF AtFrameSize > 0 THEN
 AssHString('	.comm	_'); AssString( AtModulName); AssHString('_s, '); AssInt ( 4 * ((ABS(AtFrameSize)+3) DIV 4)); AssLn;
   END;
 AssHString('	.text'); AssLn;
END BeginModule;


(*------ end   insertion IpEmit_i ------*)

 VAR ai : CARDINAL;
      localavail : RegisterSet;

(******* empty insertion IpEmit *******)
TYPE   NtAttributes = RECORD
           CASE  : IR.NonTerminal OF 
    | ntreg : reg : RECORD
     END;
    | ntfreg : freg : RECORD
     END;
    | ntfstack : fstack : RECORD
     END;
    | ntConstant : Constant : RECORD
     END;
    | ntFloatConstant : FloatConstant : RECORD
     END;
    | ntSimpleVariable : SimpleVariable : RECORD
     END;
    | ntSymPlusOffset : SymPlusOffset : RECORD
                     symbol  :  CgBase.RelSymb;
     END;
    | ntRegPlusSymPlusOffset : RegPlusSymPlusOffset : RECORD
                     base  :  Register;
                     symbol  :  CgBase.RelSymb;
     END;
    | ntOffsetPlusIndexMultFaktor : OffsetPlusIndexMultFaktor : RECORD
                     index  :  Register;
     END;
    | ntmem : mem : RECORD
                     am  :  MemAdr;
     END;
    | ntCMem : CMem : RECORD
                     am  :  MemAdr;
     END;
    | ntRegOrIm : RegOrIm : RECORD
                     am  :  AdrMode;
     END;
    | ntRegOrCMem : RegOrCMem : RECORD
                     am  :  AdrMode;
     END;
    | ntRegOrCMemOrIm : RegOrCMemOrIm : RECORD
                     am  :  AdrMode;
     END;
    | ntarglist : arglist : RECORD
     END;
    | ntloadln2 : loadln2 : RECORD
     END;
           END;
   END;

PROCEDURE PerformActions (ai : RegAlloc.AllocIndex);
VAR i : CARDINAL;
BEGIN
   WITH RegAlloc.allocation [ai] DO
      FOR i:=1 TO num DO 
	 WITH a[i] DO
	    IF action=aLr THEN   
             LR (regto, regfrom);
    IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (regfrom);
                WriteString (' into ');
                PrintRegister (regto);
                WriteLn;
    END;
	    ELSE 
	       Restore (reg, spilllocation);
    IF IR.OptEmitMatch THEN 
                WriteString (' Restore Register ');
                PrintRegister (reg);
                WriteString (' from ');
                WriteInt (spilllocation,1);
                WriteLn;
    END;
         END;
	 END;
     END;
  END;
END PerformActions;
 
PROCEDURE WriteNest (i : INTEGER);
VAR j : INTEGER;
BEGIN
   FOR j:=1 TO i DO WriteString ('.  '); END;
END WriteNest;
PROCEDURE WriteAttrreg (at: NtAttributes);
BEGIN
END WriteAttrreg;
PROCEDURE WriteAttrfreg (at: NtAttributes);
BEGIN
END WriteAttrfreg;
PROCEDURE WriteAttrfstack (at: NtAttributes);
BEGIN
END WriteAttrfstack;
PROCEDURE WriteAttrConstant (at: NtAttributes);
BEGIN
END WriteAttrConstant;
PROCEDURE WriteAttrFloatConstant (at: NtAttributes);
BEGIN
END WriteAttrFloatConstant;
PROCEDURE WriteAttrSimpleVariable (at: NtAttributes);
BEGIN
END WriteAttrSimpleVariable;
PROCEDURE WriteAttrSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('symbol=');
       PrintRelSymb ( at.SymPlusOffset.symbol ); 
       Write (' ');
END WriteAttrSymPlusOffset;
PROCEDURE WriteAttrRegPlusSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('base=');
       PrintRegister ( at.RegPlusSymPlusOffset.base ); 
       Write (' ');
       WriteString ('symbol=');
       PrintRelSymb ( at.RegPlusSymPlusOffset.symbol ); 
       Write (' ');
END WriteAttrRegPlusSymPlusOffset;
PROCEDURE WriteAttrOffsetPlusIndexMultFaktor (at: NtAttributes);
BEGIN
       WriteString ('index=');
       PrintRegister ( at.OffsetPlusIndexMultFaktor.index ); 
       Write (' ');
END WriteAttrOffsetPlusIndexMultFaktor;
PROCEDURE WriteAttrmem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.mem.am ); 
       Write (' ');
END WriteAttrmem;
PROCEDURE WriteAttrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.CMem.am ); 
       Write (' ');
END WriteAttrCMem;
PROCEDURE WriteAttrRegOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrIm.am ); 
       Write (' ');
END WriteAttrRegOrIm;
PROCEDURE WriteAttrRegOrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMem.am ); 
       Write (' ');
END WriteAttrRegOrCMem;
PROCEDURE WriteAttrRegOrCMemOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMemOrIm.am ); 
       Write (' ');
END WriteAttrRegOrCMemOrIm;
PROCEDURE WriteAttrarglist (at: NtAttributes);
BEGIN
END WriteAttrarglist;
PROCEDURE WriteAttrloadln2 (at: NtAttributes);
BEGIN
END WriteAttrloadln2;

PROCEDURE EmitNtreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntreg] OF 
   | 269 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 269/2799 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$4,%esp'); AssLn;
	CheckRoundMode (RndZero);
 AssHString('	fistpl	(%esp)'); AssLn;
 AssHString('	popl	'); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 266 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 266/2755 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$4,%esp'); AssLn;
	CheckRoundMode (RndNegInf);
 AssHString('	fistpl	(%esp)'); AssLn;
 AssHString('	popl	'); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 251 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 251/2514 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 AssHString('	call	'); AssString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
   | 250 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 250/2499 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 AssHString('	call	'); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
   | 225 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 225/2150 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestOdd ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	and'); AssSuffix( e^.attr^.TestOdd.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode); AssLn;
	IF NOT e^.attr^.TestOdd.cond THEN
 AssHString('	xor'); AssSuffix( e^.attr^.TestOdd.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode); AssLn;
	END;
	
   | 224 : 
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 224/2138 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestMembershipL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	btl	'); AssAdrMode( AT0.RegOrIm.am); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
	IF e^.attr^.TestMembershipL.cond THEN
 AssHString('	setb	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	ELSE
 AssHString('	setnb	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	END;
	
   | 223 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 223/2106 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	movl	'); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	CASE e^.attr^.SetCompare.rel OF
	| RelLess:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelLessOrEqual:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelEqual;
	| RelGreater:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelGreaterOrEqual:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelEqual;
	END;
 AssHString('	cmpl	'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.SetCompare.rel][FALSE]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 222 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 222/2097 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmpl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.SetCompare.rel][FALSE]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 221 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 221/2079 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
 AssHString('	fcompl	'); AssInt ( FStackTempo[FStackStart]); AssHString('(%ebp)'); AssLn;
	  DEC (CurFStackSize);
	ELSE
 AssHString('	fcompp'); AssLn;
	  DEC (CurFStackSize, 2);
	END;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	set'); AssString( RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 220 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 220/2067 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	fcomp'); AssSuffix( e^.son[1]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	set'); AssString( RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 219 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 219/2055 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	fcomp'); AssSuffix( e^.son[2]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.FloatCompare.rel][SignedTable[e^.attr^.FloatCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 218 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 218/2047 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompare.mode); AssHString('	$'); AssInt ( e^.son[1]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
 AssHString('	set'); AssString( RelationTable[Reverse[e^.attr^.FixedCompare.rel]][SignedTable[e^.attr^.FixedCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 217 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 217/2039 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompare.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 216 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 216/2031 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompare.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedCompare.mode); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 214 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 214/1979 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
 AssHString('	cmp'); AssSuffix( e^.attr^.CheckL.LwbMode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.CheckL.LwbMode); AssLn;
 AssHString('	j'); AssString( RelationTable[RelLess][SignedTable[e^.attr^.CheckL.LwbMode]]); AssHString('	'); AssString( lab2^); AssLn;
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
 AssHString('	cmp'); AssSuffix( e^.attr^.CheckL.UpbMode); AssHString('	'); AssAdrMode( AT2.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.CheckL.UpbMode); AssLn;
 AssHString('	j'); AssString( RelationTable[RelLessOrEqual][SignedTable[e^.attr^.CheckL.UpbMode]]); AssHString('	'); AssString( lab^); AssLn;
	ELSE
 AssHString('	jmp	'); AssString( lab^); AssLn;
	END;
 AssString( lab2^); AssHString(':'); AssLn;
 AssHString('   	call	BoundErr_		'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 213 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 213/1966 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	push'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssAdrMode( AT2.RegOrCMemOrIm.am); AssLn;
 AssHString('	push'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssLn;
 AssHString('	bound'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode); AssHString(',(%esp)'); AssLn;
 AssHString('	addl	$'); AssInt ( 2*SizeTable[e^.son[1]^.gcg^.reg.mode]); AssHString(',%esp'); AssLn;
	
   | 212 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 212/1938 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
 AssHString('	.data'); AssLn;
	CASE SizeTable[e^.son[1]^.gcg^.reg.mode] OF
	| 4:
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.long	'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssHString(','); AssInt ( e^.son[3]^.gcg^.Constant.val); AssLn;
	| 2:
 AssHString('	.align 2'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.word	'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssHString(','); AssInt ( e^.son[3]^.gcg^.Constant.val); AssLn;
	END;
 AssHString('	.text'); AssLn;
 AssHString('	bound'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode); AssHString(','); AssString( lab^); AssLn;
	
   | 211 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 211/1933 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 205 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 205/1873 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 204 : 
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 204/1860 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF SignedTable[e^.attr^.Coerce.premode] AND SignedTable[e^.attr^.Coerce.postmode] THEN
 AssHString('	movs'); AssSuffix( e^.son[1]^.gcg^.RegOrCMem.mode); AssSuffix( e^.attr^.Coerce.postmode); AssHString('	'); AssAdrMode( AT0.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode); AssLn;
	ELSE
 AssHString('	movz'); AssSuffix( e^.son[1]^.gcg^.RegOrCMem.mode); AssSuffix( e^.attr^.Coerce.postmode); AssHString('	'); AssAdrMode( AT0.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode); AssLn;
	END;
	
   | 196 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 196/1777 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Trunc ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
 AssHString('	fcoml	TwoExp31_'); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jb	'); AssString( lab^); AssLn;
 AssHString('	fsubl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	subl	$4,%esp'); AssLn;
	CheckRoundMode2 (RndZero, RndNegInf);
 AssHString('	fistpl	(%esp)'); AssLn;
 AssHString('	popl	'); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 191 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 191/1727 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Cap ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 GetLabel(lab);
 AssHString('	cmpb	$'); AssInt ( ORD('a')); AssHString(','); AssByteRegister ( RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	jl	'); AssString( lab^); AssLn;
 AssHString('	cmpb	$'); AssInt ( ORD('z')); AssHString(','); AssByteRegister ( RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	jg	'); AssString( lab^); AssLn;
 AssHString('	subb	$'); AssInt ( ORD('a') - ORD('A')); AssHString(','); AssByteRegister ( RegAlloc.allocation[ai].op[1]); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 190 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtreg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 190/1705 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 GetLabel(lab);
 AssHString(' 	sub'); AssSuffix( e^.attr^.SetPlusRange.LwbMode); AssHString(' 	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( Regecx,e^.attr^.SetPlusRange.LwbMode); AssLn;
 AssHString(' 	jl	'); AssString( lab^); AssLn;
 AssHString('	incb	%cl'); AssLn;
 AssHString('	movl	$-1,'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	shll	%cl,'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	notl	'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	mov'); AssSuffix( e^.attr^.SetPlusRange.LwbMode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( Regecx,e^.attr^.SetPlusRange.LwbMode); AssLn;
 AssHString('	shll	%cl,'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	orl	'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
       
   | 189 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 189/1699 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	orl	$'); AssInt ( PowerTable[e^.son[3]^.gcg^.Constant.val+1]-PowerTable[e^.son[2]^.gcg^.Constant.val]); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 188 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 188/1693 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	btsl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 187 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 187/1687 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	orl	$'); AssInt ( PowerTable[e^.son[2]^.gcg^.Constant.val]); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 184 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 184/1664 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	xorl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 183 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 183/1664 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	xorl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssHString(' '); AssLn;
   | 180 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 180/1645 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	andl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 179 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 179/1645 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	andl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssHString(' '); AssLn;
   | 176 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 176/1610 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString(' 	andl	$'); AssInt ( INTEGER(BITSET(-1) - BITSET(e^.son[2]^.gcg^.Constant.val))); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
	
   | 175 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 175/1601 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	notl	'); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
 AssHString(' 	andl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	
   | 172 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 172/1582 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	orl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 171 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 171/1582 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	orl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssHString(' '); AssLn;
   | 152 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 152/1495 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cwd'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode); AssLn;
	
   | 151 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 151/1484 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	xor'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode); AssLn;
 AssHString('	div'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode); AssLn;
	
   | 150 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 150/1473 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cdq'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode); AssLn;
	
   | 148 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 148/1452 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	and'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	$'); AssInt ( e^.son[2]^.gcg^.Constant.val-1); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMod.mode); AssHString(' '); AssLn;
   | 146 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 146/1435 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cwd'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode); AssLn;
	
   | 145 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 145/1423 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	xor'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( Regedx,e^.attr^.FixedDiv.mode); AssHString(','); AssRegister2 ( Regedx,e^.attr^.FixedDiv.mode); AssLn;
 AssHString('	div'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode); AssLn;
	
   | 144 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 144/1411 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cdq'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode); AssLn;
	
   | 141 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 141/1380 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	sar'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	$'); AssInt ( Log2 (e^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode); AssHString(' '); AssLn;
   | 139 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 139/1357 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	shr'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	$'); AssInt ( Log2 (e^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode); AssHString(' '); AssLn;
   | 137 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 137/1341 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 136 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 136/1335 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 134 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 134/1309 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	mul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 132 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 132/1279 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

EmitIndex (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[ai].reg);
 AssHString('	mov'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssMemAdr( e^.son[1]^.son[1]^.gcg^.SimpleVariable.base); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssLn;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssLn;
	
   | 131 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 131/1273 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( e^.son[1]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 130 : 
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 130/1273 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT0.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 129 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 129/1266 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 128 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 128/1266 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 119 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 119/1198 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 118 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 118/1198 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 109 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 109/1152 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	
   | 108 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 108/1152 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	
   | 107 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 107/1145 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 106 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 106/1145 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 103 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 103/1132 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 102 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 102/1132 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 95 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 95/1082 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMinus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	sub'); AssSuffix( e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString(' '); AssLn;
   | 81 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 81/985 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	add'); AssSuffix( e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString(' '); AssLn;
   | 80 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 80/985 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	add'); AssSuffix( e^.son[1]^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.son[1]^.gcg^.RegOrCMemOrIm.mode); AssHString(' '); AssLn;
   | 62 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 62/914 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedAbs ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
 AssHString('	cmp'); AssSuffix( e^.attr^.FixedAbs.mode); AssHString('	$0,'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode); AssLn;
 AssHString('	jg	'); AssString( lab^); AssLn;
 AssHString('	neg'); AssSuffix( e^.attr^.FixedAbs.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 60 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 60/894 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedNegate ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	neg'); AssSuffix( e^.attr^.FixedNegate.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedNegate.mode); AssLn;
	
   | 37 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 37/612 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FrameBase ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 16 : 
  EmitNtRegOrCMemOrIm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 16/437 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' RegOrCMemOrIm ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	mov'); AssSuffix( e^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.gcg^.RegOrCMemOrIm.mode); AssLn;
	
   | 15 : 
  EmitNtmem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 15/430 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' mem ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	leal	'); AssMemAdr( AT0.mem.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtreg;

PROCEDURE EmitNtfreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfreg] OF 
   | 263 : 
  EmitNtreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 263/2720 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	pushl	'); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	fildl	(%esp)'); AssLn;
 AssHString('	addl	$4,%esp'); AssLn;
	
   | 262 : 
  EmitNtCMem(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 262/2705 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	fildl	'); AssMemAdr( AT0.CMem.am); AssLn;
	
   | 261 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 261/2689 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	flds	RealOne_'); AssLn;
 AssHString('	fpatan'); AssLn;
	PopFStack;
	
   | 260 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 260/2678 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fcos'); AssLn;
   | 259 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 259/2667 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsin'); AssLn;
   | 257 : 
  EmitNtloadln2(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 257/2633 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF CurFStackSize < 2 THEN
	(* Es wurde RealLn2_ zwar geladen, aber dann wegen Funktionsaufrufen *)
	(* als Tempo in den Speicher ausgelagert. Deshalb wird RealLn2_      *)
	(* hier erneut geladen, die ersten beiden Stackregister vertauscht,  *)
	(* und die Markierung als Tempo (die Speicherstelle) geloescht.      *)
	(* Im Normalfall wird durch das Nichtterminalloadln2 die Konstante   *)
	(* RealLn2_ vor (!) der Auswertung des Funktionsarguments in RegAlloc.allocation[ai].reg*)
	(* auf den Floating-Point-Stack geladen.			     *)
 AssHString('	fldl	RealLn2_'); AssLn;
 AssHString('	fxch	%st(1)'); AssLn;
	FStackTempo[FStackStart+1] := NoTempo;
	INC (CurFStackSize);
	END;
 AssHString('	fyl2x'); AssLn;
	PopFStack;
	
   | 256 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 256/2595 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	(* e^x = 2^(x * log2e) *) 
 AssHString('	fmull	RealLog2e_'); AssLn;
	(* Normierung noetig: Fuer f2xm1 muss -0.5 <= st <= +0.5 gelten *)
	(* Daher Aufteilung von x = hi + lo mit |lo| <= 0.5		*)
	(* Neues Register fuer hi, weil x noch gebraucht wird 		*)
	PushFStack;
 AssHString('	fld	%st'); AssLn;
	(* Rundung hier zur naechsten ganzen Zahl, deshalb Aenderung    *)
	(* des Steuerwortes						*)
	CheckRoundMode (RndNearest);
 AssHString('	frndint'); AssLn;
	(* Neues Register fuer lo, weil hi noch gebraucht wird 		*)
	PushFStack;
 AssHString('	fld	%st'); AssLn;
	(* Differenz von x und hi -> lo					*)
 AssHString('	fsubr	%st(2),%st'); AssLn;
	(* Berechnung von 2^lo						*)
 AssHString('	f2xm1'); AssLn;
 AssHString('	fadds	RealOne_'); AssLn;
	(* Berechnung 2^hi * 2^lo					*)
 AssHString('	fscale'); AssLn;
	(* Benutzte Register wieder poppen (und Ergebnis weitergeben)	*)
 AssHString('	fstp	%st(1)'); AssLn;
	PopFStack;
 AssHString('	fstp	%st(1)'); AssLn;
	PopFStack;
	
   | 255 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 255/2584 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsqrt'); AssLn;
   | 253 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 253/2544 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 AssHString('	call	'); AssString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	PushFStack;
	
   | 252 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 252/2529 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 AssHString('	call	'); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	PushFStack;
	
   | 215 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
  EmitNtCMem(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 215/2002 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CheckL ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
 AssHString('	fcom'); AssSuffix( e^.attr^.CheckL.LwbMode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jb	'); AssString( lab2^); AssLn;
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
 AssHString('	fcom'); AssSuffix( e^.attr^.CheckL.UpbMode); AssHString('	'); AssMemAdr( AT2.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jbe	'); AssString( lab^); AssLn;
	ELSE
 AssHString('	jmp	'); AssString( lab^); AssLn;
	END;
 AssString( lab2^); AssHString(':'); AssLn;
 AssHString('   	call	BoundErr_		'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 208 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 208/1889 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Coerce ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 193 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 193/1752 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	PushFStack;
 AssHString('	pushl	'); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	fildl	(%esp)'); AssLn;
 AssHString('	addl	$4,%esp'); AssLn;
 AssHString('	cmpl	$0x7fffffff,'); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	jbe	'); AssString( lab^); AssLn;
 AssHString('	faddl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 192 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 192/1740 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	PushFStack;
 AssHString('	fildl	'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	cmpl	$0x7fffffff,'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	jbe	'); AssString( lab^); AssLn;
 AssHString('	faddl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 170 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 170/1574 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatAbs ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fabs '); AssLn;
   | 169 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 169/1569 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fdivr'); 
   | 168 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 168/1564 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fdiv'); 
   | 167 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 167/1559 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fdivr'); AssSuffix( e^.attr^.FloatDiv.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 166 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 166/1554 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fdiv'); AssSuffix( e^.attr^.FloatDiv.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 165 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 165/1549 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fmul'); 
   | 164 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 164/1549 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fmul'); 
   | 163 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 163/1544 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fmul'); AssSuffix( e^.attr^.FloatMult.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 162 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 162/1544 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fmul'); AssSuffix( e^.attr^.FloatMult.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 161 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 161/1539 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fsub'); 
   | 160 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 160/1534 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fsubr'); 
   | 159 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 159/1529 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsubr'); AssSuffix( e^.attr^.FloatMinus.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 158 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 158/1524 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsub'); AssSuffix( e^.attr^.FloatMinus.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 157 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 157/1519 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fadd'); 
   | 156 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 156/1519 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fadd'); 
   | 155 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 155/1514 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fadd'); AssSuffix( e^.attr^.FloatPlus.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 154 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 154/1514 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fadd'); AssSuffix( e^.attr^.FloatPlus.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 153 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 153/1509 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatNegate ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fchs '); AssLn;
   | 19 : 
  EmitNtCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 19/482 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CMem ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	fld'); AssSuffix( e^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrfreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfreg;

PROCEDURE EmitNtfstack (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfstack] OF 
   | 20 : 
  EmitNtfreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 20/489 Cost=');
          WriteInt    (e^.gcg^.cost [ntfstack],1);
          WriteString (' freg ->   fstack');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF Kommentar THEN
 AssHString('					/* Kettenregel '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' -> '); AssRegister(RegAlloc.allocation[ai].reg); AssHString(' */'); AssLn;
	END;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrfstack (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfstack;

PROCEDURE EmitNtConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntConstant] OF 
   | 270 : 
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 270/2813 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 267 : 
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 267/2771 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 198 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 198/1815 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Coerce ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 195 : 
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 195/1770 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Trunc ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 147 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 147/1447 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMod ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 143 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 143/1403 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 135 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 135/1330 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 101 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 101/1127 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 100 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 100/1127 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 99 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 99/1123 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 98 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 98/1115 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 87 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 87/1033 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 63 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 63/927 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedPlus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 61 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 61/902 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedAbs ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 59 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 59/890 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedNegate ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 30 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 30/536 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' NilConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 29 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 29/532 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' SetConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 28 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 28/527 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' BoolConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 27 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 27/523 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' CharConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 24 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 24/511 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 23 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 23/507 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 22 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 22/503 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 21 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 21/499 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrConstant (resAttributes);
       WriteLn;
   END;
END EmitNtConstant;

PROCEDURE EmitNtFloatConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntFloatConstant] OF 
   | 265 : 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 265/2747 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 264 : 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 264/2737 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 207 : 
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 207/1884 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 206 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 206/1879 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 194 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 194/1766 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Float ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 26 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 26/519 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' LongRealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 25 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 25/515 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' RealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrFloatConstant (resAttributes);
       WriteLn;
   END;
END EmitNtFloatConstant;

PROCEDURE EmitNtSimpleVariable (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntSimpleVariable] OF 
   | 117 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 117/1182 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 116 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1]^.son[1],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 116/1182 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 115 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 115/1182 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 114 : 
  EmitNtConstant(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[1]^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 114/1182 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 94 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 94/1077 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedMinus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 79 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 79/980 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 78 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 78/980 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 40 : 
  EmitNtConstant(e^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 40/626 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 SaveDisplay [e^.son[1]^.attr^.FrameBase.level] := TRUE; 
   | 39 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 39/626 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 SaveDisplay [e^.son[2]^.attr^.FrameBase.level] := TRUE; 
   | 35 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 35/571 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' StaticVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 33 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 33/551 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' LocalVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrSimpleVariable (resAttributes);
       WriteLn;
   END;
END EmitNtSimpleVariable;

PROCEDURE EmitNtSymPlusOffset (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntSymPlusOffset] OF 
   | 199 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 199/1820 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Coerce ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 88 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 88/1037 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedMinus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 65 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 65/931 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 64 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 64/931 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol; 
   | 36 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 36/583 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StaticVariable ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StaticVariable.module^.Statics; 
   | 32 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 32/544 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StringAddr ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StringAddr.index; 
   | 31 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 31/540 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' ProcedureConstant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.ProcedureConstant.index^.Entry; 
   | 1 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 1/332 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Constant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= NullSymb; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtSymPlusOffset;

PROCEDURE EmitNtRegPlusSymPlusOffset (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegPlusSymPlusOffset] OF 
   | 200 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 200/1826 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' Coerce ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 91 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 91/1057 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 90 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 90/1047 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
	resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
 AssHString('	mov'); AssSigned( e^.son[1]^.gcg^.reg.mode); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('l	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
	
   | 89 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 89/1041 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb; 
   | 71 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 71/951 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 70 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 70/951 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.RegPlusSymPlusOffset.symbol; 
   | 69 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 69/941 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[2];
	resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
 AssHString('	mov'); AssSigned( e^.son[2]^.gcg^.reg.mode); AssSuffix( e^.son[2]^.gcg^.reg.mode); AssHString('l	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.son[2]^.gcg^.reg.mode); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	
   | 68 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 68/941 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
	resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol;
 AssHString('	mov'); AssSigned( e^.son[1]^.gcg^.reg.mode); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('l	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
	
   | 67 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 67/935 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[2];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 66 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 66/935 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol; 
   | 34 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 34/563 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' LocalVariable ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= Regebp;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb; 
   | 4 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 4/347 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
 AssHString('	mov'); AssSigned( e^.gcg^.reg.mode); AssSuffix( e^.gcg^.reg.mode); AssHString('l	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.gcg^.reg.mode); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
	
   | 3 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 3/341 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	  resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1]; 
   | 2 : 
  EmitNtSymPlusOffset(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 2/336 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' SymPlusOffset ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegNil;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegPlusSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtRegPlusSymPlusOffset;

PROCEDURE EmitNtOffsetPlusIndexMultFaktor (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntOffsetPlusIndexMultFaktor] OF 
   | 201 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 201/1833 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' Coerce ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 138 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 138/1346 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedDiv ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index; 
   | 111 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 111/1162 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index; 
   | 110 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 110/1162 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT1.OffsetPlusIndexMultFaktor.index; 
   | 92 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 92/1062 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMinus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 73 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 73/956 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 72 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 72/956 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT1.OffsetPlusIndexMultFaktor.index; 
   | 6 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 6/363 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	resAttributes.OffsetPlusIndexMultFaktor.index		:= RegAlloc.allocation[ai].op[1];
 AssHString('	mov'); AssSigned( e^.gcg^.reg.mode); AssSuffix( e^.gcg^.reg.mode); AssHString('l	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.gcg^.reg.mode); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
	
   | 5 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 5/357 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrOffsetPlusIndexMultFaktor (resAttributes);
       WriteLn;
   END;
END EmitNtOffsetPlusIndexMultFaktor;

PROCEDURE EmitNtmem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntmem] OF 
   | 202 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 202/1840 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' Coerce ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 127 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 127/1251 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val DIV 9)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 126 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 126/1251 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val DIV 9)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 125 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 125/1236 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val DIV 5)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 124 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 124/1236 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val DIV 5)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 123 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 123/1221 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val DIV 3)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 122 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 122/1221 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val DIV 3)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 113 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 113/1171 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb; 
   | 112 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 112/1171 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb; 
   | 93 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 93/1068 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMinus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset - e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 77 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 77/971 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset + e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 76 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 76/971 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT1.mem.am.offset + e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT1.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT1.mem.am.base;
	  resAttributes.mem.am.index	:= AT1.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT1.mem.am.symbol; 
   | 75 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 75/962 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT1.RegPlusSymPlusOffset.symbol; 
   | 74 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 74/962 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 8 : 
  EmitNtOffsetPlusIndexMultFaktor(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 8/382 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' OffsetPlusIndexMultFaktor ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  resAttributes.mem.am.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= RegNil;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= NullSymb; 
   | 7 : 
  EmitNtRegPlusSymPlusOffset(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 7/373 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' RegPlusSymPlusOffset ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= 1;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= RegNil;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrmem (resAttributes);
       WriteLn;
   END;
END EmitNtmem;

PROCEDURE EmitNtCMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntCMem] OF 
   | 210 : 
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 210/1909 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
 AssHString('	mov'); AssSuffix( e^.attr^.Coerce.premode); AssHString('	'); AssAdrMode( AT0.RegOrIm.am); AssHString(','); AssMemAdr( resAttributes.CMem.am); AssLn;
	
   | 209 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 209/1893 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
 AssHString('	fstp'); AssSuffix( e^.attr^.Coerce.premode); AssHString('	'); AssMemAdr( resAttributes.CMem.am); AssLn;
	PopFStack;
	
   | 203 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 203/1851 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am.offset	:= AT0.CMem.am.offset;
	  resAttributes.CMem.am.faktor	:= AT0.CMem.am.faktor;
	  resAttributes.CMem.am.base	:= AT0.CMem.am.base;
	  resAttributes.CMem.am.index	:= AT0.CMem.am.index;
	  resAttributes.CMem.am.symbol	:= AT0.CMem.am.symbol; 
   | 41 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 41/681 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Content ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am	 := AT0.mem.am; 
   | 38 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 38/616 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FrameBase ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am.offset	:= 4*e^.attr^.FrameBase.level;
	  resAttributes.CMem.am.faktor	:= 0;
	  resAttributes.CMem.am.base	:= RegNil;
	  resAttributes.CMem.am.index	:= RegNil;
	  resAttributes.CMem.am.symbol	:= DisplaySym;
	  SaveDisplay [e^.attr^.FrameBase.level] := TRUE; 
   | 18 : 
  EmitNtFloatConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 18/463 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr2.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
 AssHString('	.data'); AssLn;
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.long	'); AssInt ( tr2.c2); AssHString(','); AssInt ( tr2.c1); AssHString('		# '); AssString( str); AssLn;
 AssHString('	.text'); AssLn;
	
   | 17 : 
  EmitNtFloatConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 17/444 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr1.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
 AssHString('	.data'); AssLn;
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.long	'); AssInt ( tr1.c); AssHString('		# '); AssString( str); AssLn;
 AssHString('	.text'); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtCMem;

PROCEDURE EmitNtRegOrIm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrIm] OF 
   | 13 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 13/418 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' Constant ->   RegOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrIm.am.kind  := Mconst;
	  resAttributes.RegOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrIm.am.constant := e^.gcg^.Constant.val; 
   | 9 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 9/391 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' reg ->   RegOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrIm.am.kind := Mreg;
	  resAttributes.RegOrIm.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrIm.am.reg  := RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrIm;

PROCEDURE EmitNtRegOrCMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrCMem] OF 
   | 11 : 
  EmitNtCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 11/403 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' CMem ->   RegOrCMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMem.am.kind := Mmem;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.CMem.mode;
	  resAttributes.RegOrCMem.am.mem  := AT0.CMem.am; 
   | 10 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 10/397 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' reg ->   RegOrCMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMem.am.kind := Mreg;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrCMem.am.reg  := RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMem;

PROCEDURE EmitNtRegOrCMemOrIm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrCMemOrIm] OF 
   | 14 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 14/424 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' Constant ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMemOrIm.am.kind  := Mconst;
	  resAttributes.RegOrCMemOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrCMemOrIm.am.constant := e^.gcg^.Constant.val; 
   | 12 : 
  EmitNtRegOrCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 12/409 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' RegOrCMem ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMemOrIm.am.kind := AT0.RegOrCMem.am.kind;
	  resAttributes.RegOrCMemOrIm.am.mode := e^.gcg^.RegOrCMem.mode;
	  IF AT0.RegOrCMem.am.kind = Mreg
	    THEN resAttributes.RegOrCMemOrIm.am.reg := AT0.RegOrCMem.am.reg;
	    ELSE resAttributes.RegOrCMemOrIm.am.mem := AT0.RegOrCMem.am.mem;
	  END; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrCMemOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMemOrIm;

PROCEDURE EmitNtarglist (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntarglist] OF 
   | 247 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 247/2463 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$'); AssInt ( e^.attr^.PassLong.space); AssHString(',%esp'); AssLn;
 AssHString('	movl	%esp,%edi'); AssLn;
 AssHString('	movl	$'); AssInt ( (e^.attr^.PassLong.size + 3) DIV 4); AssHString(',%ecx'); AssLn;
 AssHString('	cld'); AssLn;
 AssHString('	repz'); AssLn;
 AssHString('	movsl'); AssLn;
	
   | 246 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 246/2453 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF e^.attr^.PassLong.space > 4 THEN
 AssHString('	subl	$'); AssInt ( e^.attr^.PassLong.space - 4); AssHString(',%esp'); AssLn;
	END;	
 AssHString('	pushl	'); AssMemAdr( AT1.mem.am); AssLn;
	
   | 245 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 245/2444 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$'); AssInt ( SizeTable[e^.attr^.Pass.mode]); AssHString(',%esp'); AssLn;
 AssHString('	fstp'); AssSuffix( e^.attr^.Pass.mode); AssHString('	(%esp)'); AssLn;
	PopFStack;
	
   | 244 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 244/2434 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	INC (AT1.CMem.am.offset, 4);
 AssHString('	pushl	'); AssMemAdr( AT1.CMem.am); AssLn;
	DEC (AT1.CMem.am.offset, 4);
 AssHString('	pushl	'); AssMemAdr( AT1.CMem.am); AssLn;
	
   | 243 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 243/2428 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	pushl	$'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssLn;
	
   | 242 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 242/2410 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	pushl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssLn;
	
   | 241 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 241/2408 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Nil ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrarglist (resAttributes);
       WriteLn;
   END;
END EmitNtarglist;

PROCEDURE EmitNtloadln2 (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR

BEGIN
   CASE e^.gcg^.rule [ntloadln2] OF 
   | 258 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 258/2660 Cost=');
          WriteInt    (e^.gcg^.cost [ntloadln2],1);
          WriteString (' Nil ->   loadln2');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	fldl	RealLn2_'); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrloadln2 (resAttributes);
       WriteLn;
   END;
END EmitNtloadln2;

PROCEDURE EmitStatement (e : IR.Expression);
CONST nest = 0;  
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

VAR   i        : INTEGER;
BEGIN
   ai := RegAlloc.ai;
   IF e^.gcg^.stmtcost >= IR.infcost THEN 
     (*************** Compiler Error ******************)
     (******** No code selected, no cover found *******)
     WriteString ('no code selected'); WriteLn;
     IR.PrintInstrCosts (e);
     WriteLn;
     IR.Error ('internal error');
     i := 0; i := 1 DIV i; HALT;
   ELSE
     CASE e^.gcg^.stmtrule OF 
     | 42 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 42/688 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	mov'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 43 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 43/693 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	fstp'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( AT0.mem.am); AssLn;
	PopFStack;
	
     | 44 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 44/701 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr1.r := e^.son[2]^.gcg^.FloatConstant.val;
 AssHString('	movl	$'); AssInt ( tr1.c); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 45 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 45/709 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr2.r := e^.son[2]^.gcg^.FloatConstant.val;
 AssHString('	movl	$'); AssInt ( tr2.c2); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT0.mem.am.offset, 4);
 AssHString('	movl	$'); AssInt ( tr2.c1); AssHString(','); AssMemAdr( AT0.mem.am); AssHString('	'); AssLn;
	
     | 46 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 46/719 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	'); AssMemAdr( AT1.CMem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 47 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 47/728 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	'); AssMemAdr( AT1.CMem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT0.mem.am.offset, 4);
	INC (AT1.CMem.am.offset, 4);
 AssHString('	movl	'); AssMemAdr( AT1.CMem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 48 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 48/741 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 49 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 49/765 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	leal	'); AssMemAdr( AT1.mem.am); AssHString(',%esi'); AssLn;
 AssHString('	leal	'); AssMemAdr( AT0.mem.am); AssHString(',%edi'); AssLn;
	IF AT0.mem.am.offset MOD 4 >= 1 THEN
	  DEC (e^.attr^.AssignLong.size, 4-(AT0.mem.am.offset MOD 4));
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
 AssHString('	movl	$'); AssInt ( e^.attr^.AssignLong.size DIV 4); AssHString(',%ecx'); AssLn;
	END;
 AssHString('	cld'); AssLn;
	IF AT0.mem.am.offset MOD 2 = 1 THEN
 AssHString('	movsb'); AssLn;
	END;
	IF (AT0.mem.am.offset MOD 4 = 1) OR (AT0.mem.am.offset MOD 4 = 2) THEN
 AssHString('	movsw'); AssLn;
	END;
	IF e^.attr^.AssignLong.size >= 8 THEN
 AssHString('	repz'); AssLn;
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
 AssHString('	movsl'); AssLn;
	END;
	IF e^.attr^.AssignLong.size MOD 4 >= 2 THEN
 AssHString('	movsw'); AssLn;
	END;
	IF e^.attr^.AssignLong.size MOD 2 >= 1 THEN
 AssHString('	movsb'); AssLn;
	END;
	
     | 50 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 50/799 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.AssignLong.size >= 4 THEN
 AssHString('	movl	'); AssMemAdr( AT1.mem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT1.mem.am.offset, 4);
	INC (AT0.mem.am.offset, 4);
	DEC (e^.attr^.AssignLong.size, 4);
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
 AssHString('	movl	'); AssMemAdr( AT1.mem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT1.mem.am.offset, 4);
	INC (AT0.mem.am.offset, 4);
	DEC (e^.attr^.AssignLong.size, 4);
	END;
	IF e^.attr^.AssignLong.size DIV 2 > 0 THEN
 AssHString('	movw	'); AssMemAdr( AT1.mem.am); AssHString(','); AssWordRegister ( RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movw	'); AssWordRegister ( RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT1.mem.am.offset, 2);
	INC (AT0.mem.am.offset, 2);
	END;
	IF e^.attr^.AssignLong.size MOD 2 > 0 THEN
 AssHString('	movb	'); AssMemAdr( AT1.mem.am); AssHString(','); AssByteRegister ( RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movb	'); AssByteRegister ( RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	END;
	
     | 51 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 51/830 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc1');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	inc'); AssSuffix( e^.attr^.Inc1.mode); AssHString('	'); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 52 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 52/834 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec1');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	dec'); AssSuffix( e^.attr^.Dec1.mode); AssHString('	'); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 53 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 53/838 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc2');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	add'); AssSuffix( e^.attr^.Inc2.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 54 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 54/842 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec2');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	sub'); AssSuffix( e^.attr^.Dec2.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 55 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 55/857 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' InclL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	btsl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 56 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 56/874 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ExclL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	btrl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 57 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 57/881 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipAddress');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 58 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 58/884 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipData');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 82 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 82/991 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	inc'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 83 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 83/991 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	inc'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 84 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 84/1005 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	add'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 85 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 85/1005 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	add'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 86 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 86/1018 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shl'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$1, '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 96 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 96/1088 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	dec'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 97 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 97/1102 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	sub'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 104 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 104/1137 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 105 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 105/1137 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 120 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 120/1206 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shl'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[1]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 121 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 121/1206 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shl'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 133 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 133/1292 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	mov'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssLn;
 AssHString('	imul'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssLn;
 AssHString('	mov'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 140 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 140/1365 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shr'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 142 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 142/1388 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	sar'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 149 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 149/1459 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	and'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( e^.son[2]^.son[2]^.gcg^.Constant.val-1); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 173 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 173/1588 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	orl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 174 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 174/1588 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	orl	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 177 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtreg(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 177/1618 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	notl	'); AssRegister(RegAlloc.allocation[1].op[3]); AssLn;
 AssHString(' 	andl	'); AssRegister(RegAlloc.allocation[1].op[3]); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 178 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 178/1632 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString(' 	andl	$'); AssInt ( INTEGER(BITSET(-1) - BITSET(e^.son[2]^.son[2]^.gcg^.Constant.val))); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 181 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 181/1651 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	andl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 182 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 182/1651 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	andl	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 185 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 185/1670 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	xorl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 186 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 186/1670 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	xorl	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 197 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 197/1796 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel(lab);
 AssHString('	fcoml	TwoExp31_'); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jb	'); AssString( lab^); AssLn;
 AssHString('	fsubl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	CheckRoundMode2 (RndZero, RndNegInf);
 AssHString('	fistpl	'); AssMemAdr( AT0.mem.am ); AssLn;
	PopFStack;
	
     | 226 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 226/2163 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' PlaceLabel');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssString( e^.attr^.PlaceLabel.lab^); AssHString(':'); AssLn;
	
     | 227 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 227/2170 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Goto');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	jmp	'); AssString( e^.attr^.Goto.tar^); AssLn;
	
     | 228 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 228/2177 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SwitchL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel (lab);
 AssHString('	.data'); AssLn;
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	WHILE e^.attr^.SwitchL.CaseLabels # NIL DO
 AssHString('	.long	'); AssString( e^.attr^.SwitchL.CaseLabels^.label^); AssLn;
	  e^.attr^.SwitchL.CaseLabels := e^.attr^.SwitchL.CaseLabels^.next;
	END;
 AssHString('	.text'); AssLn;
	CurRoundMode := RndUnknown;
 AssHString('	sub'); AssSuffix( e^.attr^.SwitchL.mode); AssHString('	$'); AssInt ( e^.attr^.SwitchL.lwb); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode); AssLn;
 AssHString('	j'); AssString( RelationTable[RelLess][SignedTable[e^.attr^.SwitchL.mode]]); AssHString('	'); AssString( e^.attr^.SwitchL.DefaultLabel^); AssLn;
 AssHString('	cmp'); AssSuffix( e^.attr^.SwitchL.mode); AssHString('	$'); AssInt ( e^.attr^.SwitchL.upb - e^.attr^.SwitchL.lwb); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode); AssLn;
 AssHString('	j'); AssString( RelationTable[RelGreater][SignedTable[e^.attr^.SwitchL.mode]]); AssHString('	'); AssString( e^.attr^.SwitchL.DefaultLabel^); AssLn;
 AssHString('	jmp	'); AssString( lab^); AssHString('(,'); AssRegister(RegAlloc.allocation[1].op[1]); AssHString(',4)'); AssLn;
	
     | 229 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 229/2198 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
	CurRoundMode := RndUnknown;
 AssHString('	cmpb	$'); AssInt ( k); AssHString(','); AssByteRegister ( RegAlloc.allocation[1].op[1]); AssLn;
 AssHString('	je	'); AssString( e^.attr^.TestAndBranch.tar^); AssLn;
	
     | 230 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 230/2207 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
	CurRoundMode := RndUnknown;
 AssHString('	cmpb	$'); AssInt ( k); AssHString(','); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	je	'); AssString( e^.attr^.TestAndBranch.tar^); AssLn;
	
     | 231 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 231/2216 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompareAndBranch.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.FixedCompareAndBranch.mode); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FixedCompareAndBranch.tar^); AssLn;
	
     | 232 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 232/2224 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompareAndBranch.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FixedCompareAndBranch.tar^); AssLn;
	
     | 233 :
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 233/2232 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompareAndBranch.mode); AssHString('	$'); AssInt ( e^.son[1]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
 AssHString('	j'); AssString( RelationTable[Reverse[e^.attr^.FixedCompareAndBranch.rel]][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FixedCompareAndBranch.tar^); AssLn;
	
     | 234 :
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 234/2240 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	fcomp'); AssSuffix( e^.son[2]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.FloatCompareAndBranch.rel][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FloatCompareAndBranch.tar^); AssLn;
	PopFStack;
	
     | 235 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 235/2252 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	fcomp'); AssSuffix( e^.son[1]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	j'); AssString( RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FloatCompareAndBranch.tar^); AssLn;
	PopFStack;
	
     | 236 :
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 236/2264 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
 AssHString('	fcompl	'); AssInt ( FStackTempo[FStackStart]); AssHString('(%ebp)'); AssLn;
	  DEC (CurFStackSize);
	ELSE
 AssHString('	fcompp'); AssLn;
	  DEC (CurFStackSize, 2);
	END;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	j'); AssString( RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FloatCompareAndBranch.tar^); AssLn;
	
     | 237 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 237/2282 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	cmpl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].op[1]); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]); AssHString('	'); AssString( e^.attr^.SetCompareAndBranch.tar^); AssLn;
	
     | 238 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 238/2291 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].op[1]); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	CASE e^.attr^.SetCompareAndBranch.rel OF
	| RelLess:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelLessOrEqual:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	| RelGreater:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelGreaterOrEqual:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	END;
 AssHString('	cmpl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssRegister(RegAlloc.allocation[1].op[1]); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]); AssHString('	'); AssString( e^.attr^.SetCompareAndBranch.tar^); AssLn;
	
     | 239 :
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 239/2323 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestMembershipAndBranchL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	btl	'); AssAdrMode( AT0.RegOrIm.am); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
	IF e^.attr^.TestMembershipAndBranchL.cond THEN
 AssHString('	jc	'); AssString( e^.attr^.TestMembershipAndBranchL.tar^); AssLn;
	ELSE
 AssHString('	jnc	'); AssString( e^.attr^.TestMembershipAndBranchL.tar^); AssLn;
	END;
	
     | 240 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 240/2335 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestOddAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	and'); AssSuffix( e^.attr^.TestOddAndBranch.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode); AssLn;
	IF NOT e^.attr^.TestOddAndBranch.cond THEN
 AssHString('	xor'); AssSuffix( e^.attr^.TestOddAndBranch.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode); AssLn;
	END;
 AssHString('	jnz	'); AssString( e^.attr^.TestOddAndBranch.tar^); AssLn;
	
     | 248 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 248/2475 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	call	'); AssRegister(RegAlloc.allocation[1].op[2]); AssLn;
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN 
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.ProcedureCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
     | 249 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 249/2487 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 AssHString('	call	'); AssString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^); AssLn;
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN 
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.ProcedureCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
     | 254 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 254/2559 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' RTSCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
	CASE e^.attr^.RTSCall.sysproc OF 
	      | SysProcHALT : 
 AssHString('	call	exit_'); AssLn;
	      | SysProcTransfer : 
 AssHString('	call	Transfer_'); AssLn;
	      | SysProcNewprocess : 
 AssHString('	call	NewProcess_'); AssLn;
	      | SysProcCaseError : 
 AssHString('	call	CaseErr_'); AssLn;
	      | SysProcReturnError : 
 AssHString('	call	ReturnErr_'); AssLn;
	END;
	IF e^.attr^.RTSCall.paramsize # 0 THEN 
	(* e^.attr^.RTSCall.paramsize := (e^.attr^.RTSCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.RTSCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
     | 268 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 268/2783 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CheckRoundMode (RndNegInf);
 AssHString('	fistpl	'); AssMemAdr( AT0.mem.am); AssLn;
	PopFStack;
	
     | 271 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 271/2823 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CheckRoundMode (RndZero);
 AssHString('	fistpl	'); AssMemAdr( AT0.mem.am); AssLn;
	PopFStack;
	
     | 272 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 272/2840 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' BeginProcedure');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   UndefOperand := IR.emptyExpression;
   CurLevel := e^.attr^.BeginProcedure.level;
   CurFrameSize := 4 * ((ABS(e^.attr^.BeginProcedure.FrameSize)+3) DIV 4);
   CurRoundMode := RndUnknown;
   IF CurLevel > MaxDisplay THEN 
      ERROR ('too many nested procedures', CurPos);
      CurLevel := 0;
   END;
   CurFStackSize := 0;
   FStackStart := MaxFloatTempo;
   TransferTempo := NoTempo;

(* -------------------------------------------------------------------- *)
(* Die Daten werden bei Prozeduren wie folgt auf dem Stack abgelegt :	*)
(*		------------------------- <--- Stackanfang (MaxAdr)	*)
(*		|			|				*)
(*		|	.......		|				*)
(*		|			|				*)
(*	    .	|-----------------------|				*)
(*	    .	|	Parameter	|				*)
(*	    .	| (bei OpenArrays nur	|				*)
(*	    8	|  Adresse und Laenge)	|				*)
(*		|-----------------------|				*)
(*	    4	|    Return-Adresse	|				*)
(*		|-----------------------|				*)
(*	    0	|   alter BasePointer   | <--- BasePointer (ebp)	*)
(*		|-----------------------|   )				*)
(*	   -4	| alter DV [CurLevel]	|   )				*)
(*		|-----------------------|   )				*)
(*	   -8	| lokale Variablen	|   )  Activation Record (AR)	*)
(*	    .	|-----------------------|   )				*)
(*	    .	| evtl.temporaere Werte	|   )				*)
(*	    .	|-----------------------|   )				*)
(*		| evtl. OpenArrays	|   )				*)
(*		|-----------------------|   )				*)
(*		| Platz fuer Sicherungen|   )				*)
(*		|-----------------------| <--- StackPointer (esp)	*)
(*									*)
(* Der DisplayVector DV enthaelt jeweils den aktuellen BP der zuletzt	*)
(* auf dem jeweiligen Level ausgefuehrten Prozedur.			*)
(* Der DisplayVector steht ab der Stelle DISPLAY_ im Speicher,		*)
(* durch das sich die Adresse vom DisplayVector des Levels i, also	*)
(* DV [i], als DISPLAY_ + i*4 errechnen laesst.				*)
(* Aus Optimierungsgruenden wird jedoch der DV nicht in jedem Level	*)
(* gespeichert und geladen, sondern nur, falls eine Prozedur des Levels *)
(* i auf eine nicht-globale Variable des Levels j (j < i) zugreift.	*)
(* -------------------------------------------------------------------- *)

(* Zunaechst den Label bestimmen, an dem der die Groesse des Activation *)
(* Records bei EndProcedure gespeichert wird. Diese kann durch die un-	*)
(* gewisse Zahl der benoetigten temporaeren Werte erst am Schluss	*)
(* bestimmt werden.							*)
	GetLabel (ProcLabel);
(* Startlabel der Prozedur eintragen *)
 AssHString('	.align 4'); AssLn;
 AssString( e^.attr^.BeginProcedure.index^.Entry^); AssHString(':'); AssLn;
(* Alten BP sichern *)
 AssHString('	pushl	%ebp'); AssLn;
(* Neuer BP fuer neuen Activation Record *)
 AssHString('	movl	%esp,%ebp'); AssLn;
(* Platz fuer alten DisplayVector[CurLevel], lokale Variablen und	*)
(* temporaere Werte schaffen.						*)
 AssHString('	subl	$'); AssString( ProcLabel^); AssHString(', %esp'); AssLn;
     IF SaveDisplay [CurLevel] THEN
(* Aktualisieren des DisplayVectors,  wird fuer andere Prozedur benoetigt. *)
(* Laden des momentanen DisplayVectors [CurLevel] *)
 AssHString('	movl	DISPLAY_+'); AssInt ( 4 * CurLevel); AssHString(',%ecx'); AssLn;
(* Sichern des alten Wertes des DisplayVectors [CurLevel] *)
 AssHString('	movl	%ecx,-4(%ebp)'); AssLn;
(* Schreiben des aktuellen DisplayVectors [CurLevel] *)
 AssHString('	movl	%ebp,DISPLAY_+'); AssInt ( 4 * CurLevel); AssLn;
     END;

(* !!!!!!!!!! Registersicherung bei Funktionsaufrufen !!!!!!!!!!
   Linux/BSD: edi, esi, ebx werden in aufgerufener Funktion gesichert,
	      ecx, edx werden in aufrufender Funktion gesichert,
	      eax oder st behinhaltet den Rueckgabewert
   MOCKA:     edi, esi, ebx, ecx, edx werden in aufrufender Funktion gesichert,
	      eax oder st behinhaltet den Rueckgabewert
   Dieser Unterschied ist unwesentlich bei Aufruf von C-Funktionen
   (z.B. libc) aus MOCKA-Programmen. Im umgekehrten Fall (Aufruf von MOCKA-
   Funktionen von C aus, z.B. von atexit-Funktionen) fuehrt dies zu Fehlern.
   Abhilfe: Die CcallsMocka Option
   Diese sichert immer edi, esi, ebx, egal ob sie veraendert werden oder
   nicht (was genau geaendert wird, weiss man bei einem 1-Pass Compiler
   leider nicht). Dies ist im Normalfall ueberfluessig, und sollte daher
   aus Performancegruenden auf die Funktionen beschraenkt werden, die
   von C aus aufgerufen werden.						*)
     IF Enabled (oCCall) THEN
 AssHString('	pushl %edi'); AssLn;
 AssHString('	pushl %esi'); AssLn;
 AssHString('	pushl %ebx'); AssLn;
     END;

     IF Kommentar THEN
 AssHString('	/* --------------------------------------------------------- */'); AssLn;
 AssHString('	/* Level : '); AssInt ( CurLevel); AssHString(' */'); AssLn;
 AssHString('	/* --------------------------------------------------------- */'); AssLn;
     END;
	
     | 273 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 273/2944 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' CopyOpenArray');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF Kommentar THEN
 AssHString('	/* Copy Open Array Begin */'); AssLn;
	END;
   IF (e^.attr^.CopyOpenArray.elemsize # ByteSize) & ODD (e^.attr^.CopyOpenArray.elemsize) THEN INC (e^.attr^.CopyOpenArray.elemsize); END;
   (* Lade letzten Index (= Laenge - 1) des Stringparameter *)
 AssHString('	movl	'); AssInt ( e^.attr^.CopyOpenArray.HighOffset); AssHString('(%ebp),%ecx'); AssLn;
   (* Bestimme Laenge des Stringparameters *)
 AssHString('	incl	%ecx'); AssLn;
   (* Ermittle Platzbedarf fuer den Stringparameter.			*)
   (* Das Resultat steht in Register ecx.				*)
      IF e^.attr^.CopyOpenArray.elemsize # ByteSize THEN
      (* Multiplikation Elementanzahl * Elementgroesse = Platzbedarf	*)
      (* durchfuehren.							*)
	 IF IsPowerOfTwo (e^.attr^.CopyOpenArray.elemsize) THEN
 AssHString('	shll	$'); AssInt ( Log2 (e^.attr^.CopyOpenArray.elemsize)); AssHString(', %ecx'); AssLn;
	 ELSE
 AssHString('	imull	$'); AssInt ( e^.attr^.CopyOpenArray.elemsize); AssHString(',%ecx'); AssLn;
	 END
      END;
   (* Platzbedarf auf durch 4 teilbare Adresse aufrunden *)
 AssHString('	addl	$3,%ecx'); AssLn;
 AssHString('	andl	$0xfffffffc, %ecx'); AssLn;
   (* Schaffe auf dem Stack entsprechenden Platz *)
 AssHString('	subl 	%ecx,%esp'); AssLn;
   (* Startadresse des zu kopierenden ARRAYs				*)
 AssHString('	movl	%esp,%edi'); AssLn;
   (* Lade Startadresse des OpenArrays *)
 AssHString('	movl	'); AssInt ( e^.attr^.CopyOpenArray.DataOffset); AssHString('(%ebp),%esi'); AssLn;
    (* Ersetze im Parameterteil der Prozedur die Startadresse des Parameter-
       strings durch die Adresse dessen Kopie auf das OpenArray         *)
 AssHString('	movl	%edi,'); AssInt ( e^.attr^.CopyOpenArray.DataOffset); AssHString('(%ebp)'); AssLn;
     (* Kopiere Stringparameter in den OpenArray-Platz der Prozedur     *)
     (* Register ecx enthaelt die Groesse				*)
     (* Register esi die Quelladresse,					*)
     (* Register edi die Zieladresse.					*)
 AssHString('	shrl	$2,%ecx'); AssLn;
 AssHString('	cld'); AssLn;
 AssHString('	repz'); AssLn;
 AssHString('	movsl'); AssLn;
	IF Kommentar THEN
 AssHString('	/* Copy Open Array End */'); AssLn;
	END;
	
     | 274 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 274/2992 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Return');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 
	IF (CurFStackSize <> 0) AND OK THEN
 AssHString('	ERROR: CurFStackSize <> 0'); AssLn;
	AssClose;
	CompilerError ("Something's going wrong in fp expression");
	END;	
	CurRoundMode := RndUnknown;
	IF SaveDisplay [CurLevel] THEN
	(* Alten Wert von DisplayVector [CurLevel] laden, wurde veraendert *)
 AssHString('	movl	-4(%ebp),%ecx'); AssLn;
	(* Diesen Wert wieder in DisplayVector [CurLevel] eintragen *)
 AssHString('	movl	%ecx,DISPLAY_+'); AssInt ( 4 * CurLevel); AssLn;
	END;
	(* Bei Aufruf von MOCKA Prozeduren von C Programmen 
	   (z.B. atexitHandler) muessen diese in BeginProcedure
	   gesicherten Register wiederhergestellt werden. *)
	IF Enabled (oCCall) THEN
 AssHString('	popl %ebx'); AssLn;
 AssHString('	popl %esi'); AssLn;
 AssHString('	popl %edi'); AssLn;
	END;
	(* Ruecksprung aus der Prozedur *)
 AssHString('	leave'); AssLn;
 AssHString('	ret'); AssLn;
	
     | 275 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 275/3025 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 276 :
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 276/3028 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	PopFStack;
	
     | 277 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 277/3034 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndProcedure');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	SaveDisplay [CurLevel] := FALSE; 
	CurFrameSize :=   4 * ((ABS(CurFrameSize)+3) DIV 4);
 AssHString('	'); AssString( ProcLabel^); AssHString(' = '); AssInt ( CurFrameSize); AssLn;
	
     | 278 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 278/3044 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndModule');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   AssClose;
   IF OK (* no Errors *) THEN 
      StringAssign  (cmd, 'cd '); 
      StringAppend2 (cmd, LibraryDirectory, '; ');
      StringAppend1 (cmd, AssemblerScript);
      IF Enabled (ElfOption) THEN
	 StringAppend1 (cmd,' -elf');
      END;
      IF Enabled (DebugOption) THEN
	 StringAppend1 (cmd,' -g');
      END;
      StringAppend2 (cmd, ' ', ModName); 
      SystemCommand (cmd,ok);
      IF NOT ok THEN 
	 WriteString ("Assembler terminated with error"); WriteLn;
	 exit (1);
      END;
   END;
   IF NOT Enabled (oAssemblerListing) THEN
      Erase (AsmListFileName,ok);
   END;
	
     | 279 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 279/3070 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Mark');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CurPos.line := e^.attr^.Mark.line; CurPos.col := e^.attr^.Mark.col; 
    END;
  END;
END EmitStatement;

PROCEDURE EmitInstruction (e : IR.Expression);
BEGIN
   IF IR.OptEmitIR THEN IR.PrintExpression (e); END;
(*++++++ start insertion IpEmitI1 ++++++*)

      localavail[0] := { ORD (Regeax)-0,  ORD (Regebx)-0,  ORD (Regecx)-0,  ORD (Regedx)-0,  ORD (Regesi)-0,  ORD (Regedi)-0,  ORD (Regst)-0, ORD (Regst1)-0};


(*------ end   insertion IpEmitI1 ------*)
   RegAlloc.RegAllo (e, localavail);
(******* empty insertion IpEmitI2 *******)
   EmitStatement (e);
END EmitInstruction;
 VAR  RegisterSetEmpty : RegisterSet;
BEGIN
  RegisterSetEmpty [0] := {};
(*++++++ start insertion IpEmitInit ++++++*)

    SizeTable [UnsignedByte] := ByteSize;
    SizeTable [UnsignedWord] := WordSize;
    SizeTable [UnsignedLong] := LongSize;
    SizeTable [SignedByte]   := ByteSize;
    SizeTable [SignedWord]   := WordSize;
    SizeTable [SignedLong]   := LongSize;
    SizeTable [FloatShort]   := SizeREAL;
    SizeTable [FloatLong]    := SizeLONGREAL;

    SuffixTable [UnsignedByte] := 'b';
    SuffixTable [UnsignedWord] := 'w';
    SuffixTable [UnsignedLong] := 'l';
    SuffixTable [SignedByte]   := 'b';
    SuffixTable [SignedWord]   := 'w';
    SuffixTable [SignedLong]   := 'l';
    SuffixTable [FloatShort]   := 's';
    SuffixTable [FloatLong]    := 'l';

    SignedTable [UnsignedByte] := FALSE;
    SignedTable [UnsignedWord] := FALSE;
    SignedTable [UnsignedLong] := FALSE;
    SignedTable [SignedByte]   := TRUE;
    SignedTable [SignedWord]   := TRUE;
    SignedTable [SignedLong]   := TRUE;
    SignedTable [FloatShort]   := FALSE;
    SignedTable [FloatLong]    := FALSE;

    RelationTable [RelEqual]	     [FALSE] := 'e';
    RelationTable [RelUnequal]	     [FALSE] := 'ne';
    RelationTable [RelLess]	     [FALSE] := 'b';
    RelationTable [RelLessOrEqual]   [FALSE] := 'be';
    RelationTable [RelGreater]	     [FALSE] := 'a';
    RelationTable [RelGreaterOrEqual][FALSE] := 'ae';
    RelationTable [RelEqual]	     [TRUE ] := 'e';
    RelationTable [RelUnequal]	     [TRUE ] := 'ne';
    RelationTable [RelLess]	     [TRUE ] := 'l';
    RelationTable [RelLessOrEqual]   [TRUE ] := 'le';
    RelationTable [RelGreater]	     [TRUE ] := 'g';
    RelationTable [RelGreaterOrEqual][TRUE ] := 'ge';

    Reverse [RelEqual]		:= RelEqual;
    Reverse [RelUnequal]	:= RelUnequal;
    Reverse [RelLess]		:= RelGreater;
    Reverse [RelLessOrEqual]	:= RelGreaterOrEqual;
    Reverse [RelGreater]	:= RelLess;
    Reverse [RelGreaterOrEqual]	:= RelLessOrEqual;

    PowerTable [0] := 1;
    FOR i := 1 TO MaxPowerTable DO PowerTable [i] := 2 * PowerTable [i-1] END;

    WordReg[Regeax] := '%ax';
    WordReg[Regebx] := '%bx';
    WordReg[Regecx] := '%cx';
    WordReg[Regedx] := '%dx';
    WordReg[Regesi] := '%si';
    WordReg[Regedi] := '%di';
    ByteReg[Regeax] := '%al';
    ByteReg[Regebx] := '%bl';
    ByteReg[Regecx] := '%cl';
    ByteReg[Regedx] := '%dl';

    DefineOption (oEmitIR, 'EmitIR', FALSE, FALSE);
    DefineOption (oEmitMatch, 'EmitMatch', FALSE, FALSE);
    DefineOption (oRegAlloc, 'RegAlloc', FALSE, FALSE);
    DefineOption (oCCall, 'CcallsMocka', FALSE, FALSE);    
    DefineOption (ElfOption, 'elf', FALSE, TRUE);
    DefineOption (oAssemblerListing, 'S', FALSE, TRUE);


(*------ end   insertion IpEmitInit ------*)
END Emit.

