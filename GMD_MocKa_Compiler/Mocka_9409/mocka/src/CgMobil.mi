  (**************************************************************) 
  (*   This module was generated by BEG V1.75        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
 IMPLEMENTATION MODULE CgMobil;
 
 
 IMPORT     IR;
 IMPORT     Emit;
(*++++++ start insertion IpIRConsStorage ++++++*)

FROM GcgStorage IMPORT ALLOCATE;


(*------ end   insertion IpIRConsStorage ------*)
 FROM       IR      IMPORT NonTerminal;
 FROM       IR      IMPORT OpCode;

(*++++++ start insertion IpNtTypes ++++++*)

FROM IR	IMPORT	MemAdr, AdrMode, AdrModeMode;


(*------ end   insertion IpNtTypes ------*)
(******* empty insertion IpText *******)
(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;
FROM Strings	IMPORT	String;


(*------ end   insertion IpTypes ------*)
(*++++++ start insertion IpCgMobil_i ++++++*)

FROM LREAL		IMPORT	LTRUNC, LFLOAT;
FROM MathLib		IMPORT	real;
FROM Strings		IMPORT	StrEq;
FROM SuErrors		IMPORT	ERROR, UndefSourcePos, CompilerError;
FROM CgBase		IMPORT	GetLabel;
FROM CgTypeMap		IMPORT	ReservedParamFrameSize;
FROM CgUtilities	IMPORT	IsPowerOfTwo, Log2;
FROM Emit		IMPORT	SizeTable, SignedTable, NullSymb, DisplaySym,
				CurLevel, CallLevel, MaxCallLevel, IsNilMemAdr;
FROM GcgStorage		IMPORT	InitGcgStorage;

CONST	FloatMaxCardinal = 4294967295.0;
	
VAR     optemp : Operand;	(* Temporaries for CONDITIONS etc. *)

VAR	ParamSize	: ARRAY [1..MaxCallLevel] OF LONGINT;
	CurParamOffset  : ARRAY [1..MaxCallLevel] OF LONGINT;
	arglist		: ARRAY [1..MaxCallLevel] OF Arglist;
	callee		: Address;
	r		: REAL;

PROCEDURE EqualMemAdr (a,b: MemAdr) : BOOLEAN;
BEGIN
  RETURN (a.offset = b.offset) AND
	 (a.faktor = b.faktor) AND
	 (a.base = b.base) AND
	 (a.index = b.index) AND
	 (a.symbol = b.symbol)
END EqualMemAdr;

PROCEDURE DeclareModule
   (    extern       : BOOLEAN;
    VAR CompUnitName : ARRAY OF CHAR; 
    VAR ref          : ModuleIndex);
BEGIN
   Emit.DeclareModule (extern, CompUnitName, ref);
END DeclareModule;


PROCEDURE DeclareProcedure
   (    extern       : BOOLEAN;
	isFunction   : BOOLEAN;
	ProcMode     : Mode;
    VAR ProcName     : ARRAY OF CHAR; 
        ProcNumber   : SHORTCARD;
        module       : ModuleIndex;
	level        : SHORTCARD;
	father       : ProcIndex;
    VAR ref          : ProcIndex);
BEGIN
  Emit.DeclareProcedure (extern, isFunction, ProcMode,
			 ProcName, ProcNumber, module, level, father, ref);
END DeclareProcedure;


PROCEDURE DeclareString
   (    length : SHORTCARD;
    VAR string : ARRAY OF CHAR; 
    VAR ref    : StringIndex);
BEGIN
  Emit.DeclareString (length, string, ref);
END DeclareString;


PROCEDURE DeclareLabel (VAR lab : CgBase.Label);
BEGIN
  GetLabel (lab);
END DeclareLabel;


PROCEDURE DeclareDataTempo (mode: CgBase.Mode; VAR tempo: CgBase.Tempo);
BEGIN
  Emit.DeclareTempo (mode, tempo);
END DeclareDataTempo;

  
PROCEDURE DeclareAddressTempo (VAR tempo: CgBase.Tempo);
BEGIN
  Emit.DeclareTempo (SignedLong, tempo);
END DeclareAddressTempo;
 

PROCEDURE Switch
   (mode         : Mode;
    lwb          : LONGINT;
    upb          : LONGINT;
    CaseLabels   : ARRAY OF CgBase.Label;
    DefaultLabel : CgBase.Label;
    op           : Operand);
(* Zunaechst wird die Label-Liste <CaseLabels> von der ARRAY-Struktur	*)
(* des Front-Ends in eine verkettete Liste <LabelList> umgespeichert.	*)
VAR   l,ll,l1 : CgBase.LabelList;
      i       : LONGINT;
BEGIN
   NEW (l); ll:=l;
   l^.label := CaseLabels[0];
   FOR i:=1 TO upb - lwb DO 
      NEW (l1); ll^.next := l1; ll :=l1;
      l1^.label := CaseLabels[i];
   END;
   ll^.next := NIL;
   Coerce (mode, UnsignedLong, op, op);
   SwitchL (UnsignedLong, lwb, upb, l, DefaultLabel, op);
END Switch;

PROCEDURE  BeginModule
   (AtModulName  :  ARRAY OF CHAR;
    AtFrameSize  :  LONGINT);
BEGIN
   InitGcgStorage;
   FirstAttr := NIL; MemExtend;
   Emit.BeginModule (AtModulName, AtFrameSize);
END BeginModule;


(*------ end   insertion IpCgMobil_i ------*)
 VAR
    FirstExpr, NextExpr, LastExpr    :  IR.Expression;
    FirstAttr, NextAttr, LastAttr    :  IR.Attributes;
    FirstGcg,  NextGcg,  LastGcg     :  IR.ExprAttributes;
 
 PROCEDURE MatchChainRules (e : IR.Expression);
 VAR   fired   : BOOLEAN;
       ga      : IR.ExprAttributes;
 BEGIN
    ga := e^.gcg;
      IF ga^.cost[ntSymPlusOffset] > ga^.cost[ntConstant] THEN
      (* RULE 1/332 *)
 ga^.SymPlusOffset.offset	:= e^.gcg^.Constant.val; ;
      ga^.cost[ntSymPlusOffset] :=  ga^.cost[ntConstant];
      ga^.rule[ntSymPlusOffset] := 1;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntSymPlusOffset] THEN
      (* RULE 2/336 *)
 ga^.RegPlusSymPlusOffset.offset	:= e^.gcg^.SymPlusOffset.offset; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntSymPlusOffset];
      ga^.rule[ntRegPlusSymPlusOffset] := 2;
   END;

      IF ga^.cost[ntRegOrIm] > ga^.cost[ntConstant] THEN
      (* RULE 11/398 *)
 ga^.RegOrIm.mode     := e^.gcg^.Constant.mode; ;
      ga^.cost[ntRegOrIm] :=  ga^.cost[ntConstant];
      ga^.rule[ntRegOrIm] := 11;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntConstant] THEN
      (* RULE 12/404 *)
 ga^.RegOrCMemOrIm.mode     := e^.gcg^.Constant.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntConstant];
      ga^.rule[ntRegOrCMemOrIm] := 12;
   END;

      IF ga^.cost[ntCMem] > ga^.cost[ntFloatConstant] THEN
      (* RULE 15/424 *)
   IF  e^.gcg^.FloatConstant.mode = FloatShort  THEN 
 ga^.CMem.mode := e^.gcg^.FloatConstant.mode; ;
      ga^.cost[ntCMem] :=  ga^.cost[ntFloatConstant];
      ga^.rule[ntCMem] := 15;
   END;
   END;

      IF ga^.cost[ntCMem] > ga^.cost[ntFloatConstant] THEN
      (* RULE 16/443 *)
   IF  e^.gcg^.FloatConstant.mode = FloatLong  THEN 
 ga^.CMem.mode := e^.gcg^.FloatConstant.mode; ;
      ga^.cost[ntCMem] :=  ga^.cost[ntFloatConstant];
      ga^.rule[ntCMem] := 16;
   END;
   END;

      IF ga^.cost[ntRegOrCMem] > ga^.cost[ntCMem] THEN
      (* RULE 9/383 *)
 ga^.RegOrCMem.mode    := e^.gcg^.CMem.mode; ;
      ga^.cost[ntRegOrCMem] :=  ga^.cost[ntCMem];
      ga^.rule[ntRegOrCMem] := 9;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 6/362 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 6;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg] THEN
      (* RULE 4/347 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg];
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 4;
   END;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntRegOrCMem] THEN
      (* RULE 10/389 *)
 ga^.RegOrCMemOrIm.mode    := e^.gcg^.RegOrCMem.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntRegOrCMem];
      ga^.rule[ntRegOrCMemOrIm] := 10;
   END;

      IF ga^.cost[ntreg] > ga^.cost[ntRegOrCMemOrIm]+2 THEN
      (* RULE 14/417 *)
 ga^.reg.mode := e^.gcg^.RegOrCMemOrIm.mode ;
      ga^.cost[ntreg] :=  ga^.cost[ntRegOrCMemOrIm]+2;
      ga^.rule[ntreg] := 14;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg] THEN
      (* RULE 3/341 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg];
      ga^.rule[ntRegPlusSymPlusOffset] := 3;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntRegPlusSymPlusOffset] THEN
      (* RULE 5/353 *)
 ga^.mem.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= 1; ;
      ga^.cost[ntmem] :=  ga^.cost[ntRegPlusSymPlusOffset];
      ga^.rule[ntmem] := 5;
   END;

      IF ga^.cost[ntreg] > ga^.cost[ntmem]+2 THEN
      (* RULE 13/410 *)
 ga^.reg.mode := SignedLong; ;
      ga^.cost[ntreg] :=  ga^.cost[ntmem]+2;
      ga^.rule[ntreg] := 13;
   END;

      IF ga^.cost[ntRegOrCMem] > ga^.cost[ntreg] THEN
      (* RULE 8/377 *)
 ga^.RegOrCMem.mode    := e^.gcg^.reg.mode; ;
      ga^.cost[ntRegOrCMem] :=  ga^.cost[ntreg];
      ga^.rule[ntRegOrCMem] := 8;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 6/362 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 6;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg] THEN
      (* RULE 4/347 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg];
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 4;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 6/362 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 6;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntRegOrCMem] THEN
      (* RULE 10/389 *)
 ga^.RegOrCMemOrIm.mode    := e^.gcg^.RegOrCMem.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntRegOrCMem];
      ga^.rule[ntRegOrCMemOrIm] := 10;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg] THEN
      (* RULE 3/341 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg];
      ga^.rule[ntRegPlusSymPlusOffset] := 3;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntRegPlusSymPlusOffset] THEN
      (* RULE 5/353 *)
 ga^.mem.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= 1; ;
      ga^.cost[ntmem] :=  ga^.cost[ntRegPlusSymPlusOffset];
      ga^.rule[ntmem] := 5;
   END;

      IF ga^.cost[ntreg] > ga^.cost[ntmem]+2 THEN
      (* RULE 13/410 *)
 ga^.reg.mode := SignedLong; ;
      ga^.cost[ntreg] :=  ga^.cost[ntmem]+2;
      ga^.rule[ntreg] := 13;
   END;

      IF ga^.cost[ntRegOrCMem] > ga^.cost[ntreg] THEN
      (* RULE 8/377 *)
 ga^.RegOrCMem.mode    := e^.gcg^.reg.mode; ;
      ga^.cost[ntRegOrCMem] :=  ga^.cost[ntreg];
      ga^.rule[ntRegOrCMem] := 8;
   END;

      IF ga^.cost[ntOffsetPlusIndexMultFaktor] > ga^.cost[ntreg] THEN
      (* RULE 4/347 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= 0; 
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= 1; ;
      ga^.cost[ntOffsetPlusIndexMultFaktor] :=  ga^.cost[ntreg];
      ga^.rule[ntOffsetPlusIndexMultFaktor] := 4;
   END;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntOffsetPlusIndexMultFaktor] THEN
      (* RULE 6/362 *)
 ga^.mem.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.mem.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
      ga^.cost[ntmem] :=  ga^.cost[ntOffsetPlusIndexMultFaktor];
      ga^.rule[ntmem] := 6;
   END;

      IF ga^.cost[ntRegPlusSymPlusOffset] > ga^.cost[ntreg] THEN
      (* RULE 3/341 *)
   IF  SizeTable[e^.gcg^.reg.mode] = 4  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= 0; ;
      ga^.cost[ntRegPlusSymPlusOffset] :=  ga^.cost[ntreg];
      ga^.rule[ntRegPlusSymPlusOffset] := 3;
   END;
   END;

      IF ga^.cost[ntRegOrCMemOrIm] > ga^.cost[ntRegOrCMem] THEN
      (* RULE 10/389 *)
 ga^.RegOrCMemOrIm.mode    := e^.gcg^.RegOrCMem.mode; ;
      ga^.cost[ntRegOrCMemOrIm] :=  ga^.cost[ntRegOrCMem];
      ga^.rule[ntRegOrCMemOrIm] := 10;
   END;

      IF ga^.cost[ntmem] > ga^.cost[ntRegPlusSymPlusOffset] THEN
      (* RULE 5/353 *)
 ga^.mem.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= 1; ;
      ga^.cost[ntmem] :=  ga^.cost[ntRegPlusSymPlusOffset];
      ga^.rule[ntmem] := 5;
   END;

      IF ga^.cost[ntfreg] > ga^.cost[ntCMem]+20 THEN
      (* RULE 17/462 *)
      ga^.cost[ntfreg] :=  ga^.cost[ntCMem]+20;
      ga^.rule[ntfreg] := 17;
   END;

      IF ga^.cost[ntfstack] > ga^.cost[ntfreg]+2 THEN
      (* RULE 18/469 *)
      ga^.cost[ntfstack] :=  ga^.cost[ntfreg]+2;
      ga^.rule[ntfstack] := 18;
   END;

      IF ga^.cost[ntRegOrIm] > ga^.cost[ntreg] THEN
      (* RULE 7/371 *)
 ga^.RegOrIm.mode    := e^.gcg^.reg.mode; ;
      ga^.cost[ntRegOrIm] :=  ga^.cost[ntreg];
      ga^.rule[ntRegOrIm] := 7;
   END;

 END MatchChainRules;

 PROCEDURE MemExtend;
 VAR i : CARDINAL;
     e,le : IR.Expression;
     a,la : IR.Attributes;
     g,lg : IR.ExprAttributes;
 BEGIN 
    NEW (NextAttr); NEW (NextExpr); NEW (NextGcg);
    NextAttr^.hashchain := NIL;
    NextExpr^.hashchain := NIL;
    NextGcg^. hashchain := NIL;
    la:=NextAttr; le:=NextExpr; lg:=NextGcg;
    FOR i:=1 TO 
(******* empty insertion IpMemSize *******)
        30
    DO 
        NEW (a); a^.hashchain := NextAttr; NextAttr := a;
        NEW (e); e^.hashchain := NextExpr; NextExpr := e;
        NEW (g); g^.hashchain := NextGcg;  NextGcg  := g;
    END;
    IF FirstAttr=NIL THEN 
       FirstAttr:=NextAttr; FirstExpr:=NextExpr; FirstGcg:=NextGcg;
    ELSE
       LastAttr^.hashchain := NextAttr;
       LastExpr^.hashchain := NextExpr;
       LastGcg^.hashchain  := NextGcg;
    END;
    LastAttr:=la; LastExpr := le; LastGcg  := lg;
 END MemExtend;

 PROCEDURE  ShortCardConstant (
                      Atc  :  SHORTCARD
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShortCardConstant;
   a^.ShortCardConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 19/479 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val  := e^.attr^.ShortCardConstant.c;
	  ga^.Constant.mode := UnsignedWord; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 19;
   END;
   MatchChainRules(e);
 END ShortCardConstant;


 PROCEDURE  LongCardConstant (
                      Atc  :  LONGCARD
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongCardConstant;
   a^.LongCardConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 20/483 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := INTEGER(e^.attr^.LongCardConstant.c);
	  ga^.Constant.mode := UnsignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 20;
   END;
   MatchChainRules(e);
 END LongCardConstant;


 PROCEDURE  ShortIntConstant (
                      Atc  :  SHORTINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShortIntConstant;
   a^.ShortIntConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 21/487 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.attr^.ShortIntConstant.c;
	  ga^.Constant.mode := SignedWord; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 21;
   END;
   MatchChainRules(e);
 END ShortIntConstant;


 PROCEDURE  LongIntConstant (
                      Atc  :  LONGINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongIntConstant;
   a^.LongIntConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 22/491 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.attr^.LongIntConstant.c;
	  ga^.Constant.mode := SignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 22;
   END;
   MatchChainRules(e);
 END LongIntConstant;


 PROCEDURE  RealConstant (
                      Atc  :  REAL
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRealConstant;
   a^.RealConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 23/495 *)
   IF 0 <   ga^.cost[ntFloatConstant]  THEN 
 ga^.FloatConstant.mode := FloatShort;
	  ga^.FloatConstant.val  := e^.attr^.RealConstant.c; ;
     ga^.cost[ntFloatConstant] := 0; 
     ga^.rule[ntFloatConstant] := 23;
   END;
   MatchChainRules(e);
 END RealConstant;


 PROCEDURE  LongRealConstant (
                      Atc  :  LONGREAL
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongRealConstant;
   a^.LongRealConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 24/499 *)
   IF 0 <   ga^.cost[ntFloatConstant]  THEN 
 ga^.FloatConstant.mode := FloatLong;
	  ga^.FloatConstant.val  := e^.attr^.LongRealConstant.c; ;
     ga^.cost[ntFloatConstant] := 0; 
     ga^.rule[ntFloatConstant] := 24;
   END;
   MatchChainRules(e);
 END LongRealConstant;


 PROCEDURE  CharConstant (
                      Atc  :  CHAR
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCharConstant;
   a^.CharConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 25/503 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := ORD (e^.attr^.CharConstant.c);
	  ga^.Constant.mode := UnsignedByte; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 25;
   END;
   MatchChainRules(e);
 END CharConstant;


 PROCEDURE  BoolConstant (
                      Atval  :  BOOLEAN
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBoolConstant;
   a^.BoolConstant.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 26/507 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 IF e^.attr^.BoolConstant.val THEN ga^.Constant.val := 1; 
	                      ELSE ga^.Constant.val := 0; END;
	  ga^.Constant.mode := UnsignedByte; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 26;
   END;
   MatchChainRules(e);
 END BoolConstant;


 PROCEDURE  SetConstant (
                      Atc  :  BITSET
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetConstant;
   a^.SetConstant.c := Atc;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 27/512 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := LONGINT (e^.attr^.SetConstant.c);
	  ga^.Constant.mode := UnsignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 27;
   END;
   MatchChainRules(e);
 END SetConstant;


 PROCEDURE  NilConstant (
                         VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNilConstant;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 28/516 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := LONGINT (NIL);
	  ga^.Constant.mode := UnsignedLong; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 28;
   END;
   MatchChainRules(e);
 END NilConstant;


 PROCEDURE  ProcedureConstant (
                      Atindex  :  CgBase.ProcIndex
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opProcedureConstant;
   a^.ProcedureConstant.index := Atindex;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 29/520 *)
   IF 0 <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= 0; ;
     ga^.cost[ntSymPlusOffset] := 0; 
     ga^.rule[ntSymPlusOffset] := 29;
   END;
   MatchChainRules(e);
 END ProcedureConstant;


 PROCEDURE  StringAddr (
                      Atindex  :  CgBase.StringIndex
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opStringAddr;
   a^.StringAddr.index := Atindex;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 30/524 *)
   IF 0 <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= 0; ;
     ga^.cost[ntSymPlusOffset] := 0; 
     ga^.rule[ntSymPlusOffset] := 30;
   END;
   MatchChainRules(e);
 END StringAddr;


 PROCEDURE  LocalVariable (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLocalVariable;
   a^.LocalVariable.offset := Atoffset;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 31/531 *)
   IF 0 <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base.offset  := e^.attr^.LocalVariable.offset;
	  ga^.SimpleVariable.base.base	   := Regebp;
	  ga^.SimpleVariable.base.symbol  := NullSymb;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 0;
	  ga^.SimpleVariable.index.offset := 0;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := NullSymb;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := 0; 
     ga^.rule[ntSimpleVariable] := 31;
   END;
     (* RULE 32/543 *)
   IF 0 <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.attr^.LocalVariable.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := 0; 
     ga^.rule[ntRegPlusSymPlusOffset] := 32;
   END;
   MatchChainRules(e);
 END LocalVariable;


 PROCEDURE  GlobalVariable (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
 END GlobalVariable;


 PROCEDURE  StaticVariable (
                      Atmodule  :  CgBase.ModuleIndex;
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opStaticVariable;
   a^.StaticVariable.module := Atmodule;
   a^.StaticVariable.offset := Atoffset;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 33/551 *)
   IF 0 <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base.offset  := e^.attr^.StaticVariable.offset;
	  ga^.SimpleVariable.base.base	   := RegNil;
	  ga^.SimpleVariable.base.symbol  := e^.attr^.StaticVariable.module^.Statics;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 0;
	  ga^.SimpleVariable.index.offset := 0;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := NullSymb;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := 0; 
     ga^.rule[ntSimpleVariable] := 33;
   END;
     (* RULE 34/563 *)
   IF 0 <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.attr^.StaticVariable.offset; ;
     ga^.cost[ntSymPlusOffset] := 0; 
     ga^.rule[ntSymPlusOffset] := 34;
   END;
   MatchChainRules(e);
 END StaticVariable;


 PROCEDURE  LocalValueParam (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Atoffset, result);
 END LocalValueParam;


 PROCEDURE  LocalVarParam (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Atoffset, result);
      Content   (SignedLong, result, result)
 END LocalVarParam;


 PROCEDURE  LocalOpenArrayValueParam (
                      Atoffset  :  LONGINT
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Atoffset, result);
      Content   (SignedLong, result, result)
 END LocalOpenArrayValueParam;


 PROCEDURE  GlobalValueParam (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
 END GlobalValueParam;


 PROCEDURE  GlobalVarParam (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
      Content   (SignedLong, result, result)
 END GlobalVarParam;


 PROCEDURE  GlobalOpenArrayValueParam (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
      Content   (SignedLong, result, result)
 END GlobalOpenArrayValueParam;


 PROCEDURE  UsePointer (
                         op1  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 result := op1 
 END UsePointer;


 PROCEDURE  FrameBase (
                      Atproc  :  CgBase.ProcIndex;
                      Atlevel  :  SHORTCARD
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFrameBase;
   a^.FrameBase.proc := Atproc;
   a^.FrameBase.level := Atlevel;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 35/592 *)
   IF 0 <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FrameBase.level = CurLevel  THEN 
 ga^.reg.mode := SignedLong; ;
     ga^.cost[ntreg] := 0; 
     ga^.rule[ntreg] := 35;
   END;
   END;
     (* RULE 36/596 *)
   IF 0 <   ga^.cost[ntCMem]  THEN 
   IF  e^.attr^.FrameBase.level < CurLevel  THEN 
 ga^.CMem.mode	:= SignedLong; ;
     ga^.cost[ntCMem] := 0; 
     ga^.rule[ntCMem] := 36;
   END;
   END;
   MatchChainRules(e);
 END FrameBase;


 PROCEDURE  ParamBase (
                      Atproc  :  CgBase.ProcIndex;
                      Atlevel  :  SHORTCARD
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
FrameBase (Atproc, Atlevel, result);
 END ParamBase;


 PROCEDURE  AddOffset (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 LongIntConstant (Atoffset, result);
       FixedPlus (SignedLong, op1, result, result); 
 END AddOffset;


 PROCEDURE  Subscript (
                      AtIndexMode  :  CgBase.Mode;
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode;
                      AtElemSize  :  LONGCARD
                      ;  op1  : Address
                      ;  op2  : Data
                      ;  op3  : Address
                      ;  op4  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
	       
     (* op1 = Base, op2 = Index, op3 = Lwb, op4 = Upb *)
	   Coerce (AtIndexMode, UnsignedLong, op2, op2);
	   LongCardConstant (AtElemSize, result);
	 FixedMult (UnsignedLong,  op2, result, result); 
       AddAddr (op1, result, result);
       e:=op3;
     AddOffset (-INTEGER(AtElemSize)*e^.gcg^.Constant.val, result, result);
		      (* op3 is known to be constant *) 
 END Subscript;


 PROCEDURE  AddAddr (
                         op1  : Address
                      ;  op2  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FixedPlus (UnsignedLong, op1, op2, result); 
 END AddAddr;


 PROCEDURE  SelectField (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AddOffset (Atoffset, op1, result);
 END SelectField;


 PROCEDURE  AssignDataTempo (
                      Atmode  :  CgBase.Mode;
                      Attempo  :  CgBase.DataTempo
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Attempo, optemp); Assign (Atmode, optemp, op1);
 END AssignDataTempo;


 PROCEDURE  AssignAddressTempo (
                      Attempo  :  CgBase.AddressTempo
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
AssignDataTempo (SignedLong, Attempo, op1)
 END AssignAddressTempo;


 PROCEDURE  UseDataTempo (
                      Atmode  :  CgBase.Mode;
                      Attempo  :  CgBase.DataTempo
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
LocalVariable (Attempo, result); Content (Atmode, result, result);
 END UseDataTempo;


 PROCEDURE  UseAddressTempo (
                      Attempo  :  CgBase.AddressTempo
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
UseDataTempo (SignedLong, Attempo, result);
 END UseAddressTempo;


 PROCEDURE  Content (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opContent;
   a^.Content.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 39/661 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntCMem]  THEN 
 ga^.CMem.mode := e^.attr^.Content.mode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 39;
   END;
   MatchChainRules(e);
 END Content;


 PROCEDURE  Assign (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAssign;
   a^.Assign.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 40/668 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode < FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 40;
   END;
   END;
     (* RULE 41/673 *)
    c:=  45+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode >= FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 41;
   END;
   END;
     (* RULE 42/681 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode = FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 42;
   END;
   END;
     (* RULE 43/689 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.Assign.mode = FloatLong  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 43;
   END;
   END;
     (* RULE 44/699 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.Assign.mode = FloatShort) AND (e^.son[2]^.gcg^.CMem.mode = FloatShort)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 44;
   END;
   END;
     (* RULE 77/878 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.Assign.mode = FloatLong) AND (e^.son[2]^.gcg^.CMem.mode = FloatLong)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 77;
   END;
   END;
     (* RULE 78/891 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[1]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 78;
   END;
   END;
   END;
   END;
     (* RULE 79/891 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[2]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 79;
   END;
   END;
   END;
   END;
     (* RULE 80/905 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 80;
   END;
   END;
   END;
   END;
     (* RULE 81/905 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 81;
   END;
   END;
   END;
   END;
     (* RULE 82/918 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedPlus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  c+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 82;
   END;
   END;
   END;
   END;
   END;
     (* RULE 89/966 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMinus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[2]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 89;
   END;
   END;
   END;
   END;
     (* RULE 90/980 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMinus THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 90;
   END;
   END;
   END;
   END;
     (* RULE 97/1015 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[1]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 97;
   END;
   END;
   END;
   END;
     (* RULE 98/1015 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (e^.son[2]^.son[2]^.gcg^.Constant.val = 1)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 98;
   END;
   END;
   END;
   END;
     (* RULE 113/1084 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (NOT SignedTable [e^.attr^.Assign.mode] OR (e^.son[2]^.son[1]^.gcg^.Constant.val > 0)) AND
	  IsPowerOfTwo (e^.son[2]^.son[1]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[1]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 113;
   END;
   END;
   END;
   END;
     (* RULE 114/1084 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (NOT SignedTable [e^.attr^.Assign.mode] OR (e^.son[2]^.son[2]^.gcg^.Constant.val > 0)) AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[2]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 114;
   END;
   END;
   END;
   END;
     (* RULE 126/1170 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  14+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  c+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 126;
   END;
   END;
   END;
   END;
   END;
     (* RULE 132/1236 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedDiv THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  (NOT SignedTable [e^.attr^.Assign.mode]) AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[2]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 132;
   END;
   END;
   END;
   END;
     (* RULE 134/1259 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedDiv THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  SignedTable [e^.attr^.Assign.mode] AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.son[2]^.gcg^.Constant.val) # 0)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 134;
   END;
   END;
   END;
   END;
     (* RULE 141/1330 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMod THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index) AND
	  IsPowerOfTwo (e^.son[2]^.son[2]^.gcg^.Constant.val) & (NOT SignedTable[e^.attr^.Assign.mode])  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 141;
   END;
   END;
   END;
   END;
     (* RULE 165/1459 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetUnion THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 165;
   END;
   END;
   END;
   END;
     (* RULE 166/1459 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetUnion THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 166;
   END;
   END;
   END;
   END;
     (* RULE 169/1489 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetDifference THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntreg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 169;
   END;
   END;
   END;
   END;
     (* RULE 170/1503 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetDifference THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  3+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 170;
   END;
   END;
   END;
   END;
     (* RULE 173/1522 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetIntersection THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 173;
   END;
   END;
   END;
   END;
     (* RULE 174/1522 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetIntersection THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 174;
   END;
   END;
   END;
   END;
     (* RULE 177/1541 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetSymDifference THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[2]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 177;
   END;
   END;
   END;
   END;
     (* RULE 178/1541 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opSetSymDifference THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opContent THEN 
    c:=  5+     e3^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntRegOrIm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.stmtcost  THEN 
   IF  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[1]^.gcg^.SimpleVariable.index)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 178;
   END;
   END;
   END;
   END;
     (* RULE 189/1666 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opTrunc THEN 
    c:=  90+     e2^.son[1]^.gcg^.cost[ntfreg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 189;
   END;
   END;
     (* RULE 259/2584 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFunctionCall THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opPass THEN 
   IF e3^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e3^.son[2]^.gcg^.cost[ntfreg];
   IF e2^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  c+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entier') OR
	 StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entierL') OR
	 StrEq (e^.son[2]^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LTRUNC')  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 259;
   END;
   END;
   END;
   END;
   END;
   END;
   Emit.EmitInstruction (e);
 END Assign;


 PROCEDURE  AssignLong (
                      Atsize  :  LONGINT
                      ;  op1  : Address
                      ;  op2  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAssignLong;
   a^.AssignLong.size := Atsize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 45/708 *)
    c:=  20+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.AssignLong.size >= 4)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 45;
   END;
   END;
     (* RULE 46/725 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.attr^.AssignLong.size = 4)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 46;
   END;
   END;
     (* RULE 47/734 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.AssignLong.size < 4  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 47;
   END;
   END;
   Emit.EmitInstruction (e);
 END AssignLong;


 PROCEDURE  Inc1 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opInc1;
   a^.Inc1.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 48/751 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 48;
   END;
   Emit.EmitInstruction (e);
 END Inc1;


 PROCEDURE  Inc2 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opInc2;
   a^.Inc2.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 50/759 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 50;
   END;
   Emit.EmitInstruction (e);
 END Inc2;


 PROCEDURE  Dec1 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opDec1;
   a^.Dec1.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 49/755 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 49;
   END;
   Emit.EmitInstruction (e);
 END Dec1;


 PROCEDURE  Dec2 (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opDec2;
   a^.Dec2.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 51/763 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 51;
   END;
   Emit.EmitInstruction (e);
 END Dec2;


 PROCEDURE  Incl (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (Atmode, UnsignedLong, op2, op2);
    InclL (op1, op2); 
 END Incl;


 PROCEDURE  Excl (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (Atmode, UnsignedLong, op2, op2);
    ExclL (op1, op2); 
 END Excl;


 PROCEDURE  InclL (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opInclL;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 52/771 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 52;
   END;
   Emit.EmitInstruction (e);
 END InclL;


 PROCEDURE  ExclL (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opExclL;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 53/779 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 53;
   END;
   Emit.EmitInstruction (e);
 END ExclL;


 PROCEDURE  SkipAddress (
                         op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSkipAddress;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 54/786 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 54;
   END;
   Emit.EmitInstruction (e);
 END SkipAddress;


 PROCEDURE  SkipData (
                         op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSkipData;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 55/789 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 55;
   END;
   Emit.EmitInstruction (e);
 END SkipData;


 PROCEDURE  FixedNegate (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedNegate;
   a^.FixedNegate.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 56/795 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := -e^.son[1]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 56;
   END;
     (* RULE 57/799 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedNegate.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 57;
   END;
   MatchChainRules(e);
 END FixedNegate;


 PROCEDURE  FixedPlus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedPlus;
   a^.FixedPlus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 37/606 *)
   IF e^.son[2]^.attr^.op = opFrameBase THEN 
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  e^.son[2]^.attr^.FrameBase.level < CurLevel  THEN 
 ga^.SimpleVariable.base.offset  := e^.son[1]^.gcg^.Constant.val;
	  ga^.SimpleVariable.base.base	   := RegNil;
	  ga^.SimpleVariable.base.symbol  := NullSymb;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 1;
	  ga^.SimpleVariable.index.offset := 4*e^.son[2]^.attr^.FrameBase.level;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := DisplaySym;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 37;
   END;
   END;
   END;
     (* RULE 38/606 *)
   IF e^.son[1]^.attr^.op = opFrameBase THEN 
    c:=       e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  e^.son[1]^.attr^.FrameBase.level < CurLevel  THEN 
 ga^.SimpleVariable.base.offset  := e^.son[2]^.gcg^.Constant.val;
	  ga^.SimpleVariable.base.base	   := RegNil;
	  ga^.SimpleVariable.base.symbol  := NullSymb;
	  ga^.SimpleVariable.base.index   := RegNil;
	  ga^.SimpleVariable.base.faktor  := 1;
	  ga^.SimpleVariable.index.offset := 4*e^.son[1]^.attr^.FrameBase.level;
	  ga^.SimpleVariable.index.base   := RegNil;
	  ga^.SimpleVariable.index.symbol := DisplaySym;
	  ga^.SimpleVariable.index.index  := RegNil;
	  ga^.SimpleVariable.index.faktor := 0; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 38;
   END;
   END;
   END;
     (* RULE 60/824 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val + e^.son[2]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 60;
   END;
     (* RULE 61/828 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[2]^.gcg^.SymPlusOffset.offset + e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 61;
   END;
     (* RULE 62/828 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset + e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 62;
   END;
     (* RULE 63/832 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[2]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 63;
   END;
     (* RULE 64/832 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 64;
   END;
     (* RULE 65/838 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegPlusSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset + e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 65;
   END;
     (* RULE 66/838 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset + e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 66;
   END;
     (* RULE 67/843 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 67;
   END;
     (* RULE 68/843 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 68;
   END;
     (* RULE 69/849 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 69;
   END;
     (* RULE 70/849 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntRegPlusSymPlusOffset];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 70;
   END;
     (* RULE 71/858 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[2]^.gcg^.mem.offset + e^.son[1]^.gcg^.Constant.val;
	  ga^.mem.faktor	:= e^.son[2]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 71;
   END;
     (* RULE 72/858 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.mem.offset + e^.son[2]^.gcg^.Constant.val;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 72;
   END;
     (* RULE 73/867 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base	    := e^.son[2]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[2]^.gcg^.SimpleVariable.index;
	  ga^.SimpleVariable.base.offset  := e^.son[2]^.gcg^.SimpleVariable.base.offset + e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 73;
   END;
     (* RULE 74/867 *)
    c:=       e^.son[1]^.gcg^.cost[ntSimpleVariable]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.gcg^.SimpleVariable.index;
	  ga^.SimpleVariable.base.offset  := e^.son[1]^.gcg^.SimpleVariable.base.offset + e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 74;
   END;
     (* RULE 75/872 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedPlus.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 75;
   END;
     (* RULE 76/872 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedPlus.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 76;
   END;
     (* RULE 107/1060 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[2]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[2]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[1]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[1]^.son[2]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[1]^.son[2]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[1]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[1]^.son[1]^.gcg^.Constant.val = 1) OR (e^.son[1]^.son[1]^.gcg^.Constant.val = 2) OR (e^.son[1]^.son[1]^.gcg^.Constant.val = 4) OR (e^.son[1]^.son[1]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[2]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[1]^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 107;
   END;
   END;
   END;
   END;
   END;
     (* RULE 108/1060 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[2]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[2]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[1]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[1]^.son[1]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[1]^.son[1]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[1]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[1]^.son[2]^.gcg^.Constant.val = 1) OR (e^.son[1]^.son[2]^.gcg^.Constant.val = 2) OR (e^.son[1]^.son[2]^.gcg^.Constant.val = 4) OR (e^.son[1]^.son[2]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[2]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[1]^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 108;
   END;
   END;
   END;
   END;
   END;
     (* RULE 109/1060 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[1]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[2]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[2]^.son[2]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[2]^.son[2]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[2]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[2]^.son[1]^.gcg^.Constant.val = 1) OR (e^.son[2]^.son[1]^.gcg^.Constant.val = 2) OR (e^.son[2]^.son[1]^.gcg^.Constant.val = 4) OR (e^.son[2]^.son[1]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[2]^.son[2]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[2]^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 109;
   END;
   END;
   END;
   END;
   END;
     (* RULE 110/1060 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = opFixedMult THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = opCoerce THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = opContent THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntSimpleVariable];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
   IF  IsNilMemAdr (e^.son[1]^.gcg^.SimpleVariable.index) AND
	  IsNilMemAdr (e^.son[2]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.index) AND
	  (SizeTable[e^.son[2]^.son[1]^.attr^.Coerce.premode] = 4) AND 
	  (SizeTable[e^.son[2]^.son[1]^.attr^.Coerce.postmode] = 4) AND 
	  (SizeTable[e^.son[2]^.attr^.FixedMult.mode] = 4) AND 
 	  (SizeTable[e^.attr^.FixedPlus.mode] = 4) AND
	  ((e^.son[2]^.son[2]^.gcg^.Constant.val = 1) OR (e^.son[2]^.son[2]^.gcg^.Constant.val = 2) OR (e^.son[2]^.son[2]^.gcg^.Constant.val = 4) OR (e^.son[2]^.son[2]^.gcg^.Constant.val = 8))  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[2]^.son[1]^.son[1]^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.base.faktor  := e^.son[2]^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 110;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END FixedPlus;


 PROCEDURE  FixedMinus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedMinus;
   a^.FixedMinus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 83/933 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val - e^.son[2]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 83;
   END;
     (* RULE 84/937 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 84;
   END;
     (* RULE 85/941 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 85;
   END;
     (* RULE 86/946 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.mem.offset - e^.son[2]^.gcg^.Constant.val;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 86;
   END;
     (* RULE 87/955 *)
    c:=       e^.son[1]^.gcg^.cost[ntSimpleVariable]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntSimpleVariable]  THEN 
 ga^.SimpleVariable.base	    := e^.son[1]^.gcg^.SimpleVariable.base;
	  ga^.SimpleVariable.index	    := e^.son[1]^.gcg^.SimpleVariable.index;
	  ga^.SimpleVariable.base.offset  := e^.son[1]^.gcg^.SimpleVariable.base.offset - e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntSimpleVariable] := c; 
     ga^.rule[ntSimpleVariable] := 87;
   END;
     (* RULE 88/960 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMinus.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 88;
   END;
     (* RULE 91/993 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opContent THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[2]^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[2]^.son[1]^.gcg^.SimpleVariable.index)  THEN 
 ga^.Constant.val := 0;
	  ga^.Constant.mode := e^.attr^.FixedMinus.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 91;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END FixedMinus;


 PROCEDURE  FixedMult (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedMult;
   a^.FixedMult.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 92/1001 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val * e^.son[2]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 92;
   END;
     (* RULE 93/1005 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 0  THEN 
 ga^.Constant.mode := e^.attr^.FixedMult.mode;
	  ga^.Constant.val  := 0; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 93;
   END;
   END;
     (* RULE 94/1005 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 0  THEN 
 ga^.Constant.mode := e^.attr^.FixedMult.mode;
	  ga^.Constant.val  := 0; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 94;
   END;
   END;
     (* RULE 95/1010 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 1  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 95;
   END;
   END;
     (* RULE 96/1010 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 1  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 96;
   END;
   END;
     (* RULE 99/1023 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 2  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 99;
   END;
   END;
     (* RULE 100/1023 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 2  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 100;
   END;
   END;
     (* RULE 101/1030 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[1]^.gcg^.Constant.val = 4  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 101;
   END;
   END;
     (* RULE 102/1030 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 4  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 102;
   END;
   END;
     (* RULE 103/1040 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[1]^.gcg^.Constant.val <= 8) AND
	 ((e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=0) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=1) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=2) OR
	  (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=4) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=8))  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 103;
   END;
   END;
     (* RULE 104/1040 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[2]^.gcg^.Constant.val <= 8) AND
	 ((e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=0) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=1) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=2) OR
	  (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=4) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=8))  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 104;
   END;
   END;
     (* RULE 105/1049 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[1]^.gcg^.Constant.val <= 9) AND
	 ((e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=3) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=5) OR (e^.son[1]^.gcg^.Constant.val*e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor=9))  THEN 
 ga^.mem.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val - 1;
	  ga^.mem.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 105;
   END;
   END;
     (* RULE 106/1049 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[2]^.gcg^.Constant.val <= 9) AND
	 ((e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=3) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=5) OR (e^.son[2]^.gcg^.Constant.val*e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor=9))  THEN 
 ga^.mem.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val - 1;
	  ga^.mem.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 106;
   END;
   END;
     (* RULE 111/1076 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (NOT SignedTable [e^.attr^.FixedMult.mode] OR (e^.son[1]^.gcg^.Constant.val > 0)) AND
	      IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val) AND (Log2(e^.son[1]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 111;
   END;
   END;
     (* RULE 112/1076 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (NOT SignedTable [e^.attr^.FixedMult.mode] OR (e^.son[2]^.gcg^.Constant.val > 0)) AND
	      IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) AND (Log2(e^.son[2]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 112;
   END;
   END;
     (* RULE 115/1099 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[2]^.gcg^.reg.mode] = 4) AND (e^.son[1]^.gcg^.Constant.val > 1) AND
	 (e^.son[1]^.gcg^.Constant.val MOD 3 = 0) AND IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val DIV 3)  THEN 
 ga^.mem.faktor := 2;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 115;
   END;
   END;
     (* RULE 116/1099 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > 1) AND
	 (e^.son[2]^.gcg^.Constant.val MOD 3 = 0) AND IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val DIV 3)  THEN 
 ga^.mem.faktor := 2;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 116;
   END;
   END;
     (* RULE 117/1114 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[2]^.gcg^.reg.mode] = 4) AND (e^.son[1]^.gcg^.Constant.val > 1) AND
	 (e^.son[1]^.gcg^.Constant.val MOD 5 = 0) AND IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val DIV 5)  THEN 
 ga^.mem.faktor := 4;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 117;
   END;
   END;
     (* RULE 118/1114 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > 1) AND
	 (e^.son[2]^.gcg^.Constant.val MOD 5 = 0) AND IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val DIV 5)  THEN 
 ga^.mem.faktor := 4;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 118;
   END;
   END;
     (* RULE 119/1129 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[2]^.gcg^.reg.mode] = 4) AND (e^.son[1]^.gcg^.Constant.val > 1) AND
	 (e^.son[1]^.gcg^.Constant.val MOD 9 = 0) AND IsPowerOfTwo (e^.son[1]^.gcg^.Constant.val DIV 9)  THEN 
 ga^.mem.faktor := 8;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 119;
   END;
   END;
     (* RULE 120/1129 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (SizeTable [e^.son[1]^.gcg^.reg.mode] = 4) AND (e^.son[2]^.gcg^.Constant.val > 1) AND
	 (e^.son[2]^.gcg^.Constant.val MOD 9 = 0) AND IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val DIV 9)  THEN 
 ga^.mem.faktor := 8;
	  ga^.mem.offset := 0; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 120;
   END;
   END;
     (* RULE 121/1144 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 121;
   END;
     (* RULE 122/1144 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 122;
   END;
     (* RULE 123/1151 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntRegOrCMem]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 123;
   END;
     (* RULE 124/1151 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 124;
   END;
     (* RULE 125/1157 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opContent THEN 
    c:=  13+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[2]^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[2]^.son[1]^.gcg^.SimpleVariable.index)  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 125;
   END;
   END;
   END;
   END;
     (* RULE 127/1187 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  NOT SignedTable [e^.attr^.FixedMult.mode]  THEN 
 ga^.reg.mode := e^.attr^.FixedMult.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 127;
   END;
   END;
   MatchChainRules(e);
 END FixedMult;


 PROCEDURE  FixedDiv (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedDiv;
   a^.FixedDiv.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 128/1208 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 IF e^.son[2]^.gcg^.Constant.val = 0 THEN ERROR ("DIV by 0", UndefSourcePos);
		      ELSE ga^.Constant.val := e^.son[1]^.gcg^.Constant.val DIV e^.son[2]^.gcg^.Constant.val END;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 128;
   END;
     (* RULE 129/1213 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.son[2]^.gcg^.Constant.val = 1  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 129;
   END;
   END;
     (* RULE 130/1218 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor > 0) AND (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor <= 8) AND (e^.son[2]^.gcg^.Constant.val <= 8) AND 
         (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor MOD e^.son[2]^.gcg^.Constant.val = 0) AND (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset MOD e^.son[2]^.gcg^.Constant.val = 0) AND
	 ((e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 1) OR (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 2) OR
	  (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 4) OR (e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val = 8))  THEN 
 ga^.OffsetPlusIndexMultFaktor.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor DIV e^.son[2]^.gcg^.Constant.val;
	  ga^.OffsetPlusIndexMultFaktor.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset DIV e^.son[2]^.gcg^.Constant.val; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 130;
   END;
   END;
     (* RULE 131/1228 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (NOT SignedTable [e^.attr^.FixedDiv.mode]) AND
	 IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) AND (Log2 (e^.son[2]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 131;
   END;
   END;
     (* RULE 133/1251 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (SignedTable [e^.attr^.FixedDiv.mode]) AND
	 IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) AND (Log2 (e^.son[2]^.gcg^.Constant.val) # 0)  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 133;
   END;
   END;
     (* RULE 135/1274 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opContent THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   e2 := e^.son[2];
   IF e2^.attr^.op = opContent THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntSimpleVariable];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[2]^.son[1]^.gcg^.SimpleVariable.base) AND 
	  EqualMemAdr (e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, e^.son[2]^.son[1]^.gcg^.SimpleVariable.index)  THEN 
 ga^.Constant.val := 1;
	  ga^.Constant.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 135;
   END;
   END;
   END;
   END;
     (* RULE 136/1282 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedDiv.mode = SignedLong  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 136;
   END;
   END;
     (* RULE 137/1294 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.FixedDiv.mode = UnsignedLong) OR (e^.attr^.FixedDiv.mode = UnsignedWord)  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 137;
   END;
   END;
     (* RULE 138/1306 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedDiv.mode = SignedWord  THEN 
 ga^.reg.mode := e^.attr^.FixedDiv.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 138;
   END;
   END;
   MatchChainRules(e);
 END FixedDiv;


 PROCEDURE  FixedMod (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedMod;
   a^.FixedMod.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 139/1318 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 IF e^.son[2]^.gcg^.Constant.val = 0 THEN ERROR ("MOD by 0", UndefSourcePos);
		      ELSE ga^.Constant.val := e^.son[1]^.gcg^.Constant.val MOD e^.son[2]^.gcg^.Constant.val END;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 139;
   END;
     (* RULE 140/1323 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  IsPowerOfTwo (e^.son[2]^.gcg^.Constant.val) & (NOT SignedTable[e^.attr^.FixedMod.mode])  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 140;
   END;
   END;
     (* RULE 142/1344 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedMod.mode = SignedLong  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 142;
   END;
   END;
     (* RULE 143/1355 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.FixedMod.mode = UnsignedLong) OR (e^.attr^.FixedMod.mode = UnsignedWord)  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 143;
   END;
   END;
     (* RULE 144/1366 *)
    c:=  14+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FixedMod.mode = SignedWord  THEN 
 ga^.reg.mode := e^.attr^.FixedMod.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 144;
   END;
   END;
   MatchChainRules(e);
 END FixedMod;


 PROCEDURE  FixedAbs (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedAbs;
   a^.FixedAbs.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 58/807 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 IF e^.son[1]^.gcg^.Constant.val < 0 THEN ga^.Constant.val := -e^.son[1]^.gcg^.Constant.val ELSE ga^.Constant.val := e^.son[1]^.gcg^.Constant.val END;
	  ga^.Constant.mode := e^.son[1]^.gcg^.Constant.mode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 58;
   END;
     (* RULE 59/811 *)
    c:=  11+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  SignedTable[e^.attr^.FixedAbs.mode]  THEN 
 ga^.reg.mode := e^.attr^.FixedAbs.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 59;
   END;
   END;
   MatchChainRules(e);
 END FixedAbs;


 PROCEDURE  FloatNegate (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatNegate;
   a^.FloatNegate.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 145/1380 *)
    c:=  24+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 145;
   END;
   MatchChainRules(e);
 END FloatNegate;


 PROCEDURE  FloatPlus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatPlus;
   a^.FloatPlus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 146/1385 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 146;
   END;
     (* RULE 147/1385 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 147;
   END;
     (* RULE 148/1390 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 148;
   END;
     (* RULE 149/1390 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 149;
   END;
   MatchChainRules(e);
 END FloatPlus;


 PROCEDURE  FloatMinus (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatMinus;
   a^.FloatMinus.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 150/1395 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 150;
   END;
     (* RULE 151/1400 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 151;
   END;
     (* RULE 152/1405 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 152;
   END;
     (* RULE 153/1410 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 153;
   END;
   MatchChainRules(e);
 END FloatMinus;


 PROCEDURE  FloatMult (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatMult;
   a^.FloatMult.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 154/1415 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 154;
   END;
     (* RULE 155/1415 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 155;
   END;
     (* RULE 156/1420 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 156;
   END;
     (* RULE 157/1420 *)
    c:=  40+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 157;
   END;
   MatchChainRules(e);
 END FloatMult;


 PROCEDURE  FloatDiv (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatDiv;
   a^.FloatDiv.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 158/1425 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 158;
   END;
     (* RULE 159/1430 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 159;
   END;
     (* RULE 160/1435 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 160;
   END;
     (* RULE 161/1440 *)
    c:=  90+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntfstack];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 161;
   END;
   MatchChainRules(e);
 END FloatDiv;


 PROCEDURE  FloatAbs (
                      Atmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatAbs;
   a^.FloatAbs.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 162/1445 *)
    c:=  22+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 162;
   END;
   MatchChainRules(e);
 END FloatAbs;


 PROCEDURE  SetUnion (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetUnion;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 163/1453 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 163;
   END;
     (* RULE 164/1453 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 164;
   END;
   MatchChainRules(e);
 END SetUnion;


 PROCEDURE  SetDifference (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetDifference;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 167/1472 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 167;
   END;
     (* RULE 168/1481 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 168;
   END;
   MatchChainRules(e);
 END SetDifference;


 PROCEDURE  SetIntersection (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetIntersection;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 171/1516 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 171;
   END;
     (* RULE 172/1516 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 172;
   END;
   MatchChainRules(e);
 END SetIntersection;


 PROCEDURE  SetSymDifference (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetSymDifference;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 175/1535 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[2]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 175;
   END;
     (* RULE 176/1535 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 176;
   END;
   MatchChainRules(e);
 END SetSymDifference;


 PROCEDURE  SetPlusSingle (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (Atmode, UnsignedLong, op2, op2);
    SetPlusSingleL (op1, op2, result); 
 END SetPlusSingle;


 PROCEDURE  SetPlusSingleL (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetPlusSingleL;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 179/1558 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 179;
   END;
     (* RULE 180/1564 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 180;
   END;
   MatchChainRules(e);
 END SetPlusSingleL;


 PROCEDURE  SetPlusRange (
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetPlusRange;
   a^.SetPlusRange.LwbMode := AtLwbMode;
   a^.SetPlusRange.UpbMode := AtUpbMode;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 181/1570 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 181;
   END;
     (* RULE 182/1576 *)
    c:=  25+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[3]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 182;
   END;
   MatchChainRules(e);
 END SetPlusRange;


 PROCEDURE  Cap (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCap;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 183/1598 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 183;
   END;
   MatchChainRules(e);
 END Cap;


 PROCEDURE  Float (
                         op1  : Data
                      ;  VAR result : FloatExp);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloat;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 184/1611 *)
    c:=  60+     e^.son[1]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 184;
   END;
     (* RULE 185/1623 *)
    c:=  64+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntfreg]  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 185;
   END;
     (* RULE 186/1637 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntFloatConstant]  THEN 
 ga^.FloatConstant.mode := FloatShort;
	  ga^.FloatConstant.val  := FLOAT(CARDINAL(e^.son[1]^.gcg^.Constant.val)); ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 186;
   END;
   MatchChainRules(e);
 END Float;


 PROCEDURE  Trunc (
                      Atopmode  :  CgBase.Mode;
                      Atresultmode  :  CgBase.Mode
                      ;  op1  : FloatExp
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTrunc;
   a^.Trunc.opmode := Atopmode;
   a^.Trunc.resultmode := Atresultmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 187/1641 *)
    c:=       e^.son[1]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (e^.son[1]^.gcg^.FloatConstant.val <= FloatMaxCardinal) AND
	  (e^.son[1]^.gcg^.FloatConstant.val >= LFLOAT(MIN(CARDINAL)))  THEN 
 ga^.Constant.mode := UnsignedLong;
	  r := e^.son[1]^.gcg^.FloatConstant.val;
	  ga^.Constant.val  := INTEGER(TRUNC(r)); ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 187;
   END;
   END;
     (* RULE 188/1648 *)
    c:=  94+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedLong; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 188;
   END;
   MatchChainRules(e);
 END Trunc;


 PROCEDURE  Adr (
                         op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 result := op1 
 END Adr;


 PROCEDURE  Coerce (
                      Atpremode  :  CgBase.Mode;
                      Atpostmode  :  CgBase.Mode
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCoerce;
   a^.Coerce.premode := Atpremode;
   a^.Coerce.postmode := Atpostmode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 190/1684 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort)  THEN 
 ga^.Constant.val := e^.son[1]^.gcg^.Constant.val;
	  ga^.Constant.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 190;
   END;
   END;
     (* RULE 191/1689 *)
    c:=       e^.son[1]^.gcg^.cost[ntSymPlusOffset];
   IF c <   ga^.cost[ntSymPlusOffset]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.SymPlusOffset.offset	:= e^.son[1]^.gcg^.SymPlusOffset.offset; ;
     ga^.cost[ntSymPlusOffset] := c; 
     ga^.rule[ntSymPlusOffset] := 191;
   END;
   END;
     (* RULE 192/1695 *)
    c:=       e^.son[1]^.gcg^.cost[ntRegPlusSymPlusOffset];
   IF c <   ga^.cost[ntRegPlusSymPlusOffset]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.RegPlusSymPlusOffset.offset	:= e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset; ;
     ga^.cost[ntRegPlusSymPlusOffset] := c; 
     ga^.rule[ntRegPlusSymPlusOffset] := 192;
   END;
   END;
     (* RULE 193/1702 *)
    c:=       e^.son[1]^.gcg^.cost[ntOffsetPlusIndexMultFaktor];
   IF c <   ga^.cost[ntOffsetPlusIndexMultFaktor]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.OffsetPlusIndexMultFaktor.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  ga^.OffsetPlusIndexMultFaktor.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor; ;
     ga^.cost[ntOffsetPlusIndexMultFaktor] := c; 
     ga^.rule[ntOffsetPlusIndexMultFaktor] := 193;
   END;
   END;
     (* RULE 194/1709 *)
    c:=       e^.son[1]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntmem]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.mem.offset	:= e^.son[1]^.gcg^.mem.offset;
	  ga^.mem.faktor	:= e^.son[1]^.gcg^.mem.faktor; ;
     ga^.cost[ntmem] := c; 
     ga^.rule[ntmem] := 194;
   END;
   END;
     (* RULE 195/1720 *)
    c:=       e^.son[1]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntCMem]  THEN 
   IF  (SizeTable[e^.attr^.Coerce.premode] = SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.CMem.mode	:= e^.attr^.Coerce.postmode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 195;
   END;
   END;
     (* RULE 196/1729 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.attr^.Coerce.premode] < SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.reg.mode := e^.attr^.Coerce.postmode ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 196;
   END;
   END;
     (* RULE 197/1742 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.son[1]^.gcg^.reg.mode < FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort) AND
	  (SizeTable[e^.son[1]^.gcg^.reg.mode] >= SizeTable[e^.attr^.Coerce.postmode])  THEN 
 ga^.reg.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 197;
   END;
   END;
     (* RULE 198/1748 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode >= FloatShort)  THEN 
 ga^.FloatConstant.val := REAL(e^.son[1]^.gcg^.Constant.val);
	  ga^.FloatConstant.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 198;
   END;
   END;
     (* RULE 199/1753 *)
    c:=       e^.son[1]^.gcg^.cost[ntFloatConstant];
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  (e^.attr^.Coerce.premode = FloatShort) AND (e^.attr^.Coerce.postmode = FloatLong)  THEN 
 ga^.FloatConstant.val := e^.son[1]^.gcg^.FloatConstant.val;
	  ga^.FloatConstant.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 199;
   END;
   END;
     (* RULE 200/1758 *)
    c:=       e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  (e^.attr^.Coerce.premode >= FloatShort) AND (e^.attr^.Coerce.postmode >= FloatShort)  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 200;
   END;
   END;
     (* RULE 201/1762 *)
    c:=  45+     e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntCMem]  THEN 
   IF  (e^.attr^.Coerce.premode = FloatShort) AND (e^.attr^.Coerce.postmode < FloatShort)  THEN 
 ga^.CMem.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 201;
   END;
   END;
     (* RULE 202/1778 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.cost[ntCMem]  THEN 
   IF  (e^.attr^.Coerce.premode < FloatShort) AND (e^.attr^.Coerce.postmode = FloatShort)  THEN 
 ga^.CMem.mode := e^.attr^.Coerce.postmode; ;
     ga^.cost[ntCMem] := c; 
     ga^.rule[ntCMem] := 202;
   END;
   END;
   MatchChainRules(e);
 END Coerce;


 PROCEDURE  Check (
                      AtIndexMode  :  CgBase.Mode;
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode;
                      AtCheckLwb  :  BOOLEAN;
                      AtCheckUpb  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 IF SizeTable[AtIndexMode] = 1
         THEN Coerce (AtIndexMode, UnsignedLong, op1, op1);
	      AtIndexMode := UnsignedLong;
       END;
       CheckL (AtIndexMode, AtLwbMode, AtUpbMode, AtCheckLwb, AtCheckUpb,
	       op1, op2, op3, result);
     
 END Check;


 PROCEDURE  CheckL (
                      AtIndexMode  :  CgBase.Mode;
                      AtLwbMode  :  CgBase.Mode;
                      AtUpbMode  :  CgBase.Mode;
                      AtCheckLwb  :  BOOLEAN;
                      AtCheckUpb  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCheckL;
   a^.CheckL.IndexMode := AtIndexMode;
   a^.CheckL.LwbMode := AtLwbMode;
   a^.CheckL.UpbMode := AtUpbMode;
   a^.CheckL.CheckLwb := AtCheckLwb;
   a^.CheckL.CheckUpb := AtCheckUpb;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 203/1802 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.son[2]^.gcg^.Constant.val = 0) AND (e^.son[3]^.gcg^.Constant.val = -1)  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 203;
   END;
   END;
     (* RULE 204/1807 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.CheckL.LwbMode < FloatShort) AND (e^.attr^.CheckL.UpbMode < FloatShort) AND
         (SizeTable[e^.son[1]^.gcg^.reg.mode] > 1)   THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 204;
   END;
   END;
     (* RULE 205/1830 *)
    c:=  16+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm]+
     e^.son[3]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  (e^.attr^.CheckL.LwbMode < FloatShort) AND (e^.attr^.CheckL.UpbMode < FloatShort) AND
         (SizeTable[e^.son[1]^.gcg^.reg.mode] > 1)   THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 205;
   END;
   END;
     (* RULE 206/1843 *)
    c:=  50+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem]+
     e^.son[3]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  e^.attr^.CheckL.IndexMode >= FloatShort  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 206;
   END;
   END;
   MatchChainRules(e);
 END CheckL;


 PROCEDURE  FixedCompare (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedCompare;
   a^.FixedCompare.mode := Atmode;
   a^.FixedCompare.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 207/1872 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 207;
   END;
     (* RULE 208/1880 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 208;
   END;
     (* RULE 209/1888 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 209;
   END;
   MatchChainRules(e);
 END FixedCompare;


 PROCEDURE  FloatCompare (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation
                      ;  op1  : FloatExp
                      ;  op2  : FloatExp
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatCompare;
   a^.FloatCompare.mode := Atmode;
   a^.FloatCompare.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 210/1896 *)
    c:=  48+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 210;
   END;
     (* RULE 211/1908 *)
    c:=  48+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 211;
   END;
     (* RULE 212/1920 *)
    c:=  48+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 212;
   END;
   MatchChainRules(e);
 END FloatCompare;


 PROCEDURE  SetCompare (
                      Atrel  :  CgBase.Relation
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetCompare;
   a^.SetCompare.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 213/1938 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.SetCompare.rel <= RelUnequal  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 213;
   END;
   END;
     (* RULE 214/1947 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.SetCompare.rel > RelUnequal  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 214;
   END;
   END;
   MatchChainRules(e);
 END SetCompare;


 PROCEDURE  PointerCompare (
                      Atrel  :  CgBase.Relation
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FixedCompare (SignedLong, Atrel, op1, op2, result)
 END PointerCompare;


 PROCEDURE  TestMembership (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (AtElemMode, UnsignedLong, op1, op1);
       TestMembershipL (UnsignedLong, Atcond, op1, op2, result); 
 END TestMembership;


 PROCEDURE  TestMembershipL (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestMembershipL;
   a^.TestMembershipL.ElemMode := AtElemMode;
   a^.TestMembershipL.cond := Atcond;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 215/1979 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntRegOrIm]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := UnsignedByte; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 215;
   END;
   MatchChainRules(e);
 END TestMembershipL;


 PROCEDURE  TestOdd (
                      Atmode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestOdd;
   a^.TestOdd.mode := Atmode;
   a^.TestOdd.cond := Atcond;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 216/1991 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
 ga^.reg.mode := e^.son[1]^.gcg^.reg.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 216;
   END;
   MatchChainRules(e);
 END TestOdd;


 PROCEDURE  PlaceLabel (
                      Atlab  :  CgBase.Label
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPlaceLabel;
   a^.PlaceLabel.lab := Atlab;
   e^.arity := 0;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 217/2004 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 217;
   END;
   Emit.EmitInstruction (e);
 END PlaceLabel;


 PROCEDURE  Goto (
                      Attar  :  CgBase.Label
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opGoto;
   a^.Goto.tar := Attar;
   e^.arity := 0;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 218/2010 *)
   IF 7 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 7; 
     ga^.stmtrule := 218;
   END;
   Emit.EmitInstruction (e);
 END Goto;


 PROCEDURE  SwitchL (
                      Atmode  :  CgBase.Mode;
                      Atlwb  :  LONGINT;
                      Atupb  :  LONGINT;
                      AtCaseLabels  :  CgBase.LabelList;
                      AtDefaultLabel  :  CgBase.Label
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opSwitchL;
   a^.SwitchL.mode := Atmode;
   a^.SwitchL.lwb := Atlwb;
   a^.SwitchL.upb := Atupb;
   a^.SwitchL.CaseLabels := AtCaseLabels;
   a^.SwitchL.DefaultLabel := AtDefaultLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 219/2016 *)
    c:=  12+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 219;
   END;
   Emit.EmitInstruction (e);
 END SwitchL;


 PROCEDURE  TestAndBranch (
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestAndBranch;
   a^.TestAndBranch.cond := Atcond;
   a^.TestAndBranch.tar := Attar;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 220/2036 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 220;
   END;
     (* RULE 221/2044 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 221;
   END;
   Emit.EmitInstruction (e);
 END TestAndBranch;


 PROCEDURE  FixedCompareAndBranch (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFixedCompareAndBranch;
   a^.FixedCompareAndBranch.mode := Atmode;
   a^.FixedCompareAndBranch.rel := Atrel;
   a^.FixedCompareAndBranch.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 222/2052 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 222;
   END;
     (* RULE 223/2059 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntRegOrIm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 223;
   END;
     (* RULE 224/2066 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 224;
   END;
   Emit.EmitInstruction (e);
 END FixedCompareAndBranch;


 PROCEDURE  FloatCompareAndBranch (
                      Atmode  :  CgBase.Mode;
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatCompareAndBranch;
   a^.FloatCompareAndBranch.mode := Atmode;
   a^.FloatCompareAndBranch.rel := Atrel;
   a^.FloatCompareAndBranch.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 225/2073 *)
    c:=  51+     e^.son[1]^.gcg^.cost[ntfreg]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 225;
   END;
     (* RULE 226/2084 *)
    c:=  51+     e^.son[1]^.gcg^.cost[ntCMem]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 226;
   END;
     (* RULE 227/2095 *)
    c:=  51+     e^.son[1]^.gcg^.cost[ntfstack]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 227;
   END;
   Emit.EmitInstruction (e);
 END FloatCompareAndBranch;


 PROCEDURE  SetCompareAndBranch (
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetCompareAndBranch;
   a^.SetCompareAndBranch.rel := Atrel;
   a^.SetCompareAndBranch.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 228/2112 *)
    c:=  9+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.SetCompareAndBranch.rel <= RelUnequal  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 228;
   END;
   END;
     (* RULE 229/2120 *)
    c:=  11+     e^.son[1]^.gcg^.cost[ntreg]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.SetCompareAndBranch.rel > RelUnequal  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 229;
   END;
   END;
   Emit.EmitInstruction (e);
 END SetCompareAndBranch;


 PROCEDURE  PointerCompareAndBranch (
                      Atrel  :  CgBase.Relation;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FixedCompareAndBranch (SignedLong, Atrel, Attar, op1, op2)
 END PointerCompareAndBranch;


 PROCEDURE  TestMembershipAndBranch (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 Coerce (AtElemMode, UnsignedLong, op1, op1);
       TestMembershipAndBranchL (UnsignedLong, Atcond, Attar, op1, op2); 
 END TestMembershipAndBranch;


 PROCEDURE  TestMembershipAndBranchL (
                      AtElemMode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestMembershipAndBranchL;
   a^.TestMembershipAndBranchL.ElemMode := AtElemMode;
   a^.TestMembershipAndBranchL.cond := Atcond;
   a^.TestMembershipAndBranchL.tar := Attar;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 230/2151 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntRegOrIm]+
     e^.son[2]^.gcg^.cost[ntRegOrCMem];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 230;
   END;
   Emit.EmitInstruction (e);
 END TestMembershipAndBranchL;


 PROCEDURE  TestOddAndBranch (
                      Atmode  :  CgBase.Mode;
                      Atcond  :  BOOLEAN;
                      Attar  :  CgBase.Label
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opTestOddAndBranch;
   a^.TestOddAndBranch.mode := Atmode;
   a^.TestOddAndBranch.cond := Atcond;
   a^.TestOddAndBranch.tar := Attar;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 231/2162 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 231;
   END;
   Emit.EmitInstruction (e);
 END TestOddAndBranch;


 PROCEDURE  PreCall (
                      AtParamSize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 INC(CallLevel); 
       IF CallLevel > MaxCallLevel
        THEN CompilerError
        ("Compilerlimit exceeded: Backend: nesting of PROCEDURE-calls to deep!")
       END;
       CurParamOffset[CallLevel] := AtParamSize + ReservedParamFrameSize;
       ParamSize     [CallLevel] := AtParamSize;
       callee := NIL;
       Nil (arglist[CallLevel]); 
 END PreCall;


 PROCEDURE  PassValue (
                      Atmode  :  CgBase.Mode;
                      Atoffset  :  LONGINT
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 IF SizeTable[Atmode] < 4 THEN
	 IF SignedTable[Atmode] THEN
	   Coerce (Atmode, SignedLong, op1, op1);
	   Atmode := SignedLong;
	 ELSE
	   Coerce (Atmode, UnsignedLong, op1, op1);
	   Atmode := UnsignedLong;
	 END;
       END;
       Pass (Atmode, Atoffset,
	     arglist[CallLevel], op1, arglist[CallLevel]);
       CurParamOffset[CallLevel] := Atoffset; 
 END PassValue;


 PROCEDURE  PassLongValue (
                      Atsize  :  LONGINT;
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 PassLong (Atsize, Atoffset, CurParamOffset[CallLevel] - Atoffset, 
		 arglist[CallLevel], op1, arglist[CallLevel]);
       CurParamOffset[CallLevel] := Atoffset; 
 END PassLongValue;


 PROCEDURE  PassOpenArrayValue (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
PassValue (SignedLong, Atoffset, op1)
 END PassOpenArrayValue;


 PROCEDURE  PassStringValue (
                      AtSourceLength  :  LONGINT;
                      AtTargetLength  :  LONGINT;
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
PassLongValue (AtSourceLength, Atoffset, op1)
 END PassStringValue;


 PROCEDURE  PassAddress (
                      Atoffset  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
PassValue (SignedLong, Atoffset, op1)
 END PassAddress;


 PROCEDURE  Call (
                         op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 callee := op1; 
 END Call;


 PROCEDURE  SysCall (
                      Atsysproc  :  CgBase.SysProc
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 RTSCall (ParamSize[CallLevel], Atsysproc, arglist[CallLevel]);
       callee := NIL; 
 END SysCall;


 PROCEDURE  PostCall (
                      Atparamsize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 IF callee # NIL
         THEN ProcedureCall (ParamSize[CallLevel], arglist[CallLevel], callee);
       END;
       DEC (CallLevel); 
 END PostCall;


 PROCEDURE  FunctionResult (
                      Atmode  :  CgBase.Mode
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
 FunctionCall (ParamSize[CallLevel], Atmode, 
		     arglist[CallLevel], callee, result);
       callee := NIL; 
 END FunctionResult;


 PROCEDURE  Nil (
                         VAR result : Arglist);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNil;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 232/2235 *)
   IF 0 <   ga^.cost[ntarglist]  THEN 
     ga^.cost[ntarglist] := 0; 
     ga^.rule[ntarglist] := 232;
   END;
     (* RULE 249/2479 *)
   IF 2 <   ga^.cost[ntloadln2]  THEN 
     ga^.cost[ntloadln2] := 2; 
     ga^.rule[ntloadln2] := 249;
   END;
   MatchChainRules(e);
 END Nil;


 PROCEDURE  SkipArglist (
                         op1  : Arglist
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSkipArglist;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

   Emit.EmitInstruction (e);
 END SkipArglist;


 PROCEDURE  Pass (
                      Atmode  :  CgBase.Mode;
                      Atoffset  :  LONGINT
                      ;  op1  : Arglist
                      ;  op2  : Data
                      ;  VAR result : Arglist);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPass;
   a^.Pass.mode := Atmode;
   a^.Pass.offset := Atoffset;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 233/2237 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntRegOrCMemOrIm];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  SizeTable[e^.attr^.Pass.mode] = 4  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 233;
   END;
   END;
     (* RULE 234/2255 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntarglist]  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 234;
   END;
     (* RULE 235/2261 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntCMem];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  e^.attr^.Pass.mode = FloatLong  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 235;
   END;
   END;
     (* RULE 236/2271 *)
    c:=  47+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntfreg];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  e^.attr^.Pass.mode >= FloatShort  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 236;
   END;
   END;
   MatchChainRules(e);
 END Pass;


 PROCEDURE  PassLong (
                      Atsize  :  LONGINT;
                      Atoffset  :  LONGINT;
                      Atspace  :  LONGINT
                      ;  op1  : Arglist
                      ;  op2  : Data
                      ;  VAR result : Arglist);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPassLong;
   a^.PassLong.size := Atsize;
   a^.PassLong.offset := Atoffset;
   a^.PassLong.space := Atspace;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 237/2280 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntmem];
   IF c <   ga^.cost[ntarglist]  THEN 
   IF  e^.attr^.PassLong.size <= 4  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 237;
   END;
   END;
     (* RULE 238/2290 *)
    c:=  20+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntarglist]  THEN 
     ga^.cost[ntarglist] := c; 
     ga^.rule[ntarglist] := 238;
   END;
   MatchChainRules(e);
 END PassLong;


 PROCEDURE  ProcedureCall (
                      Atparamsize  :  LONGINT
                      ;  op1  : Arglist
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opProcedureCall;
   a^.ProcedureCall.paramsize := Atparamsize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 239/2302 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 239;
   END;
     (* RULE 240/2313 *)
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 240;
   END;
   END;
   Emit.EmitInstruction (e);
 END ProcedureCall;


 PROCEDURE  FunctionCall (
                      Atparamsize  :  LONGINT;
                      Atmode  :  CgBase.Mode
                      ;  op1  : Arglist
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFunctionCall;
   a^.FunctionCall.paramsize := Atparamsize;
   a^.FunctionCall.mode := Atmode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 241/2324 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FunctionCall.mode < FloatShort  THEN 
 ga^.reg.mode := e^.attr^.FunctionCall.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 241;
   END;
   END;
     (* RULE 242/2338 *)
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.cost[ntreg]  THEN 
   IF  e^.attr^.FunctionCall.mode < FloatShort  THEN 
 ga^.reg.mode := e^.attr^.FunctionCall.mode; ;
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 242;
   END;
   END;
   END;
     (* RULE 243/2352 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist]+
     e^.son[2]^.gcg^.cost[ntreg];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  e^.attr^.FunctionCall.mode >= FloatShort  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 243;
   END;
   END;
     (* RULE 244/2366 *)
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  e^.attr^.FunctionCall.mode >= FloatShort  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 244;
   END;
   END;
   END;
     (* RULE 246/2404 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sqrt') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sqrtL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 246;
   END;
   END;
   END;
   END;
   END;
     (* RULE 247/2413 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_exp') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_expL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 247;
   END;
   END;
   END;
   END;
   END;
     (* RULE 248/2454 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
    c:=  5+     e2^.son[1]^.gcg^.cost[ntloadln2]+
     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_ln') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_lnL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 248;
   END;
   END;
   END;
   END;
     (* RULE 250/2486 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sin') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_sinL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 250;
   END;
   END;
   END;
   END;
   END;
     (* RULE 251/2495 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_cos') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_cosL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 251;
   END;
   END;
   END;
   END;
   END;
     (* RULE 252/2504 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_arctan') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_arctanL')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 252;
   END;
   END;
   END;
   END;
   END;
     (* RULE 253/2518 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  5+     e2^.son[2]^.gcg^.cost[ntCMem];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_real') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LFLOAT')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 253;
   END;
   END;
   END;
   END;
   END;
     (* RULE 254/2530 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  10+     e2^.son[2]^.gcg^.cost[ntreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntfreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_real') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LFLOAT')  THEN 
     ga^.cost[ntfreg] := c; 
     ga^.rule[ntfreg] := 254;
   END;
   END;
   END;
   END;
   END;
     (* RULE 255/2544 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_realL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LFLOAT')  THEN 
 ga^.FloatConstant.mode := FloatLong;
	  ga^.FloatConstant.val  := LFLOAT(e^.son[1]^.son[2]^.gcg^.Constant.val); ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 255;
   END;
   END;
   END;
   END;
   END;
     (* RULE 256/2552 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntFloatConstant]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_real')  THEN 
 ga^.FloatConstant.mode := FloatShort;
	  ga^.FloatConstant.val  := real(e^.son[1]^.son[2]^.gcg^.Constant.val); ;
     ga^.cost[ntFloatConstant] := c; 
     ga^.rule[ntFloatConstant] := 256;
   END;
   END;
   END;
   END;
   END;
     (* RULE 257/2559 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=  10+     e2^.son[2]^.gcg^.cost[ntfreg];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntreg]  THEN 
   IF  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entier') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entierL') OR
	 StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LTRUNC')  THEN 
     ga^.cost[ntreg] := c; 
     ga^.rule[ntreg] := 257;
   END;
   END;
   END;
   END;
   END;
     (* RULE 258/2573 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = opPass THEN 
   IF e2^.son[1]^.attr^.op = opNil THEN 
    c:=       e2^.son[2]^.gcg^.cost[ntFloatConstant];
   IF e^.son[2]^.attr^.op = opProcedureConstant THEN 
   IF c <   ga^.cost[ntConstant]  THEN 
   IF  (StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entier') OR
	  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_MathLib_entierL') OR
	  StrEq (e^.son[2]^.attr^.ProcedureConstant.index^.Entry^, '_LTRUNC')) AND
	 (e^.son[1]^.son[2]^.gcg^.FloatConstant.val <= LFLOAT(MAX(INTEGER))) AND
	 (e^.son[1]^.son[2]^.gcg^.FloatConstant.val >= LFLOAT(MIN(INTEGER)))  THEN 
 ga^.Constant.mode := SignedLong;
	  ga^.Constant.val  := LTRUNC(e^.son[1]^.son[2]^.gcg^.FloatConstant.val); ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 258;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END FunctionCall;


 PROCEDURE  RTSCall (
                      Atparamsize  :  LONGINT;
                      Atsysproc  :  CgBase.SysProc
                      ;  op1  : Arglist
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRTSCall;
   a^.RTSCall.paramsize := Atparamsize;
   a^.RTSCall.sysproc := Atsysproc;
   e^.arity := 1;
   e^.son[1] := op1;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 245/2380 *)
    c:=  100+     e^.son[1]^.gcg^.cost[ntarglist];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 245;
   END;
   Emit.EmitInstruction (e);
 END RTSCall;


 PROCEDURE  BeginProcedure (
                      Atindex  :  CgBase.ProcIndex;
                      Atlevel  :  SHORTCARD;
                      AtFrameSize  :  LONGINT;
                      AtParamSize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opBeginProcedure;
   a^.BeginProcedure.index := Atindex;
   a^.BeginProcedure.level := Atlevel;
   a^.BeginProcedure.FrameSize := AtFrameSize;
   a^.BeginProcedure.ParamSize := AtParamSize;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 260/2601 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 260;
   END;
   Emit.EmitInstruction (e);
 END BeginProcedure;


 PROCEDURE  CopyOpenArray (
                      AtDataOffset  :  LONGINT;
                      AtHighOffset  :  LONGINT;
                      Atelemsize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opCopyOpenArray;
   a^.CopyOpenArray.DataOffset := AtDataOffset;
   a^.CopyOpenArray.HighOffset := AtHighOffset;
   a^.CopyOpenArray.elemsize := Atelemsize;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 261/2681 *)
   IF 20 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 20; 
     ga^.stmtrule := 261;
   END;
   Emit.EmitInstruction (e);
 END CopyOpenArray;


 PROCEDURE  Return (
                      AtParamSize  :  LONGINT
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opReturn;
   a^.Return.ParamSize := AtParamSize;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 262/2729 *)
   IF 20 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 20; 
     ga^.stmtrule := 262;
   END;
   Emit.EmitInstruction (e);
 END Return;


 PROCEDURE  ReturnValueL (
                      Atmode  :  CgBase.Mode
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opReturnValueL;
   a^.ReturnValueL.mode := Atmode;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 263/2753 *)
    c:=       e^.son[1]^.gcg^.cost[ntreg];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.ReturnValueL.mode < FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 263;
   END;
   END;
     (* RULE 264/2756 *)
    c:=       e^.son[1]^.gcg^.cost[ntfreg];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.ReturnValueL.mode >= FloatShort  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 264;
   END;
   END;
   Emit.EmitInstruction (e);
 END ReturnValueL;


 PROCEDURE  ReturnValue (
                      Atmode  :  CgBase.Mode;
                      AtParamSize  :  LONGINT
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
ReturnValueL (Atmode, op1);
      Return (AtParamSize);
 END ReturnValue;


 PROCEDURE  EndProcedure (
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opEndProcedure;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 265/2762 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 265;
   END;
   Emit.EmitInstruction (e);
 END EndProcedure;


 PROCEDURE  EndModule (
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opEndModule;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 266/2796 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 266;
   END;
   Emit.EmitInstruction (e);
 END EndModule;


 PROCEDURE  Mark (
                      Atline  :  SHORTCARD;
                      Atcol  :  SHORTCARD
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opMark;
   a^.Mark.line := Atline;
   a^.Mark.col := Atcol;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 267/2819 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 267;
   END;
   Emit.EmitInstruction (e);
 END Mark;


 BEGIN 
    FirstAttr := NIL; MemExtend;
(******* empty insertion IpIRConsInit *******)
 
 END CgMobil.
