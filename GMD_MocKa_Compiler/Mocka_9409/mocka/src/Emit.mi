  (**************************************************************) 
  (*   This module was generated by BEG V1.75        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
IMPLEMENTATION MODULE Emit;
IMPORT IR;
IMPORT  RegAlloc;
FROM    RegAlloc IMPORT Spilllocation, Action;
(******* empty insertion IpInOut *******)
FROM    InOut IMPORT Write, WriteLn, WriteInt, WriteCard, WriteString;
FROM IR      IMPORT PrintRegister;
FROM IR      IMPORT PrintINTEGER, PrintCARDINAL, PrintBOOLEAN;
(*++++++ start insertion IpTestImport ++++++*)

FROM	Prints	IMPORT	PrintSHORTCARD, PrintLONGCARD, PrintSHORTINT,
			PrintLONGINT, PrintDataTempo, PrintAddressTempo,
			PrintSysProc, PrintLabelList, PrintLabel,
			PrintMode, PrintString, PrintStringIndex, PrintLONGREAL,
			PrintREAL, PrintBITSET, PrintProcIndex, PrintRelation,
			PrintModuleIndex, PrintCHAR, PrintADDRESS,
			PrintRelSymb, PrintMemAdr, PrintAdrMode;


(*------ end   insertion IpTestImport ------*)
FROM    IR      IMPORT NonTerminal, RegisterSet, Register;
(*++++++ start insertion IpNtTypes ++++++*)

FROM IR	IMPORT	MemAdr, AdrMode, AdrModeMode;


(*------ end   insertion IpNtTypes ------*)
(******* empty insertion IpText *******)
(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;
FROM Strings	IMPORT	String;


(*------ end   insertion IpTypes ------*)
(*++++++ start insertion IpEmit_i ++++++*)

IMPORT	SuBase, BasicIO;
FROM	GcgStorage	IMPORT	ALLOCATE;
FROM	SuBase		IMPORT	BuildLibraryFileName, KindAssemblerSourceFile,
				FileName, AssemblerScript, LibraryDirectory;
FROM	SuErrors	IMPORT	ERROR, CompilerError, UndefSourcePos, OK;
FROM	CgBase		IMPORT	Tempo, Mode,  SysProc, Relation, MakeRelSymb,
				GetLabel, InitCgBase;
FROM	CgTypeMap	IMPORT	ByteSize, WordSize, LongSize,
				SizeREAL, SizeLONGREAL,
				CprocNumber, CompUnitProcNumber;
FROM	CgMobil		IMPORT	UndefOperand;
FROM	CgUtilities	IMPORT	StringAssign, StringLength,
				StringAppend1, StringAppend2, StringConcat2, 
				ConvertLONGINTtoString, ConvertREALtoString,
				IsPowerOfTwo, Log2;
FROM	CgAssOut	IMPORT	AssInt, AssLn, AssChar, AssString, AssHString,
				AssOpen, AssClose;
FROM	SysLib		IMPORT	exit;

(* Control lines for the dottool: *)
















CONST	MaxDisplay	= 15;		(* Max. nesting Level of procedures *)
	MaxFloatTempo	= 64;		(* Max. size of Float-Stack	    *)
	MaxPowerTable	= 31;
	NoTempo		= 1111111111;

	Kommentar	= FALSE;	(* Kommentare ein/aus		    *)
VAR
    RelationTable    : ARRAY CgBase.Relation OF
			 ARRAY [FALSE..TRUE] OF ARRAY [0..2] OF CHAR;
			   (* maps Relation into e,ne,g,ge,l,le,a,ae,b,be  *)

    Reverse	     : ARRAY CgBase.Relation OF CgBase.Relation;
			   (* maps Relation into reverse Relation	   *)
    
    PowerTable       : ARRAY [0 .. MaxPowerTable] OF LONGINT;
                           (* powers of two, 1 <= 2^n <= 2^MaxPowerTable   *)

    WordReg, ByteReg : ARRAY Register OF ARRAY [0..4] OF CHAR;
			   (* maps to register parts                       *)

    SaveDisplay	     : ARRAY [0 .. MaxDisplay] OF BOOLEAN;
                           (* SaveDisplay [i] = TRUE <==> save display of  *)
                           (* current procedure level                      *)

    FStackTempo	     : ARRAY [0 .. MaxFloatTempo-1] OF CgBase.Tempo;
			   (* temporaries if FloatingPoint-Stack overflows *)

    TransferTempo    : CgBase.Tempo;
			   (* temporary for reg <-> freg transfers *)
			  
    oEmitIR, oEmitMatch, oRegAlloc, oAssemblerListing : CARDINAL;

    AsmListFileName	: FileName;
    ModName		: ARRAY [0..80] OF CHAR;

    CurFrameSize	: LONGINT;

    CurFStackSize	: INTEGER;
    FStackStart		: INTEGER;
	
    ProcLabel		: CgBase.Label;

(* local Variables for Emit-Routines *)
VAR   
	lab, lab2	: CgBase.Label;
	i,j             : LONGINT;
	k		: SHORTCARD;
	str, cmd        : ARRAY [0..255] OF CHAR;
	ok		: BOOLEAN;	
	tr1		: RECORD 
			    CASE : BOOLEAN OF
			    | TRUE : r : REAL;
			    | FALSE : c : LONGINT;
			    END;
			  END;
	tr2		: RECORD 
			    CASE : BOOLEAN OF
			    | TRUE : r : LONGREAL;
			    | FALSE : c2, c1 : LONGINT;
			    END;
			  END;


PROCEDURE   LR  (to, from : Register);
(*  Copy Register from into Register to *)
BEGIN
 AssHString(' 	movl	'); AssRegister(from); AssHString(', '); AssRegister(to); AssLn;
	IF Kommentar THEN
 AssHString('					/* LR */'); AssLn;
	END;
END LR;

PROCEDURE   Spill (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
 AssHString('	pushl	'); AssRegister(reg); AssLn;
	IF Kommentar THEN
 AssHString('					/* Spill */'); AssLn;
	END;
  ELSE
	IF Kommentar THEN
 AssHString(' 					/* Spill '); AssRegister(reg); AssHString(' */'); AssLn;
	END;
  END;
END Spill;

PROCEDURE   Restore (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
 AssHString('	popl	'); AssRegister(reg); AssLn;
	IF Kommentar THEN
 AssHString('					/* Restore */'); AssLn;
	END;
  ELSE
	IF Kommentar THEN
 AssHString(' 					/* Restore '); AssRegister(reg); AssHString(' */'); AssLn;
	END;
  END;
END Restore;


PROCEDURE SpillFStack;
  VAR i : INTEGER;
BEGIN
  FOR i:=0 TO CurFStackSize - 1 DO
    DeclareTempo (FloatLong, FStackTempo[FStackStart + i]);
 AssHString('	fstpl	'); AssInt ( FStackTempo[FStackStart + i]); AssHString('(%ebp)'); AssLn;
    IF Kommentar THEN
 AssHString('					/* SpillFstack */'); AssLn;
    END;
  END;
  CurFStackSize := 0;
END SpillFStack;

PROCEDURE PushFStack;
(* Ueberpruefung auf Floating-Point-Stack Ueberlauf *)
(* wird vor jedem push auf den 387 Stack aufgerufen *)
BEGIN
  IF CurFStackSize = 8 THEN
    (* tiefstes Stackelement als Tempo in den Speicher legen *)
    DeclareTempo (FloatLong, FStackTempo[FStackStart + 7]);
 AssHString('	fxch	%st(7)'); AssLn;
 AssHString('	fstl	'); AssInt ( FStackTempo[FStackStart + 7]); AssHString('(%ebp)'); AssLn;
 AssHString('	fxch	%st(7)'); AssLn;
 AssHString('	ffree	%st(7)'); AssLn;
  ELSE
    INC (CurFStackSize);
  END;
  DEC (FStackStart);
  FStackTempo[FStackStart] := NoTempo;
END PushFStack;

PROCEDURE PopFStack;
(* wird nach jedem pop auf den 387 Stack aufgerufen *)
BEGIN
  INC (FStackStart);
  DEC (CurFStackSize);
END PopFStack;

PROCEDURE FloatOperation (VAR op: ARRAY OF CHAR);
BEGIN
  INC (FStackStart);
  IF FStackTempo[FStackStart] # NoTempo THEN
 AssHString('	'); AssString( op); AssHString('l	'); AssInt ( FStackTempo[FStackStart]); AssHString('(%ebp)'); AssLn;
    FStackTempo[FStackStart] := NoTempo;
  ELSE
 AssHString('	'); AssString( op); AssHString('p	%st,%st(1)'); AssLn;
    DEC (CurFStackSize);
  END;
END FloatOperation;


PROCEDURE IsNilMemAdr (a: MemAdr) : BOOLEAN;
BEGIN
  RETURN (a.offset = 0) AND
	 (a.faktor = 0) AND
	 (a.base = RegNil) AND
	 (a.symbol = NullSymb)
END IsNilMemAdr;

PROCEDURE EmitIndex (VAR base : MemAdr; index : MemAdr; reg : Register);
BEGIN
  IF NOT IsNilMemAdr (index)
   THEN base.index := reg;
 AssHString('	movl	'); AssMemAdr( index); AssHString(','); AssRegister(reg); AssLn;
  END (* IF *);
END EmitIndex;


PROCEDURE AssRegister (r : Register);
BEGIN
   AssChar ('%');
   IF r # Regst1
     THEN AssString (IR.RegNameTable[r]);
     ELSE AssString ('st(1)');
   END;
END AssRegister;

PROCEDURE AssRegister2 (r : Register; mode: CgBase.Mode);
BEGIN
  CASE SizeTable[mode] OF
  | 1: AssString (ByteReg[r]);
  | 2: AssString (WordReg[r]);
  | 4,8: AssChar ('%'); AssString (IR.RegNameTable[r]);
    ELSE ERROR ('Backend: Unknown Size in AssRegisterPart', UndefSourcePos);
  END;
END AssRegister2;

PROCEDURE AssWordRegister (r : Register);
BEGIN
   AssString (WordReg[r])
END AssWordRegister;

PROCEDURE AssByteRegister (r : Register);
BEGIN
   AssString (ByteReg[r])
END AssByteRegister;

PROCEDURE AssPlusInt  (i : LONGINT);
BEGIN
   IF i>=0 THEN
      AssString (' + ')
   ELSE
      AssString (' - ')
   END;
   AssInt (ABS (i));
END AssPlusInt;

PROCEDURE AssMemAdr (am: MemAdr);
BEGIN
  WITH am DO
    IF symbol # NullSymb
      THEN AssString (symbol^);
	   IF offset # 0
	     THEN AssPlusInt (offset)
	   END;
      ELSE IF offset # 0
	     THEN AssInt (offset)
	   END;
    END;
    IF (base > RegNil) OR ((index > RegNil) AND (faktor > 0))
      THEN IF (base = RegNil) AND (faktor = 1)
	     THEN base := index;
		  faktor := 0;
	   END; (* IF *)
	   AssChar ('(');
	   IF (base > RegNil)
	     THEN AssRegister(base);
	   END;
	   IF (index > RegNil) AND (faktor > 0)
	     THEN AssChar (',');
		  AssRegister (index);
		  AssChar (',');
		  AssInt (faktor);
	   END;
	   AssChar (')');
    END;
  END;
END AssMemAdr;

PROCEDURE AssAdrMode (am: AdrMode);
BEGIN
  WITH am DO
    CASE kind OF
    | Mconst : AssChar ('$'); AssInt (constant);
    | Mreg   : AssRegister2 (reg,mode);
    | Mmem   : AssMemAdr (mem);
    END;
  END;
END AssAdrMode;

PROCEDURE AssSuffix (s: CgBase.Mode);
BEGIN
  AssChar (SuffixTable[s]);
END AssSuffix;

PROCEDURE AssSigned (s: CgBase.Mode);
BEGIN
  IF SignedTable[s]
    THEN AssChar ('s')
    ELSE AssChar ('z')
  END;
END AssSigned;


PROCEDURE DeclareModule
   (    extern       : BOOLEAN;
    VAR CompUnitName : ARRAY OF CHAR; 
    VAR ref          : CgBase.ModuleIndex);
  VAR str : String;
BEGIN
   NEW (ref);
   WITH ref^ DO
      Extern := extern;
      StringAssign (str,'_');
      StringAppend1 (str, CompUnitName);      
      Name := MakeRelSymb (str);
      StringAppend1 (str,'_s');
      Statics := MakeRelSymb (str);
   END;
END DeclareModule;


PROCEDURE DeclareProcedure
   (    extern       : BOOLEAN;
	isFunction   : BOOLEAN;
	ProcMode     : CgBase.Mode;
    VAR ProcName     : ARRAY OF CHAR; 
        ProcNumber   : SHORTCARD;
        module       : CgBase.ModuleIndex;
	level        : SHORTCARD;
	father       : CgBase.ProcIndex;
    VAR ref          : CgBase.ProcIndex);
  VAR s,t : String;
BEGIN
  NEW (ref);
  WITH ref^ DO 
     Extern := extern; IsFunction := isFunction;
     Name := MakeRelSymb (ProcName); Number := ProcNumber;
     Module := module; Level := level; Father := father;

     IF ProcNumber # CprocNumber THEN 

 	IF level = 0 THEN 
	   StringAssign (t,module^.Name^);
	ELSE
	   StringAssign (t,father^.Entry^);
	END;

        IF StringLength(t)+1+StringLength(ProcName)>=80 THEN 
	   (* Produce Name and Number   *)
	   ConvertLONGINTtoString (ProcNumber,s);
	   StringAssign (t,module^.Name^);
	   StringAppend1(t,'_');
	   StringAppend1(t,ProcName);
	   StringAppend1(t,'_');
	   StringAppend1(t,s);                  
	ELSE
	   IF ProcNumber # CompUnitProcNumber
	     THEN StringAppend2 (t,'_',ProcName);
	   END;
	END;
	Entry := MakeRelSymb (t);
     ELSE (* ProcNumber = CprocNumber *)
        StringConcat2(t,'_',ProcName);
	Entry := MakeRelSymb(t);
     END;
 AssHString('	.globl	'); AssString( Entry^); AssLn;
  END;
END DeclareProcedure;


PROCEDURE DeclareString
   (    length : SHORTCARD;
    VAR string : ARRAY OF CHAR; 
    VAR ref    : CgBase.StringIndex);
  VAR l   : CARDINAL;
      c   : CHAR;
      numbersNeedRestart: BOOLEAN;
BEGIN
   numbersNeedRestart:=FALSE;
   GetLabel (ref);
 AssHString('	.data'); AssLn;
 AssString( ref^); AssHString(':'); AssLn;
 AssHString(' 	.ascii	"');
   FOR l := 0 TO length - 1 DO
      c := string[l];
      IF numbersNeedRestart AND ('0'<=c) AND (c<='9') THEN	(* Restart *)
 AssHString('"'); AssLn;
 AssHString('	.ascii	"');
      END;
      IF (' ' <= c) AND (c <= 'z') AND (c # 42C) AND (c # '\') THEN 
	 AssChar (c);
         numbersNeedRestart:=FALSE;
      ELSE
	 IF l < length - 1 THEN
	    AssChar ('\');
 AssInt ( ORD (c) DIV 64); AssInt ( (ORD (c) MOD 64) DIV 8); AssInt ( ORD (c) MOD 8);
	 END;
         numbersNeedRestart:=TRUE;
      END;
   END;
   AssString ('\000"'); AssLn;
 AssHString('	.text'); AssLn;
END DeclareString;


PROCEDURE DeclareTempo (mode: CgBase.Mode; VAR tempo: CgBase.Tempo);
BEGIN
  IF mode = FloatLong
    THEN INC(CurFrameSize, 8);
    ELSE INC(CurFrameSize, 4);
  END;
  tempo := -CurFrameSize;
END DeclareTempo;

PROCEDURE DeclareTransferTempo;
BEGIN
  IF TransferTempo = NoTempo
    THEN DeclareTempo (FloatShort, TransferTempo);
  END;
END DeclareTransferTempo;

PROCEDURE  BeginModule
   (AtModulName  :  ARRAY OF CHAR;
    AtFrameSize  :  LONGINT);
BEGIN
   CallLevel := 0;

   DisplaySym := MakeRelSymb ('DISPLAY_');

   FOR i := 0 TO MaxDisplay DO SaveDisplay [i] := FALSE; END;

   IR.OptEmitIR		:= SuBase.Enabled (oEmitIR);
   IR.OptEmitMatch	:= SuBase.Enabled (oEmitMatch);
   IR.OptRegAlloc	:= SuBase.Enabled (oRegAlloc);

   BuildLibraryFileName (AtModulName,
			 KindAssemblerSourceFile, AsmListFileName);
   AssOpen (AsmListFileName);
   StringAssign (ModName, AtModulName);

   InitCgBase;

   IF AtFrameSize > 0 THEN
 AssHString('	.comm	_'); AssString( AtModulName); AssHString('_s, '); AssInt ( 4 * ((ABS(AtFrameSize)+3) DIV 4)); AssLn;
   END;
 AssHString('	.text'); AssLn;
END BeginModule;


(*------ end   insertion IpEmit_i ------*)

 VAR ai : CARDINAL;
      localavail : RegisterSet;

(******* empty insertion IpEmit *******)
TYPE   NtAttributes = RECORD
           CASE  : IR.NonTerminal OF 
    | ntreg : reg : RECORD
     END;
    | ntfreg : freg : RECORD
     END;
    | ntfstack : fstack : RECORD
     END;
    | ntConstant : Constant : RECORD
     END;
    | ntFloatConstant : FloatConstant : RECORD
     END;
    | ntSimpleVariable : SimpleVariable : RECORD
     END;
    | ntSymPlusOffset : SymPlusOffset : RECORD
                     symbol  :  CgBase.RelSymb;
     END;
    | ntRegPlusSymPlusOffset : RegPlusSymPlusOffset : RECORD
                     base  :  Register;
                     symbol  :  CgBase.RelSymb;
     END;
    | ntOffsetPlusIndexMultFaktor : OffsetPlusIndexMultFaktor : RECORD
                     index  :  Register;
     END;
    | ntmem : mem : RECORD
                     am  :  MemAdr;
     END;
    | ntCMem : CMem : RECORD
                     am  :  MemAdr;
     END;
    | ntRegOrIm : RegOrIm : RECORD
                     am  :  AdrMode;
     END;
    | ntRegOrCMem : RegOrCMem : RECORD
                     am  :  AdrMode;
     END;
    | ntRegOrCMemOrIm : RegOrCMemOrIm : RECORD
                     am  :  AdrMode;
     END;
    | ntarglist : arglist : RECORD
     END;
    | ntloadln2 : loadln2 : RECORD
     END;
           END;
   END;

PROCEDURE PerformActions (ai : RegAlloc.AllocIndex);
VAR i : CARDINAL;
BEGIN
   WITH RegAlloc.allocation [ai] DO
      FOR i:=1 TO num DO 
	 WITH a[i] DO
	    IF action=aLr THEN   
             LR (regto, regfrom);
    IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (regfrom);
                WriteString (' into ');
                PrintRegister (regto);
                WriteLn;
    END;
	    ELSE 
	       Restore (reg, spilllocation);
    IF IR.OptEmitMatch THEN 
                WriteString (' Restore Register ');
                PrintRegister (reg);
                WriteString (' from ');
                WriteInt (spilllocation,1);
                WriteLn;
    END;
         END;
	 END;
     END;
  END;
END PerformActions;
 
PROCEDURE WriteNest (i : INTEGER);
VAR j : INTEGER;
BEGIN
   FOR j:=1 TO i DO WriteString ('.  '); END;
END WriteNest;
PROCEDURE WriteAttrreg (at: NtAttributes);
BEGIN
END WriteAttrreg;
PROCEDURE WriteAttrfreg (at: NtAttributes);
BEGIN
END WriteAttrfreg;
PROCEDURE WriteAttrfstack (at: NtAttributes);
BEGIN
END WriteAttrfstack;
PROCEDURE WriteAttrConstant (at: NtAttributes);
BEGIN
END WriteAttrConstant;
PROCEDURE WriteAttrFloatConstant (at: NtAttributes);
BEGIN
END WriteAttrFloatConstant;
PROCEDURE WriteAttrSimpleVariable (at: NtAttributes);
BEGIN
END WriteAttrSimpleVariable;
PROCEDURE WriteAttrSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('symbol=');
       PrintRelSymb ( at.SymPlusOffset.symbol ); 
       Write (' ');
END WriteAttrSymPlusOffset;
PROCEDURE WriteAttrRegPlusSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('base=');
       PrintRegister ( at.RegPlusSymPlusOffset.base ); 
       Write (' ');
       WriteString ('symbol=');
       PrintRelSymb ( at.RegPlusSymPlusOffset.symbol ); 
       Write (' ');
END WriteAttrRegPlusSymPlusOffset;
PROCEDURE WriteAttrOffsetPlusIndexMultFaktor (at: NtAttributes);
BEGIN
       WriteString ('index=');
       PrintRegister ( at.OffsetPlusIndexMultFaktor.index ); 
       Write (' ');
END WriteAttrOffsetPlusIndexMultFaktor;
PROCEDURE WriteAttrmem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.mem.am ); 
       Write (' ');
END WriteAttrmem;
PROCEDURE WriteAttrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.CMem.am ); 
       Write (' ');
END WriteAttrCMem;
PROCEDURE WriteAttrRegOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrIm.am ); 
       Write (' ');
END WriteAttrRegOrIm;
PROCEDURE WriteAttrRegOrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMem.am ); 
       Write (' ');
END WriteAttrRegOrCMem;
PROCEDURE WriteAttrRegOrCMemOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMemOrIm.am ); 
       Write (' ');
END WriteAttrRegOrCMemOrIm;
PROCEDURE WriteAttrarglist (at: NtAttributes);
BEGIN
END WriteAttrarglist;
PROCEDURE WriteAttrloadln2 (at: NtAttributes);
BEGIN
END WriteAttrloadln2;

PROCEDURE EmitNtreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntreg] OF 
   | 257 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 257/2559 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$4,%esp'); AssLn;
 AssHString('	fistpl	(%esp)'); AssLn;
 AssHString('	popl	'); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 242 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 242/2338 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
 AssHString('	call	'); AssString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
   | 241 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 241/2324 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
 AssHString('	call	'); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
   | 216 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 216/1991 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestOdd ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	and'); AssSuffix( e^.attr^.TestOdd.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode); AssLn;
	IF NOT e^.attr^.TestOdd.cond THEN
 AssHString('	xor'); AssSuffix( e^.attr^.TestOdd.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode); AssLn;
	END;
	
   | 215 : 
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 215/1979 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestMembershipL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	btl	'); AssAdrMode( AT0.RegOrIm.am); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
	IF e^.attr^.TestMembershipL.cond THEN
 AssHString('	setb	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	ELSE
 AssHString('	setnb	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	END;
	
   | 214 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 214/1947 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	movl	'); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	CASE e^.attr^.SetCompare.rel OF
	| RelLess:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelLessOrEqual:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelEqual;
	| RelGreater:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelGreaterOrEqual:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
	e^.attr^.SetCompare.rel := RelEqual;
	END;
 AssHString('	cmpl	'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.SetCompare.rel][FALSE]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 213 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 213/1938 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmpl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.SetCompare.rel][FALSE]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 212 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 212/1920 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
 AssHString('	fcompl	'); AssInt ( FStackTempo[FStackStart]); AssHString('(%ebp)'); AssLn;
	  DEC (CurFStackSize);
	ELSE
 AssHString('	fcompp'); AssLn;
	  DEC (CurFStackSize, 2);
	END;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	set'); AssString( RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 211 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 211/1908 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	fcomp'); AssSuffix( e^.son[1]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	set'); AssString( RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 210 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 210/1896 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	fcomp'); AssSuffix( e^.son[2]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.FloatCompare.rel][SignedTable[e^.attr^.FloatCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 209 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 209/1888 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompare.mode); AssHString('	$'); AssInt ( e^.son[1]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
 AssHString('	set'); AssString( RelationTable[Reverse[e^.attr^.FixedCompare.rel]][SignedTable[e^.attr^.FixedCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 208 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 208/1880 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompare.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 207 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 207/1872 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompare.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedCompare.mode); AssLn;
 AssHString('	set'); AssString( RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]); AssHString('	'); AssByteRegister ( RegAlloc.allocation[ai].reg); AssLn;
	
   | 205 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 205/1830 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	push'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssAdrMode( AT2.RegOrCMemOrIm.am); AssLn;
 AssHString('	push'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssLn;
 AssHString('	bound'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode); AssHString(',(%esp)'); AssLn;
 AssHString('	addl	$'); AssInt ( 2*SizeTable[e^.son[1]^.gcg^.reg.mode]); AssHString(',%esp'); AssLn;
	
   | 204 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 204/1807 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
 AssHString('	.data'); AssLn;
	CASE SizeTable[e^.son[1]^.gcg^.reg.mode] OF
	| 4:
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.long	'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssHString(','); AssInt ( e^.son[3]^.gcg^.Constant.val); AssLn;
	| 2:
 AssHString('	.align 2'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.word	'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssHString(','); AssInt ( e^.son[3]^.gcg^.Constant.val); AssLn;
	END;
 AssHString('	.text'); AssLn;
 AssHString('	bound'); AssSuffix( e^.son[1]^.gcg^.reg.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode); AssHString(','); AssString( lab^); AssLn;
	
   | 203 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 203/1802 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 197 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 197/1742 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 196 : 
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 196/1729 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF SignedTable[e^.attr^.Coerce.premode] AND SignedTable[e^.attr^.Coerce.postmode] THEN
 AssHString('	movs'); AssSuffix( e^.son[1]^.gcg^.RegOrCMem.mode); AssSuffix( e^.attr^.Coerce.postmode); AssHString('	'); AssAdrMode( AT0.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode); AssLn;
	ELSE
 AssHString('	movz'); AssSuffix( e^.son[1]^.gcg^.RegOrCMem.mode); AssSuffix( e^.attr^.Coerce.postmode); AssHString('	'); AssAdrMode( AT0.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode); AssLn;
	END;
	
   | 188 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 188/1648 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Trunc ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
 AssHString('	fcoml	TwoExp31_'); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jb	'); AssString( lab^); AssLn;
 AssHString('	fsubl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	subl	$4,%esp'); AssLn;
 AssHString('	fistpl	(%esp)'); AssLn;
 AssHString('	popl	'); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	PopFStack;
	
   | 183 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 183/1598 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Cap ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 GetLabel(lab);
 AssHString('	cmpb	$'); AssInt ( ORD('a')); AssHString(','); AssByteRegister ( RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	jl	'); AssString( lab^); AssLn;
 AssHString('	cmpb	$'); AssInt ( ORD('z')); AssHString(','); AssByteRegister ( RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	jg	'); AssString( lab^); AssLn;
 AssHString('	subb	$'); AssInt ( ORD('a') - ORD('A')); AssHString(','); AssByteRegister ( RegAlloc.allocation[ai].op[1]); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 182 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
  EmitNtreg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 182/1576 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 GetLabel(lab);
 AssHString(' 	sub'); AssSuffix( e^.attr^.SetPlusRange.LwbMode); AssHString(' 	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( Regecx,e^.attr^.SetPlusRange.LwbMode); AssLn;
 AssHString(' 	jl	'); AssString( lab^); AssLn;
 AssHString('	incb	%cl'); AssLn;
 AssHString('	movl	$-1,'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	shll	%cl,'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	notl	'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	mov'); AssSuffix( e^.attr^.SetPlusRange.LwbMode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( Regecx,e^.attr^.SetPlusRange.LwbMode); AssLn;
 AssHString('	shll	%cl,'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssLn;
 AssHString('	orl	'); AssRegister(RegAlloc.allocation[ai].scr[1]); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
       
   | 181 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 181/1570 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	orl	$'); AssInt ( PowerTable[e^.son[3]^.gcg^.Constant.val+1]-PowerTable[e^.son[2]^.gcg^.Constant.val]); AssHString(','); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 180 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 180/1564 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	btsl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 179 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 179/1558 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	orl	$'); AssInt ( PowerTable[e^.son[2]^.gcg^.Constant.val]); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 176 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 176/1535 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	xorl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 175 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 175/1535 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	xorl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssHString(' '); AssLn;
   | 172 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 172/1516 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	andl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 171 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 171/1516 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	andl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssHString(' '); AssLn;
   | 168 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 168/1481 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString(' 	andl	$'); AssInt ( INTEGER(BITSET(-1) - BITSET(e^.son[2]^.gcg^.Constant.val))); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
	
   | 167 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 167/1472 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	notl	'); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
 AssHString(' 	andl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	
   | 164 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 164/1453 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	orl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' '); AssLn;
   | 163 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 163/1453 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	orl	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(', '); AssRegister(RegAlloc.allocation[ai].op[2]); AssHString(' '); AssLn;
   | 144 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 144/1366 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cwd'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode); AssLn;
	
   | 143 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 143/1355 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	mov'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	$0,'); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode); AssLn;
 AssHString('	div'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode); AssLn;
	
   | 142 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 142/1344 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cdq'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode); AssLn;
	
   | 140 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 140/1323 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	and'); AssSuffix( e^.attr^.FixedMod.mode); AssHString('	$'); AssInt ( e^.son[2]^.gcg^.Constant.val-1); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMod.mode); AssHString(' '); AssLn;
   | 138 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 138/1306 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cwd'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode); AssLn;
	
   | 137 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 137/1294 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	mov'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	$0,'); AssRegister2 ( Regedx,e^.attr^.FixedDiv.mode); AssLn;
 AssHString('	div'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode); AssLn;
	
   | 136 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 136/1282 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	cdq'); AssLn;
 AssHString('	idiv'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode); AssLn;
	
   | 133 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 133/1251 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	sar'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	$'); AssInt ( Log2 (e^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode); AssHString(' '); AssLn;
   | 131 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 131/1228 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	shr'); AssSuffix( e^.attr^.FixedDiv.mode); AssHString('	$'); AssInt ( Log2 (e^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode); AssHString(' '); AssLn;
   | 129 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 129/1213 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 127 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 127/1187 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	mul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 125 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 125/1157 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	EmitIndex (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[ai].reg);
 AssHString('	mov'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssMemAdr( e^.son[1]^.son[1]^.gcg^.SimpleVariable.base); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssLn;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssLn;
	
   | 124 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 124/1151 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( e^.son[1]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 123 : 
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 123/1151 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT0.RegOrCMem.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 122 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 122/1144 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 121 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 121/1144 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	imul'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 112 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 112/1076 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 111 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 111/1076 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 102 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 102/1030 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	
   | 101 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 101/1030 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	
   | 100 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 100/1023 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 99 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 99/1023 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	add'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssHString(' '); AssLn;
   | 96 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 96/1010 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 95 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 95/1010 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 88 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 88/960 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMinus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	sub'); AssSuffix( e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString(' '); AssLn;
   | 76 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 76/872 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	add'); AssSuffix( e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode); AssHString(' '); AssLn;
   | 75 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 75/872 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString(' 	add'); AssSuffix( e^.son[1]^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.son[1]^.gcg^.RegOrCMemOrIm.mode); AssHString(' '); AssLn;
   | 59 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 59/811 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedAbs ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
 AssHString('	cmp'); AssSuffix( e^.attr^.FixedAbs.mode); AssHString('	$0,'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode); AssLn;
 AssHString('	jg	'); AssString( lab^); AssLn;
 AssHString('	neg'); AssSuffix( e^.attr^.FixedAbs.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 57 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 57/799 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedNegate ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	neg'); AssSuffix( e^.attr^.FixedNegate.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedNegate.mode); AssLn;
	
   | 35 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 35/592 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FrameBase ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 14 : 
  EmitNtRegOrCMemOrIm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 14/417 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' RegOrCMemOrIm ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	mov'); AssSuffix( e^.gcg^.RegOrCMemOrIm.mode); AssHString('	'); AssAdrMode( AT0.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[ai].reg,e^.gcg^.RegOrCMemOrIm.mode); AssLn;
	
   | 13 : 
  EmitNtmem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 13/410 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' mem ->   reg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	leal	'); AssMemAdr( AT0.mem.am); AssHString(','); AssRegister(RegAlloc.allocation[ai].reg); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtreg;

PROCEDURE EmitNtfreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfreg] OF 
   | 254 : 
  EmitNtreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 254/2530 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	pushl	'); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	fildl	(%esp)'); AssLn;
 AssHString('	addl	$4,%esp'); AssLn;
	
   | 253 : 
  EmitNtCMem(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 253/2518 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	fildl	'); AssMemAdr( AT0.CMem.am); AssLn;
	
   | 252 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 252/2504 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	flds	RealOne_'); AssLn;
 AssHString('	fpatan'); AssLn;
	PopFStack;
	
   | 251 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 251/2495 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fcos'); AssLn;
   | 250 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 250/2486 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsin'); AssLn;
   | 248 : 
  EmitNtloadln2(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 248/2454 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF CurFStackSize < 2 THEN
	(* Es wurde RealLn2_ zwar geladen, aber dann wegen Funktionsaufrufen *)
	(* als Tempo in den Speicher ausgelagert. Deshalb wird RealLn2_      *)
	(* hier erneut geladen, die ersten beiden Stackregister vertauscht,  *)
	(* und die Markierung als Tempo (die Speicherstelle) geloescht.      *)
	(* Im Normalfall wird durch das Nichtterminalloadln2 die Konstante   *)
	(* RealLn2_ vor (!) der Auswertung des Funktionsarguments in RegAlloc.allocation[ai].reg*)
	(* auf den Floating-Point-Stack geladen.			     *)
 AssHString('	fldl	RealLn2_'); AssLn;
 AssHString('	fxch	%st(1)'); AssLn;
	FStackTempo[FStackStart+1] := NoTempo;
	INC (CurFStackSize);
	END;
 AssHString('	fyl2x'); AssLn;
	PopFStack;
	
   | 247 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 247/2413 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	(* e^x = 2^(x * log2e) *) 
 AssHString('	fmull	RealLog2e_'); AssLn;
	(* Normierung noetig: Fuer f2xm1 muss -0.5 <= st <= +0.5 gelten *)
	(* Daher Aufteilung von x = hi + lo mit |lo| <= 0.5		*)
	(* Neues Register fuer hi, weil x noch gebraucht wird 		*)
	PushFStack;
 AssHString('	fld	%st'); AssLn;
	(* Rundung hier zur naechsten ganzen Zahl, deshalb Aenderung    *)
	(* des Steuerwortes						*)
 AssHString('	fnstcw	fpucw_'); AssLn;
 AssHString('	andw	$0xf3ff,fpucw_'); AssLn;
 AssHString('	fldcw	fpucw_	'); AssLn;
 AssHString('	frndint'); AssLn;
	(* Rundung wieder nach 0 zurueckstellen (wegen TRUNC Standard)	*)
 AssHString('	orw	$0x0c00,fpucw_'); AssLn;
 AssHString('	fldcw	fpucw_	'); AssLn;
	(* Neues Register fuer lo, weil hi noch gebraucht wird 		*)
	PushFStack;
 AssHString('	fld	%st'); AssLn;
	(* Differenz von x und hi -> lo					*)
 AssHString('	fsubr	%st(2),%st'); AssLn;
	(* Berechnung von 2^lo						*)
 AssHString('	f2xm1'); AssLn;
 AssHString('	fadds	RealOne_'); AssLn;
	(* Berechnung 2^hi * 2^lo					*)
 AssHString('	fscale'); AssLn;
	(* Benutzte Register wieder poppen (und Ergebnis weitergeben)	*)
 AssHString('	fstp	%st(1)'); AssLn;
	PopFStack;
 AssHString('	fstp	%st(1)'); AssLn;
	PopFStack;
	
   | 246 : 
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 246/2404 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsqrt'); AssLn;
   | 244 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 244/2366 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
 AssHString('	call	'); AssString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	PushFStack;
	
   | 243 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 243/2352 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	SpillFStack;
 AssHString('	call	'); AssRegister(RegAlloc.allocation[ai].op[2]); AssLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN 
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.FunctionCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	PushFStack;
	
   | 206 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
  EmitNtCMem(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 206/1843 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CheckL ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
 AssHString('	fcom'); AssSuffix( e^.attr^.CheckL.LwbMode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jb	'); AssString( lab2^); AssLn;
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
 AssHString('	fcom'); AssSuffix( e^.attr^.CheckL.UpbMode); AssHString('	'); AssMemAdr( AT2.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jbe	'); AssString( lab^); AssLn;
	ELSE
 AssHString('	jmp	'); AssString( lab^); AssLn;
	END;
 AssString( lab2^); AssHString(':'); AssLn;
 AssHString('   	call	BoundErr_		'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 200 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 200/1758 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Coerce ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 185 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 185/1623 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	PushFStack;
 AssHString('	pushl	'); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	fildl	(%esp)'); AssLn;
 AssHString('	addl	$4,%esp'); AssLn;
 AssHString('	cmpl	$0x7fffffff,'); AssRegister(RegAlloc.allocation[ai].op[1]); AssLn;
 AssHString('	jbe	'); AssString( lab^); AssLn;
 AssHString('	faddl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 184 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 184/1611 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel(lab);
	PushFStack;
 AssHString('	fildl	'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	cmpl	$0x7fffffff,'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	jbe	'); AssString( lab^); AssLn;
 AssHString('	faddl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	
   | 162 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 162/1445 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatAbs ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fabs '); AssLn;
   | 161 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 161/1440 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fdivr'); 
   | 160 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 160/1435 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fdiv'); 
   | 159 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 159/1430 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fdivr'); AssSuffix( e^.attr^.FloatDiv.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 158 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 158/1425 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fdiv'); AssSuffix( e^.attr^.FloatDiv.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 157 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 157/1420 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fmul'); 
   | 156 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 156/1420 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fmul'); 
   | 155 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 155/1415 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fmul'); AssSuffix( e^.attr^.FloatMult.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 154 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 154/1415 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fmul'); AssSuffix( e^.attr^.FloatMult.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 153 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 153/1410 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fsub'); 
   | 152 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 152/1405 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fsubr'); 
   | 151 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 151/1400 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsubr'); AssSuffix( e^.attr^.FloatMinus.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 150 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 150/1395 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fsub'); AssSuffix( e^.attr^.FloatMinus.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 149 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtfstack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 149/1390 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fadd'); 
   | 148 : 
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 148/1390 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 FloatOperation ('fadd'); 
   | 147 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 147/1385 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fadd'); AssSuffix( e^.attr^.FloatPlus.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssHString(' '); AssLn;
   | 146 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 146/1385 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fadd'); AssSuffix( e^.attr^.FloatPlus.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssHString(' '); AssLn;
   | 145 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 145/1380 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatNegate ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 AssHString('	fchs '); AssLn;
   | 17 : 
  EmitNtCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 17/462 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CMem ->   freg');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	fld'); AssSuffix( e^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrfreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfreg;

PROCEDURE EmitNtfstack (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfstack] OF 
   | 18 : 
  EmitNtfreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 18/469 Cost=');
          WriteInt    (e^.gcg^.cost [ntfstack],1);
          WriteString (' freg ->   fstack');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF Kommentar THEN
 AssHString('					/* Kettenregel '); AssRegister(RegAlloc.allocation[ai].op[1]); AssHString(' -> '); AssRegister(RegAlloc.allocation[ai].reg); AssHString(' */'); AssLn;
	END;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrfstack (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
      WITH RegAlloc.allocation[ai] DO 
         IF spilllocation#0 THEN 
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN 
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE 
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN 
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;   
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfstack;

PROCEDURE EmitNtConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntConstant] OF 
   | 258 : 
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 258/2573 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 190 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 190/1684 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Coerce ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 187 : 
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 187/1641 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Trunc ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 139 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 139/1318 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMod ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 135 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 135/1274 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 128 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 128/1208 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 94 : 
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 94/1005 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 93 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 93/1005 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 92 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 92/1001 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 91 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 91/993 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 83 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 83/933 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 60 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 60/824 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedPlus ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 58 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 58/807 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedAbs ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 56 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 56/795 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedNegate ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 28 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 28/516 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' NilConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 27 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 27/512 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' SetConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 26 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 26/507 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' BoolConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 25 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 25/503 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' CharConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 22 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 22/491 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 21 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 21/487 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 20 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 20/483 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 19 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 19/479 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrConstant (resAttributes);
       WriteLn;
   END;
END EmitNtConstant;

PROCEDURE EmitNtFloatConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntFloatConstant] OF 
   | 256 : 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 256/2552 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 255 : 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 255/2544 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 199 : 
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 199/1753 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 198 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 198/1748 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 186 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 186/1637 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Float ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 24 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 24/499 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' LongRealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 23 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 23/495 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' RealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrFloatConstant (resAttributes);
       WriteLn;
   END;
END EmitNtFloatConstant;

PROCEDURE EmitNtSimpleVariable (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntSimpleVariable] OF 
   | 110 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 110/1060 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 109 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1]^.son[1],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 109/1060 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 108 : 
  EmitNtSimpleVariable(e^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 108/1060 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 107 : 
  EmitNtConstant(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[1]^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 107/1060 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 87 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 87/955 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedMinus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 74 : 
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 74/867 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 73 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 73/867 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 38 : 
  EmitNtConstant(e^.son[2],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 38/606 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 SaveDisplay [e^.son[1]^.attr^.FrameBase.level] := TRUE; 
   | 37 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 37/606 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 SaveDisplay [e^.son[2]^.attr^.FrameBase.level] := TRUE; 
   | 33 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 33/551 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' StaticVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   | 31 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 31/531 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' LocalVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrSimpleVariable (resAttributes);
       WriteLn;
   END;
END EmitNtSimpleVariable;

PROCEDURE EmitNtSymPlusOffset (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntSymPlusOffset] OF 
   | 191 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 191/1689 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Coerce ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 84 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 84/937 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedMinus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 62 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 62/828 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 61 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 61/828 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol; 
   | 34 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 34/563 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StaticVariable ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StaticVariable.module^.Statics; 
   | 30 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 30/524 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StringAddr ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StringAddr.index; 
   | 29 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 29/520 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' ProcedureConstant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.ProcedureConstant.index^.Entry; 
   | 1 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 1/332 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Constant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.SymPlusOffset.symbol	:= NullSymb; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtSymPlusOffset;

PROCEDURE EmitNtRegPlusSymPlusOffset (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegPlusSymPlusOffset] OF 
   | 192 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 192/1695 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' Coerce ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 85 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 85/941 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 66 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 66/838 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 65 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 65/838 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.RegPlusSymPlusOffset.symbol; 
   | 64 : 
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 64/832 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[2];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   | 63 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 63/832 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol; 
   | 32 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 32/543 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' LocalVariable ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= Regebp;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb; 
   | 3 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 3/341 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	  resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1]; 
   | 2 : 
  EmitNtSymPlusOffset(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 2/336 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' SymPlusOffset ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegNil;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegPlusSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtRegPlusSymPlusOffset;

PROCEDURE EmitNtOffsetPlusIndexMultFaktor (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntOffsetPlusIndexMultFaktor] OF 
   | 193 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 193/1702 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' Coerce ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 130 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 130/1218 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedDiv ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index; 
   | 104 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 104/1040 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index; 
   | 103 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 103/1040 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT1.OffsetPlusIndexMultFaktor.index; 
   | 68 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 68/843 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index; 
   | 67 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 67/843 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT1.OffsetPlusIndexMultFaktor.index; 
   | 4 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 4/347 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrOffsetPlusIndexMultFaktor (resAttributes);
       WriteLn;
   END;
END EmitNtOffsetPlusIndexMultFaktor;

PROCEDURE EmitNtmem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntmem] OF 
   | 194 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 194/1709 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' Coerce ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 120 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 120/1129 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val DIV 9)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 119 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 119/1129 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val DIV 9)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 118 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 118/1114 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val DIV 5)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 117 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 117/1114 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val DIV 5)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 116 : 
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 116/1099 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.gcg^.Constant.val DIV 3)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 115 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 115/1099 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	shl'); AssSuffix( e^.attr^.FixedMult.mode); AssHString('	$'); AssInt ( Log2(e^.son[1]^.gcg^.Constant.val DIV 3)); AssHString(', '); AssRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode); AssLn;
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;
	
   | 106 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 106/1049 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb; 
   | 105 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 105/1049 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb; 
   | 86 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 86/946 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMinus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset - e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 72 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 72/858 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset + e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol; 
   | 71 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 71/858 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= AT1.mem.am.offset + e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT1.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT1.mem.am.base;
	  resAttributes.mem.am.index	:= AT1.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT1.mem.am.symbol; 
   | 70 : 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 ); 
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 70/849 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT1.RegPlusSymPlusOffset.symbol; 
   | 69 : 
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 ); 
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 69/849 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   | 6 : 
  EmitNtOffsetPlusIndexMultFaktor(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 6/362 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' OffsetPlusIndexMultFaktor ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  resAttributes.mem.am.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= RegNil;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= NullSymb; 
   | 5 : 
  EmitNtRegPlusSymPlusOffset(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 5/353 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' RegPlusSymPlusOffset ->   mem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= 1;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= RegNil;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrmem (resAttributes);
       WriteLn;
   END;
END EmitNtmem;

PROCEDURE EmitNtCMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntCMem] OF 
   | 202 : 
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 202/1778 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
 AssHString('	mov'); AssSuffix( e^.attr^.Coerce.premode); AssHString('	'); AssAdrMode( AT0.RegOrIm.am); AssHString(','); AssMemAdr( resAttributes.CMem.am); AssLn;
	
   | 201 : 
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 201/1762 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
 AssHString('	fstp'); AssSuffix( e^.attr^.Coerce.premode); AssHString('	'); AssMemAdr( resAttributes.CMem.am); AssLn;
	PopFStack;
	
   | 195 : 
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 195/1720 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am.offset	:= AT0.CMem.am.offset;
	  resAttributes.CMem.am.faktor	:= AT0.CMem.am.faktor;
	  resAttributes.CMem.am.base	:= AT0.CMem.am.base;
	  resAttributes.CMem.am.index	:= AT0.CMem.am.index;
	  resAttributes.CMem.am.symbol	:= AT0.CMem.am.symbol; 
   | 39 : 
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 39/661 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Content ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am	 := AT0.mem.am; 
   | 36 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 36/596 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FrameBase ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.CMem.am.offset	:= 4*e^.attr^.FrameBase.level;
	  resAttributes.CMem.am.faktor	:= 0;
	  resAttributes.CMem.am.base	:= RegNil;
	  resAttributes.CMem.am.index	:= RegNil;
	  resAttributes.CMem.am.symbol	:= DisplaySym;
	  SaveDisplay [e^.attr^.FrameBase.level] := TRUE; 
   | 16 : 
  EmitNtFloatConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 16/443 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr2.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
 AssHString('	.data'); AssLn;
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.long	'); AssInt ( tr2.c2); AssHString(','); AssInt ( tr2.c1); AssHString('		# '); AssString( str); AssLn;
 AssHString('	.text'); AssLn;
	
   | 15 : 
  EmitNtFloatConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 15/424 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr1.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
 AssHString('	.data'); AssLn;
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	.long	'); AssInt ( tr1.c); AssHString('		# '); AssString( str); AssLn;
 AssHString('	.text'); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtCMem;

PROCEDURE EmitNtRegOrIm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrIm] OF 
   | 11 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 11/398 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' Constant ->   RegOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrIm.am.kind  := Mconst;
	  resAttributes.RegOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrIm.am.constant := e^.gcg^.Constant.val; 
   | 7 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 7/371 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' reg ->   RegOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrIm.am.kind := Mreg;
	  resAttributes.RegOrIm.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrIm.am.reg  := RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrIm;

PROCEDURE EmitNtRegOrCMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrCMem] OF 
   | 9 : 
  EmitNtCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 9/383 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' CMem ->   RegOrCMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMem.am.kind := Mmem;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.CMem.mode;
	  resAttributes.RegOrCMem.am.mem  := AT0.CMem.am; 
   | 8 : 
  EmitNtreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 8/377 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' reg ->   RegOrCMem');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMem.am.kind := Mreg;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrCMem.am.reg  := RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMem;

PROCEDURE EmitNtRegOrCMemOrIm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRegOrCMemOrIm] OF 
   | 12 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 12/404 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' Constant ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMemOrIm.am.kind  := Mconst;
	  resAttributes.RegOrCMemOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrCMemOrIm.am.constant := e^.gcg^.Constant.val; 
   | 10 : 
  EmitNtRegOrCMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 10/389 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' RegOrCMem ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;
 resAttributes.RegOrCMemOrIm.am.kind := AT0.RegOrCMem.am.kind;
	  resAttributes.RegOrCMemOrIm.am.mode := e^.gcg^.RegOrCMem.mode;
	  IF AT0.RegOrCMem.am.kind = Mreg
	    THEN resAttributes.RegOrCMemOrIm.am.reg := AT0.RegOrCMem.am.reg;
	    ELSE resAttributes.RegOrCMemOrIm.am.mem := AT0.RegOrCMem.am.mem;
	  END; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRegOrCMemOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMemOrIm;

PROCEDURE EmitNtarglist (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntarglist] OF 
   | 238 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 238/2290 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$'); AssInt ( e^.attr^.PassLong.space); AssHString(',%esp'); AssLn;
 AssHString('	movl	%esp,%edi'); AssLn;
 AssHString('	movl	$'); AssInt ( (e^.attr^.PassLong.size + 3) DIV 4); AssHString(',%ecx'); AssLn;
 AssHString('	cld'); AssLn;
 AssHString('	repz'); AssLn;
 AssHString('	movsl'); AssLn;
	
   | 237 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 237/2280 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	IF e^.attr^.PassLong.space > 4 THEN
 AssHString('	subl	$'); AssInt ( e^.attr^.PassLong.space - 4); AssHString(',%esp'); AssLn;
	END;	
 AssHString('	pushl	'); AssMemAdr( AT1.mem.am); AssLn;
	
   | 236 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 236/2271 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	subl	$'); AssInt ( SizeTable[e^.attr^.Pass.mode]); AssHString(',%esp'); AssLn;
 AssHString('	fstp'); AssSuffix( e^.attr^.Pass.mode); AssHString('	(%esp)'); AssLn;
	PopFStack;
	
   | 235 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 235/2261 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	INC (AT1.CMem.am.offset, 4);
 AssHString('	pushl	'); AssMemAdr( AT1.CMem.am); AssLn;
	DEC (AT1.CMem.am.offset, 4);
 AssHString('	pushl	'); AssMemAdr( AT1.CMem.am); AssLn;
	
   | 234 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 234/2255 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	pushl	$'); AssInt ( e^.son[2]^.gcg^.Constant.val); AssLn;
	
   | 233 : 
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 233/2237 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

 AssHString('	pushl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssLn;
	
   | 232 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 232/2235 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Nil ->   arglist');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrarglist (resAttributes);
       WriteLn;
   END;
END EmitNtarglist;

PROCEDURE EmitNtloadln2 (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR

BEGIN
   CASE e^.gcg^.rule [ntloadln2] OF 
   | 249 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 249/2479 Cost=');
          WriteInt    (e^.gcg^.cost [ntloadln2],1);
          WriteString (' Nil ->   loadln2');
          WriteLn;
          WriteNest (nest); 
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (ai); 
       END;

	PushFStack;
 AssHString('	fldl	RealLn2_'); AssLn;
	
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrloadln2 (resAttributes);
       WriteLn;
   END;
END EmitNtloadln2;

PROCEDURE EmitStatement (e : IR.Expression);
CONST nest = 0;  
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

VAR   i        : INTEGER;
BEGIN
   ai := RegAlloc.ai;
   IF e^.gcg^.stmtcost >= IR.infcost THEN 
     (*************** Compiler Error ******************)
     (******** No code selected, no cover found *******)
     WriteString ('no code selected'); WriteLn;
     IR.PrintInstrCosts (e);
     WriteLn;
     IR.Error ('internal error');
     i := 0; i := 1 DIV i; HALT;
   ELSE
     CASE e^.gcg^.stmtrule OF 
     | 40 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 40/668 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	mov'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 41 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 41/673 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	fstp'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( AT0.mem.am); AssLn;
	PopFStack;
	
     | 42 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 42/681 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr1.r := e^.son[2]^.gcg^.FloatConstant.val;
 AssHString('	movl	$'); AssInt ( tr1.c); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 43 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 43/689 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr2.r := e^.son[2]^.gcg^.FloatConstant.val;
 AssHString('	movl	$'); AssInt ( tr2.c2); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT0.mem.am.offset, 4);
 AssHString('	movl	$'); AssInt ( tr2.c1); AssHString(','); AssMemAdr( AT0.mem.am); AssHString('	'); AssLn;
	
     | 44 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 44/699 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	'); AssMemAdr( AT1.CMem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 45 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 45/708 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	$'); AssInt ( e^.attr^.AssignLong.size DIV 4); AssHString(',%ecx'); AssLn;
 AssHString('	cld'); AssLn;
 AssHString('	repz'); AssLn;
 AssHString('	movsl'); AssLn;
	IF e^.attr^.AssignLong.size MOD 4 >= 2 THEN
 AssHString('	movsw'); AssLn;
	END;
	IF e^.attr^.AssignLong.size MOD 2 >= 1 THEN
 AssHString('	movsb'); AssLn;
	END;
	
     | 46 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 46/725 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	'); AssMemAdr( AT1.mem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 47 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtmem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 47/734 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.AssignLong.size DIV 2 > 0 THEN
 AssHString('	movw	'); AssMemAdr( AT1.mem.am); AssHString(','); AssWordRegister ( RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movw	'); AssWordRegister ( RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT1.mem.am.offset, 2);
	INC (AT0.mem.am.offset, 2);
	END;
	IF e^.attr^.AssignLong.size MOD 2 > 0 THEN
 AssHString('	movb	'); AssMemAdr( AT1.mem.am); AssHString(','); AssByteRegister ( RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movb	'); AssByteRegister ( RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	END;
	
     | 48 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 48/751 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc1');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	inc'); AssSuffix( e^.attr^.Inc1.mode); AssHString('	'); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 49 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 49/755 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec1');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	dec'); AssSuffix( e^.attr^.Dec1.mode); AssHString('	'); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 50 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 50/759 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc2');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	add'); AssSuffix( e^.attr^.Inc2.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 51 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 51/763 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec2');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	sub'); AssSuffix( e^.attr^.Dec2.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 52 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 52/771 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' InclL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	btsl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 53 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 53/779 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ExclL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 AssHString('	btrl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.mem.am); AssHString(' '); AssLn;
     | 54 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 54/786 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipAddress');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 55 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 55/789 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipData');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 77 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 77/878 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	'); AssMemAdr( AT1.CMem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	INC (AT0.mem.am.offset, 4);
	INC (AT1.CMem.am.offset, 4);
 AssHString('	movl	'); AssMemAdr( AT1.CMem.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssMemAdr( AT0.mem.am); AssLn;
	
     | 78 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 78/891 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	inc'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 79 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 79/891 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	inc'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 80 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 80/905 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	add'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 81 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 81/905 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	add'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 82 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 82/918 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shl'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$1, '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 89 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 89/966 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	dec'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 90 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 90/980 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	sub'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 97 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 97/1015 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 98 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 98/1015 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 113 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 113/1084 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shl'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[1]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 114 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 114/1084 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shl'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 126 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 126/1170 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	mov'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssLn;
 AssHString('	imul'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssLn;
 AssHString('	mov'); AssSuffix( e^.attr^.Assign.mode); AssHString('	'); AssRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 132 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 132/1236 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	shr'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 134 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 134/1259 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	sar'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val)); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 141 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 141/1330 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	and'); AssSuffix( e^.attr^.Assign.mode); AssHString('	$'); AssInt ( e^.son[2]^.son[2]^.gcg^.Constant.val-1); AssHString(', '); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 165 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 165/1459 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	orl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 166 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 166/1459 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	orl	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 169 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtreg(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 169/1489 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	notl	'); AssRegister(RegAlloc.allocation[1].op[3]); AssLn;
 AssHString(' 	andl	'); AssRegister(RegAlloc.allocation[1].op[3]); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 170 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 170/1503 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString(' 	andl	$'); AssInt ( INTEGER(BITSET(-1) - BITSET(e^.son[2]^.son[2]^.gcg^.Constant.val))); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 173 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 173/1522 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	andl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 174 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 174/1522 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	andl	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 177 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 177/1541 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	xorl	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 178 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 ); 
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 178/1541 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 AssHString('	xorl	'); AssAdrMode( AT2.RegOrIm.am); AssHString(','); AssMemAdr( e^.son[1]^.gcg^.SimpleVariable.base); AssLn;
	
     | 189 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 189/1666 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel(lab);
 AssHString('	fcoml	TwoExp31_'); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	jb	'); AssString( lab^); AssLn;
 AssHString('	fsubl	TwoExp32_'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
 AssHString('	fistpl	'); AssMemAdr( AT0.mem.am ); AssLn;
	PopFStack;
	
     | 217 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 217/2004 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' PlaceLabel');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssString( e^.attr^.PlaceLabel.lab^); AssHString(':'); AssLn;
	
     | 218 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 218/2010 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Goto');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	jmp	'); AssString( e^.attr^.Goto.tar^); AssLn;
	
     | 219 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 219/2016 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SwitchL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel (lab);
 AssHString('	.data'); AssLn;
 AssHString('	.align 4'); AssLn;
 AssString( lab^); AssHString(':'); AssLn;
	WHILE e^.attr^.SwitchL.CaseLabels # NIL DO
 AssHString('	.long	'); AssString( e^.attr^.SwitchL.CaseLabels^.label^); AssLn;
	  e^.attr^.SwitchL.CaseLabels := e^.attr^.SwitchL.CaseLabels^.next;
	END;
 AssHString('	.text'); AssLn;
 AssHString('	sub'); AssSuffix( e^.attr^.SwitchL.mode); AssHString('	$'); AssInt ( e^.attr^.SwitchL.lwb); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode); AssLn;
 AssHString('	j'); AssString( RelationTable[RelLess][SignedTable[e^.attr^.SwitchL.mode]]); AssHString('	'); AssString( e^.attr^.SwitchL.DefaultLabel^); AssLn;
 AssHString('	cmp'); AssSuffix( e^.attr^.SwitchL.mode); AssHString('	$'); AssInt ( e^.attr^.SwitchL.upb - e^.attr^.SwitchL.lwb); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode); AssLn;
 AssHString('	j'); AssString( RelationTable[RelGreater][SignedTable[e^.attr^.SwitchL.mode]]); AssHString('	'); AssString( e^.attr^.SwitchL.DefaultLabel^); AssLn;
 AssHString('	jmp	'); AssString( lab^); AssHString('(,'); AssRegister(RegAlloc.allocation[1].op[1]); AssHString(',4)'); AssLn;
	
     | 220 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 220/2036 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
 AssHString('	cmpb	$'); AssInt ( k); AssHString(','); AssByteRegister ( RegAlloc.allocation[1].op[1]); AssLn;
 AssHString('	je	'); AssString( e^.attr^.TestAndBranch.tar^); AssLn;
	
     | 221 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 221/2044 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
 AssHString('	cmpb	$'); AssInt ( k); AssHString(','); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	je	'); AssString( e^.attr^.TestAndBranch.tar^); AssLn;
	
     | 222 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 222/2052 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompareAndBranch.mode); AssHString('	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.FixedCompareAndBranch.mode); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FixedCompareAndBranch.tar^); AssLn;
	
     | 223 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 223/2059 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompareAndBranch.mode); AssHString('	'); AssAdrMode( AT1.RegOrIm.am); AssHString(','); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FixedCompareAndBranch.tar^); AssLn;
	
     | 224 :
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 224/2066 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	cmp'); AssSuffix( e^.attr^.FixedCompareAndBranch.mode); AssHString('	$'); AssInt ( e^.son[1]^.gcg^.Constant.val); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
 AssHString('	j'); AssString( RelationTable[Reverse[e^.attr^.FixedCompareAndBranch.rel]][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FixedCompareAndBranch.tar^); AssLn;
	
     | 225 :
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
  EmitNtCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 225/2073 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	fcomp'); AssSuffix( e^.son[2]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT1.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.FloatCompareAndBranch.rel][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FloatCompareAndBranch.tar^); AssLn;
	PopFStack;
	
     | 226 :
  EmitNtCMem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 226/2084 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	fcomp'); AssSuffix( e^.son[1]^.gcg^.CMem.mode); AssHString('	'); AssMemAdr( AT0.CMem.am); AssLn;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	j'); AssString( RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FloatCompareAndBranch.tar^); AssLn;
	PopFStack;
	
     | 227 :
  EmitNtfstack(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 227/2095 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
 AssHString('	fcompl	'); AssInt ( FStackTempo[FStackStart]); AssHString('(%ebp)'); AssLn;
	  DEC (CurFStackSize);
	ELSE
 AssHString('	fcompp'); AssLn;
	  DEC (CurFStackSize, 2);
	END;
 AssHString('	fstsw	%ax'); AssLn;
 AssHString('	sahf'); AssLn;
 AssHString('	j'); AssString( RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]); AssHString('	'); AssString( e^.attr^.FloatCompareAndBranch.tar^); AssLn;
	
     | 228 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 228/2112 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	cmpl	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].op[1]); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]); AssHString('	'); AssString( e^.attr^.SetCompareAndBranch.tar^); AssLn;
	
     | 229 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 229/2120 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	movl	'); AssRegister(RegAlloc.allocation[1].op[1]); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	CASE e^.attr^.SetCompareAndBranch.rel OF
	| RelLess:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelLessOrEqual:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	| RelGreater:
 AssHString('	and	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelGreaterOrEqual:
 AssHString('	or	'); AssAdrMode( AT1.RegOrCMemOrIm.am); AssHString(','); AssRegister(RegAlloc.allocation[1].scr[1]); AssLn;
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	END;
 AssHString('	cmpl	'); AssRegister(RegAlloc.allocation[1].scr[1]); AssHString(','); AssRegister(RegAlloc.allocation[1].op[1]); AssLn;
 AssHString('	j'); AssString( RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]); AssHString('	'); AssString( e^.attr^.SetCompareAndBranch.tar^); AssLn;
	
     | 230 :
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 ); 
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 230/2151 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestMembershipAndBranchL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	btl	'); AssAdrMode( AT0.RegOrIm.am); AssHString(','); AssAdrMode( AT1.RegOrCMem.am); AssLn;
	IF e^.attr^.TestMembershipAndBranchL.cond THEN
 AssHString('	jc	'); AssString( e^.attr^.TestMembershipAndBranchL.tar^); AssLn;
	ELSE
 AssHString('	jnc	'); AssString( e^.attr^.TestMembershipAndBranchL.tar^); AssLn;
	END;
	
     | 231 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 231/2162 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestOddAndBranch');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	and'); AssSuffix( e^.attr^.TestOddAndBranch.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode); AssLn;
	IF NOT e^.attr^.TestOddAndBranch.cond THEN
 AssHString('	xor'); AssSuffix( e^.attr^.TestOddAndBranch.mode); AssHString('	$1,'); AssRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode); AssLn;
	END;
 AssHString('	jnz	'); AssString( e^.attr^.TestOddAndBranch.tar^); AssLn;
	
     | 239 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
  EmitNtreg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 239/2302 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	call	'); AssRegister(RegAlloc.allocation[1].op[2]); AssLn;
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN 
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.ProcedureCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
     | 240 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 240/2313 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	call	'); AssString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^); AssLn;
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN 
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.ProcedureCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
     | 245 :
  EmitNtarglist(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 245/2380 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' RTSCall');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CASE e^.attr^.RTSCall.sysproc OF 
	      | SysProcHALT : 
 AssHString('	call	exit_'); AssLn;
	      | SysProcTransfer : 
 AssHString('	call	Transfer_'); AssLn;
	      | SysProcNewprocess : 
 AssHString('	call	NewProcess_'); AssLn;
	      | SysProcCaseError : 
 AssHString('	call	CaseErr_'); AssLn;
	      | SysProcReturnError : 
 AssHString('	call	ReturnErr_'); AssLn;
	END;
	IF e^.attr^.RTSCall.paramsize # 0 THEN 
	(* e^.attr^.RTSCall.paramsize := (e^.attr^.RTSCall.paramsize+3) DIV 4 * 4; *)
 AssHString('	addl	$'); AssInt ( e^.attr^.RTSCall.paramsize); AssHString(', %esp'); AssLn;
	END;
	
     | 259 :
  EmitNtmem(e^.son[1],nest+1,AT0 ); 
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 259/2584 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 AssHString('	fistpl	'); AssMemAdr( AT0.mem.am); AssLn;
	PopFStack;
	
     | 260 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 260/2601 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' BeginProcedure');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   UndefOperand := IR.emptyExpression;
   CurLevel := e^.attr^.BeginProcedure.level;
   CurFrameSize := 4 * ((ABS(e^.attr^.BeginProcedure.FrameSize)+3) DIV 4);
   IF CurLevel>MaxDisplay THEN 
      ERROR ('too many nested procedures', UndefSourcePos);
      CurLevel := 0;
   END;
   CurFStackSize := 0;
   FStackStart := MaxFloatTempo;
   TransferTempo := NoTempo;

(* -------------------------------------------------------------------- *)
(* Die Daten werden bei Prozeduren wie folgt auf dem Stack abgelegt :	*)
(*		------------------------- <--- Stackanfang (MaxAdr)	*)
(*		|			|				*)
(*		|	.......		|				*)
(*		|			|				*)
(*	    .	|-----------------------|				*)
(*	    .	|	Parameter	|				*)
(*	    .	| (bei OpenArrays nur	|				*)
(*	    8	|  Adresse und Laenge)	|				*)
(*		|-----------------------|				*)
(*	    4	|    Return-Adresse	|				*)
(*		|-----------------------|				*)
(*	    0	|   alter BasePointer   | <--- BasePointer (ebp)	*)
(*		|-----------------------|   )				*)
(*	   -4	| alter DV [CurLevel]	|   )				*)
(*		|-----------------------|   )				*)
(*	   -8	| lokale Variablen	|   )  Activation Record (AR)	*)
(*	    .	|-----------------------|   )				*)
(*	    .	| evtl.temporaere Werte	|   )				*)
(*	    .	|-----------------------|   )				*)
(*		| evtl. OpenArrays	|   )				*)
(*		|-----------------------|   )				*)
(*		| Platz fuer Sicherungen|   )				*)
(*		|-----------------------| <--- StackPointer (esp)	*)
(*									*)
(* Der DisplayVector DV enthaelt jeweils den aktuellen BP der zuletzt	*)
(* auf dem jeweiligen Level ausgefuehrten Prozedur.			*)
(* Der DisplayVector steht ab der Stelle DISPLAY_ im Speicher,		*)
(* durch das sich die Adresse vom DisplayVector des Levels i, also	*)
(* DV [i], als DISPLAY_ + i*4 errechnen laesst.				*)
(* Aus Optimierungsgruenden wird jedoch der DV nicht in jedem Level	*)
(* gespeichert und geladen, sondern nur, falls eine Prozedur des Levels *)
(* i auf eine nicht-globale Variable des Levels j (j < i) zugreift.	*)
(* -------------------------------------------------------------------- *)

(* Zunaechst den Label bestimmen, an dem der die Groesse des Activation *)
(* Records bei EndProcedure gespeichert wird. Diese kann durch die un-	*)
(* gewisse Zahl der benoetigten temporaeren Werte erst am Schluss	*)
(* bestimmt werden.							*)
	GetLabel (ProcLabel);
(* Startlabel der Prozedur eintragen *)
 AssString( e^.attr^.BeginProcedure.index^.Entry^); AssHString(':'); AssLn;
(* Alten BP sichern *)
 AssHString('	pushl	%ebp'); AssLn;
(* Neuer BP fuer neuen Activation Record *)
 AssHString('	movl	%esp,%ebp'); AssLn;
(* Platz fuer alten DisplayVector[CurLevel], lokale Variablen und	*)
(* temporaere Werte schaffen.						*)
 AssHString('	subl	$'); AssString( ProcLabel^); AssHString(', %esp'); AssLn;
     IF SaveDisplay [CurLevel] THEN
(* Aktualisieren des DisplayVectors,  wird fuer andere Prozedur benoetigt. *)
(* Laden des momentanen DisplayVectors [CurLevel] *)
 AssHString('	movl	DISPLAY_+'); AssInt ( 4 * CurLevel); AssHString(',%ecx'); AssLn;
(* Sichern des alten Wertes des DisplayVectors [CurLevel] *)
 AssHString('	movl	%ecx,-4(%ebp)'); AssLn;
(* Schreiben des aktuellen DisplayVectors [CurLevel] *)
 AssHString('	movl	%ebp,DISPLAY_+'); AssInt ( 4 * CurLevel); AssLn;
     END;
     IF Kommentar THEN
 AssHString('	/* --------------------------------------------------------- */'); AssLn;
 AssHString('	/* Level : '); AssInt ( CurLevel); AssHString(' */'); AssLn;
 AssHString('	/* --------------------------------------------------------- */'); AssLn;
     END;
	
     | 261 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 261/2681 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' CopyOpenArray');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF Kommentar THEN
 AssHString('	/* Copy Open Array Begin */'); AssLn;
	END;
   IF (e^.attr^.CopyOpenArray.elemsize # ByteSize) & ODD (e^.attr^.CopyOpenArray.elemsize) THEN INC (e^.attr^.CopyOpenArray.elemsize); END;
   (* Lade letzten Index (= Laenge - 1) des Stringparameter *)
 AssHString('	movl	'); AssInt ( e^.attr^.CopyOpenArray.HighOffset); AssHString('(%ebp),%ecx'); AssLn;
   (* Bestimme Laenge des Stringparameters *)
 AssHString('	incl	%ecx'); AssLn;
   (* Ermittle Platzbedarf fuer den Stringparameter.			*)
   (* Das Resultat steht in Register ecx.				*)
      IF e^.attr^.CopyOpenArray.elemsize # ByteSize THEN
      (* Multiplikation Elementanzahl * Elementgroesse = Platzbedarf	*)
      (* durchfuehren.							*)
	 IF IsPowerOfTwo (e^.attr^.CopyOpenArray.elemsize) THEN
 AssHString('	shll	$'); AssInt ( Log2 (e^.attr^.CopyOpenArray.elemsize)); AssHString(', %ecx'); AssLn;
	 ELSE
 AssHString('	imull	$'); AssInt ( e^.attr^.CopyOpenArray.elemsize); AssHString(',%ecx'); AssLn;
	 END
      END;
   (* Platzbedarf auf durch 4 teilbare Adresse aufrunden *)
 AssHString('	addl	$3,%ecx'); AssLn;
 AssHString('	andl	$0xfffffffc, %ecx'); AssLn;
   (* Schaffe auf dem Stack entsprechenden Platz *)
 AssHString('	subl 	%ecx,%esp'); AssLn;
   (* Startadresse des zu kopierenden ARRAYs				*)
 AssHString('	movl	%esp,%edi'); AssLn;
   (* Lade Startadresse des OpenArrays *)
 AssHString('	movl	'); AssInt ( e^.attr^.CopyOpenArray.DataOffset); AssHString('(%ebp),%esi'); AssLn;
    (* Ersetze im Parameterteil der Prozedur die Startadresse des Parameter-
       strings durch die Adresse dessen Kopie auf das OpenArray         *)
 AssHString('	movl	%edi,'); AssInt ( e^.attr^.CopyOpenArray.DataOffset); AssHString('(%ebp)'); AssLn;
     (* Kopiere Stringparameter in den OpenArray-Platz der Prozedur     *)
     (* Register ecx enthaelt die Groesse				*)
     (* Register esi die Quelladresse,					*)
     (* Register edi die Zieladresse.					*)
 AssHString('	shrl	$2,%ecx'); AssLn;
 AssHString('	cld'); AssLn;
 AssHString('	repz'); AssLn;
 AssHString('	movsl'); AssLn;
	IF Kommentar THEN
 AssHString('	/* Copy Open Array End */'); AssLn;
	END;
	
     | 262 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 262/2729 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Return');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 
	IF (CurFStackSize <> 0) AND OK THEN
 AssHString('	ERROR: CurFStackSize <> 0'); AssLn;
	AssClose;
	CompilerError ("Something's going wrong in fp expression");
	END;	
	IF SaveDisplay [CurLevel] THEN
	(* Alten Wert von DisplayVector [CurLevel] laden, wurde veraendert *)
 AssHString('	movl	-4(%ebp),%ecx'); AssLn;
	(* Diesen Wert wieder in DisplayVector [CurLevel] eintragen *)
 AssHString('	movl	%ecx,DISPLAY_+'); AssInt ( 4 * CurLevel); AssLn;
	END;
	(* Ruecksprung aus der Prozedur *)
 AssHString('	leave'); AssLn;
 AssHString('	ret'); AssLn;
	
     | 263 :
  EmitNtreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 263/2753 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 264 :
  EmitNtfreg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 264/2756 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	PopFStack;
	
     | 265 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 265/2762 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndProcedure');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	SaveDisplay [CurLevel] := FALSE; 
	CurFrameSize :=   4 * ((ABS(CurFrameSize)+3) DIV 4);
 AssHString('	'); AssString( ProcLabel^); AssHString(' = '); AssInt ( CurFrameSize); AssLn;
	
     | 266 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 266/2796 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndModule');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   AssClose;
   IF OK (* no Errors *) THEN 
      StringAssign  (cmd, 'cd '); 
      StringAppend2 (cmd, LibraryDirectory, '; ');
      StringAppend1 (cmd, AssemblerScript);
      IF SuBase.Enabled (SuBase.DebugOption) THEN 
	 StringAppend1 (cmd,' -g');
      END;
      StringAppend2 (cmd, ' ', ModName); 
      SuBase.SystemCommand (cmd,ok);
      IF NOT ok THEN 
	 WriteString ("Assembler terminated with error"); WriteLn;
	 exit (1);
      END;
   END;
   IF NOT SuBase.Enabled (oAssemblerListing) THEN
      BasicIO.Erase (AsmListFileName,ok);
   END;
	
     | 267 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteString ('Rule 267/2819 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Mark');
       WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

    END;
  END;
END EmitStatement;

PROCEDURE EmitInstruction (e : IR.Expression);
BEGIN
   IF IR.OptEmitIR THEN IR.PrintExpression (e); END;
(*++++++ start insertion IpEmitI1 ++++++*)

      localavail[0] := { ORD (Regeax)-0,  ORD (Regebx)-0,  ORD (Regecx)-0,  ORD (Regedx)-0,  ORD (Regesi)-0,  ORD (Regedi)-0,  ORD (Regst)-0, ORD (Regst1)-0};


(*------ end   insertion IpEmitI1 ------*)
   RegAlloc.RegAllo (e, localavail);
(******* empty insertion IpEmitI2 *******)
   EmitStatement (e);
END EmitInstruction;
 VAR  RegisterSetEmpty : RegisterSet;
BEGIN
  RegisterSetEmpty [0] := {};
(*++++++ start insertion IpEmitInit ++++++*)

    SizeTable [UnsignedByte] := ByteSize;
    SizeTable [UnsignedWord] := WordSize;
    SizeTable [UnsignedLong] := LongSize;
    SizeTable [SignedByte]   := ByteSize;
    SizeTable [SignedWord]   := WordSize;
    SizeTable [SignedLong]   := LongSize;
    SizeTable [FloatShort]   := SizeREAL;
    SizeTable [FloatLong]    := SizeLONGREAL;

    SuffixTable [UnsignedByte] := 'b';
    SuffixTable [UnsignedWord] := 'w';
    SuffixTable [UnsignedLong] := 'l';
    SuffixTable [SignedByte]   := 'b';
    SuffixTable [SignedWord]   := 'w';
    SuffixTable [SignedLong]   := 'l';
    SuffixTable [FloatShort]   := 's';
    SuffixTable [FloatLong]    := 'l';

    SignedTable [UnsignedByte] := FALSE;
    SignedTable [UnsignedWord] := FALSE;
    SignedTable [UnsignedLong] := FALSE;
    SignedTable [SignedByte]   := TRUE;
    SignedTable [SignedWord]   := TRUE;
    SignedTable [SignedLong]   := TRUE;
    SignedTable [FloatShort]   := FALSE;
    SignedTable [FloatLong]    := FALSE;

    RelationTable [RelEqual]	     [FALSE] := 'e';
    RelationTable [RelUnequal]	     [FALSE] := 'ne';
    RelationTable [RelLess]	     [FALSE] := 'b';
    RelationTable [RelLessOrEqual]   [FALSE] := 'be';
    RelationTable [RelGreater]	     [FALSE] := 'a';
    RelationTable [RelGreaterOrEqual][FALSE] := 'ae';
    RelationTable [RelEqual]	     [TRUE ] := 'e';
    RelationTable [RelUnequal]	     [TRUE ] := 'ne';
    RelationTable [RelLess]	     [TRUE ] := 'l';
    RelationTable [RelLessOrEqual]   [TRUE ] := 'le';
    RelationTable [RelGreater]	     [TRUE ] := 'g';
    RelationTable [RelGreaterOrEqual][TRUE ] := 'ge';

    Reverse [RelEqual]		:= RelEqual;
    Reverse [RelUnequal]	:= RelUnequal;
    Reverse [RelLess]		:= RelGreater;
    Reverse [RelLessOrEqual]	:= RelGreaterOrEqual;
    Reverse [RelGreater]	:= RelLess;
    Reverse [RelGreaterOrEqual]	:= RelLessOrEqual;

    PowerTable [0] := 1;
    FOR i := 1 TO MaxPowerTable DO PowerTable [i] := 2 * PowerTable [i-1] END;

    WordReg[Regeax] := '%ax';
    WordReg[Regebx] := '%bx';
    WordReg[Regecx] := '%cx';
    WordReg[Regedx] := '%dx';
    WordReg[Regesi] := '%si';
    WordReg[Regedi] := '%di';
    ByteReg[Regeax] := '%al';
    ByteReg[Regebx] := '%bl';
    ByteReg[Regecx] := '%cl';
    ByteReg[Regedx] := '%dl';

    SuBase.DefineOption (oEmitIR, 'EmitIR', FALSE, FALSE);
    SuBase.DefineOption (oEmitMatch, 'EmitMatch', FALSE, FALSE);
    SuBase.DefineOption (oRegAlloc, 'RegAlloc', FALSE, FALSE);
    SuBase.DefineOption (oAssemblerListing, 'S', FALSE, TRUE);


(*------ end   insertion IpEmitInit ------*)
END Emit.

